#!/usr/bin/env python3
"""
Tokyo Night Qt5 Panel Bar - Dark Night Edition with Integrated STILE Tiling
Complete Xfce4 panel replacement with enhanced dark night theme and built-in window tiling
Featuring subtle animations, night sky gradients, and improved visual effects
"""
import sys
import os
import time
import subprocess
import threading
import re
import json
import signal
import math
import xml.etree.ElementTree as ET
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict
from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QHBoxLayout, 
                            QVBoxLayout, QLabel, QPushButton, QMenu, QSystemTrayIcon,
                            QFrame, QToolButton, QStyle, QAction, QScrollArea,
                            QDialog, QSlider, QCheckBox, QComboBox, QGroupBox,
                            QFormLayout, QSpinBox, QColorDialog, QTabWidget,
                            QSystemTrayIcon, QSizePolicy, QListWidget, QListWidgetItem,
                            QLineEdit, QMessageBox, QInputDialog, QGridLayout)  # Added QGridLayout here
from PyQt5.QtCore import Qt, QTimer, QPoint, QSize, pyqtSignal, QThread, QSettings, QEvent, QPropertyAnimation, QEasingCurve, QObject, QRect
from PyQt5.QtGui import (QIcon, QFont, QPalette, QColor, QPainter, QLinearGradient, 
                        QFontDatabase, QPixmap, QPen, QWheelEvent, QBrush, QRadialGradient, QKeySequence, QCursor)
# Try to import QX11Info from the correct module
try:
    from PyQt5.QtX11Extras import QX11Info
    HAS_X11 = True
except ImportError:
    try:
        from PyQt5.QtGui import QX11Info
        HAS_X11 = True
    except ImportError:
        HAS_X11 = False
        print("Warning: QX11Info not available. Some X11-specific features may be disabled.")

# Enhanced Dark Night Color Palette


class EnhancedNetworkWidget(QWidget):
    """Enhanced network widget with better visual indicators and signal strength monitoring"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.current_ssid = ""
        self.signal_strength = 0
        self.connection_type = ""  # "wifi", "ethernet", "disconnected"
        self.setup_ui()
        self.start_monitoring()

    def setup_ui(self):
        """Setup the enhanced network UI"""
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(5)

        # Network icon with signal strength visualization
        self.network_icon = QLabel("Û∞ñ©")
        self.network_icon.setFixedSize(32, 32)
        self.network_icon.setAlignment(Qt.AlignCenter)
        self.network_icon.setStyleSheet(f"""
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 {TokyoNight.SELECTION}, 
                stop:1 {TokyoNight.NIGHT_BOTTOM});
            border-radius: 6px;
            font-size: 12pt;
        """)
        self.update_network_icon()
        layout.addWidget(self.network_icon)

        # Network info label
        self.network_label = QLabel("Connecting...")
        self.network_label.setStyleSheet(f"""
            padding: 4px 8px;
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 {TokyoNight.SELECTION}, 
                stop:1 {TokyoNight.NIGHT_BOTTOM});
            border-radius: 6px;
            font-size: 9pt;
            color: {TokyoNight.FOREGROUND};
        """)
        layout.addWidget(self.network_label)

        # Signal strength indicator (visual bars)
        self.signal_bars = QWidget()
        self.signal_bars.setFixedSize(20, 16)
        self.signal_bars_layout = QHBoxLayout(self.signal_bars)
        self.signal_bars_layout.setContentsMargins(2, 2, 2, 2)
        self.signal_bars_layout.setSpacing(1)
        
        # Create signal strength bars
        self.bars = []
        for i in range(4):
            bar = QLabel()
            bar.setFixedWidth(3)
            bar.setStyleSheet(f"background: {TokyoNight.COMMENT}; border-radius: 1px;")
            self.signal_bars_layout.addWidget(bar)
            self.bars.append(bar)
        
        layout.addWidget(self.signal_bars)
        self.update_signal_bars()

    def update_network_icon(self):
        """Update network icon based on connection type and strength"""
        if self.connection_type == "wifi":
            # WiFi icons based on signal strength
            if self.signal_strength >= 75:
                icon = "Û∞§®"  # Excellent
            elif self.signal_strength >= 50:
                icon = "Û∞§•"  # Good
            elif self.signal_strength >= 25:
                icon = "Û∞§¢"  # Fair
            else:
                icon = "Û∞§ü"  # Poor
        elif self.connection_type == "ethernet":
            icon = "Û∞àÄ"  # Ethernet icon
        else:
            icon = "Û∞ñ™"  # Disconnected
        
        color = TokyoNight.GREEN if self.connection_type in ["wifi", "ethernet"] else TokyoNight.RED
        self.network_icon.setText(f"<font color='{color}'>{icon}</font>")

    def update_signal_bars(self):
        """Update visual signal strength bars"""
        if self.connection_type != "wifi":
            # Hide bars for non-WiFi connections
            for bar in self.bars:
                bar.setStyleSheet(f"background: {TokyoNight.COMMENT}40; border-radius: 1px;")
            return

        # Calculate how many bars to light up
        active_bars = max(1, min(4, (self.signal_strength + 25) // 25))
        
        for i, bar in enumerate(self.bars):
            if i < active_bars:
                # Color based on signal strength
                if self.signal_strength >= 75:
                    color = TokyoNight.GREEN
                elif self.signal_strength >= 50:
                    color = TokyoNight.YELLOW
                elif self.signal_strength >= 25:
                    color = TokyoNight.ORANGE
                else:
                    color = TokyoNight.RED
                bar.setStyleSheet(f"background: {color}; border-radius: 1px;")
            else:
                bar.setStyleSheet(f"background: {TokyoNight.COMMENT}40; border-radius: 1px;")

    def update_network_info(self):
        """Update network information display"""
        if self.connection_type == "wifi":
            display_text = f"{self.current_ssid[:15]}"
            if self.signal_strength > 0:
                display_text += f" ({self.signal_strength}%)"
            tooltip = f"WiFi: {self.current_ssid}\nSignal: {self.signal_strength}%\nType: {self.connection_type}"
        elif self.connection_type == "ethernet":
            display_text = "Ethernet"
            tooltip = "Wired Ethernet Connection\nType: Ethernet"
        else:
            display_text = "Offline"
            tooltip = "No network connection\nType: Disconnected"
        
        # Set color based on connection status
        if self.connection_type == "wifi":
            if self.signal_strength >= 75:
                color = TokyoNight.GREEN
            elif self.signal_strength >= 50:
                color = TokyoNight.YELLOW
            elif self.signal_strength >= 25:
                color = TokyoNight.ORANGE
            else:
                color = TokyoNight.RED
        elif self.connection_type == "ethernet":
            color = TokyoNight.GREEN
        else:
            color = TokyoNight.RED
        
        self.network_label.setText(f"<font color='{color}'>{display_text}</font>")
        self.network_label.setToolTip(tooltip)
        self.setToolTip(tooltip)

    def get_network_info(self):
        """Get comprehensive network information"""
        try:
            # Try to get WiFi info first
            wifi_result = subprocess.run(
                "iwgetid --raw 2>/dev/null", 
                shell=True, capture_output=True, text=True, timeout=2
            )
            
            if wifi_result.returncode == 0 and wifi_result.stdout.strip():
                ssid = wifi_result.stdout.strip()
                self.connection_type = "wifi"
                self.current_ssid = ssid
                
                # Get WiFi signal strength using multiple methods
                signal_strength = 0
                
                # Method 1: iwconfig
                signal_result = subprocess.run(
                    "iwconfig 2>/dev/null | grep 'Signal level' | awk '{print $4}' | cut -d'=' -f2 | head -1",
                    shell=True, capture_output=True, text=True, timeout=2
                )
                
                if signal_result.returncode == 0 and signal_result.stdout.strip():
                    try:
                        dbm = int(signal_result.stdout.strip())
                        # Rough conversion: -30dBm = 100%, -90dBm = 0%
                        signal_strength = max(0, min(100, int((dbm + 90) * 100 / 60)))
                    except:
                        signal_strength = 0
                
                # Method 2: iw (alternative)
                if signal_strength == 0:
                    iw_result = subprocess.run(
                        "iw dev 2>/dev/null | grep 'signal:' | awk '{print $2}' | head -1",
                        shell=True, capture_output=True, text=True, timeout=2
                    )
                    if iw_result.returncode == 0 and iw_result.stdout.strip():
                        try:
                            dbm = int(iw_result.stdout.strip())
                            signal_strength = max(0, min(100, int((dbm + 90) * 100 / 60)))
                        except:
                            signal_strength = 0
                
                # Method 3: nmcli (fallback)
                if signal_strength == 0:
                    nmcli_result = subprocess.run(
                        "nmcli -t -f active,ssid,signal dev wifi | grep '^yes' | cut -d':' -f3 | head -1",
                        shell=True, capture_output=True, text=True, timeout=2
                    )
                    if nmcli_result.returncode == 0 and nmcli_result.stdout.strip():
                        try:
                            signal_strength = int(nmcli_result.stdout.strip())
                        except:
                            signal_strength = 0
                
                self.signal_strength = signal_strength
                return
            
            # Check for Ethernet connection
            ethernet_result = subprocess.run(
                "ip route show default 2>/dev/null | head -1 | awk '{print $5}'",
                shell=True, capture_output=True, text=True, timeout=2
            )
            
            if ethernet_result.returncode == 0 and ethernet_result.stdout.strip():
                interface = ethernet_result.stdout.strip()
                # Check if it's a physical Ethernet interface (not virtual)
                phys_result = subprocess.run(
                    f"cat /sys/class/net/{interface}/operstate 2>/dev/null",
                    shell=True, capture_output=True, text=True, timeout=1
                )
                if phys_result.returncode == 0 and 'up' in phys_result.stdout.lower():
                    self.connection_type = "ethernet"
                    self.current_ssid = ""
                    self.signal_strength = 0
                    return
            
            # No connection
            self.connection_type = "disconnected"
            self.current_ssid = ""
            self.signal_strength = 0
            
        except Exception as e:
            print(f"Network info error: {e}")
            self.connection_type = "disconnected"
            self.current_ssid = ""
            self.signal_strength = 0

    def start_monitoring(self):
        """Start network monitoring"""
        self.monitor_timer = QTimer()
        self.monitor_timer.timeout.connect(self.refresh_network_info)
        self.monitor_timer.start(3000)  # Update every 3 seconds
        self.refresh_network_info()  # Initial update

    def refresh_network_info(self):
        """Refresh network information and update display"""
        old_connection = self.connection_type
        old_strength = self.signal_strength
        old_ssid = self.current_ssid
        
        self.get_network_info()
        
        # Only update UI if something changed
        if (old_connection != self.connection_type or 
            old_strength != self.signal_strength or
            old_ssid != self.current_ssid):
            self.update_network_icon()
            self.update_signal_bars()
            self.update_network_info()

    def mousePressEvent(self, event):
        """Handle clicks to show network dialog"""
        if event.button() == Qt.LeftButton:
            self.show_network_dialog()

    def show_network_dialog(self):
        """Show enhanced network dialog"""
        try:
            # Import here to avoid circular dependency
            from PyQt5.QtWidgets import QDialog
            dialog = EnhancedWirelessNetworkDialog(self)
            dialog.exec_()
        except Exception as e:
            print(f"Failed to launch network dialog: {e}")







# --- SIMPLE TILER IMPLEMENTATION ---
import math

class AdvancedTiler:
    """Advanced tiling implementation that behaves like cortile with proper window management"""
    
    def __init__(self):
        self._is_active = False
        self._auto_tile = True  # Default to auto-tile
        self._current_layout = "tall"
        self._gap_size = 10
        self._outer_gap = 5
        self._smart_gaps = True
        
        # Advanced cortile-like properties
        self._master_ratio = 0.6
        self._max_master_windows = 1
        self._min_slave_windows = 1
        self._follow_focus = True
        self._border_width = 1
        
        # Window tracking
        self._windows = []  # List of window IDs in stacking order
        self._master_windows = []  # Windows in master area
        self._slave_windows = []  # Windows in slave area
        self._focused_window = None
        
        # Position storage for restoration
        self._original_positions = {}
        self._position_file = Path.home() / ".config" / "tokyo-night-panel" / "window_positions.json"
        self._position_file.parent.mkdir(parents=True, exist_ok=True)
        self._load_window_positions()
        
        # Layout definitions
        self.layouts = {
            "tall": "Tall (Master-Stack)",
            "wide": "Wide (Master-Stack)", 
            "grid": "Grid",
            "monocle": "Monocle",
            "floating": "Floating",
            "spiral": "Spiral",
            "dwindle": "Dwindle",
            "even": "Even Grid",
            "center": "Center Master"
        }
        
        print("INFO: Advanced cortile-like tiler initialized")

    def _load_window_positions(self):
        """Load saved window positions from file"""
        try:
            if self._position_file.exists():
                with open(self._position_file, 'r') as f:
                    self._original_positions = json.load(f)
                print(f"üìÅ Loaded {len(self._original_positions)} saved window positions")
        except Exception as e:
            print(f"Error loading window positions: {e}")
            self._original_positions = {}

    def _save_window_positions(self):
        """Save window positions to file"""
        try:
            with open(self._position_file, 'w') as f:
                json.dump(self._original_positions, f, indent=2)
        except Exception as e:
            print(f"Error saving window positions: {e}")

    def _save_current_window_positions(self):
        """Save current positions of all windows before tiling"""
        try:
            result = subprocess.run("wmctrl -l -G", shell=True, capture_output=True, text=True)
            if result.returncode == 0:
                for line in result.stdout.splitlines():
                    parts = line.split(None, 7)
                    if len(parts) >= 8:
                        window_id = parts[0]
                        if window_id not in self._original_positions:
                            x, y, width, height = int(parts[2]), int(parts[3]), int(parts[4]), int(parts[5])
                            self._original_positions[window_id] = {
                                'x': x, 'y': y, 'width': width, 'height': height,
                                'saved_at': time.time()
                            }
                self._save_window_positions()
        except Exception as e:
            print(f"Error saving current window positions: {e}")

    def _restore_window_positions(self):
        """Restore windows to their original positions"""
        if not self._original_positions:
            return

        restored_count = 0
        try:
            result = subprocess.run("wmctrl -l", shell=True, capture_output=True, text=True)
            current_windows = set()
            if result.returncode == 0:
                for line in result.stdout.splitlines():
                    parts = line.split(None, 3)
                    if len(parts) >= 4:
                        current_windows.add(parts[0])

            for window_id, position_data in self._original_positions.items():
                if window_id in current_windows:
                    x, y, width, height = position_data['x'], position_data['y'], position_data['width'], position_data['height']
                    cmd = f"wmctrl -i -r {window_id} -e 0,{x},{y},{width},{height}"
                    subprocess.run(cmd, shell=True)
                    restored_count += 1

            print(f"‚úÖ Restored {restored_count} windows to original positions")
            self._original_positions.clear()
            self._save_window_positions()
            
        except Exception as e:
            print(f"Error restoring window positions: {e}")

    def _update_window_list(self):
        """Update the internal window list and master/slave assignments"""
        try:
            result = subprocess.run("wmctrl -l", shell=True, capture_output=True, text=True)
            if result.returncode == 0:
                new_windows = []
                for line in result.stdout.splitlines():
                    parts = line.split(None, 3)
                    if len(parts) >= 4 and parts[1] != '-1':  # Skip sticky windows
                        new_windows.append(parts[0])
                
                # Update window list, preserving order where possible
                existing_windows_set = set(self._windows)
                new_windows_set = set(new_windows)
                
                # Add new windows to the end
                for window in new_windows:
                    if window not in existing_windows_set:
                        self._windows.append(window)
                
                # Remove closed windows
                self._windows = [w for w in self._windows if w in new_windows_set]
                
                # Update master/slave assignments
                self._update_master_slave_assignments()
                
        except Exception as e:
            print(f"Error updating window list: {e}")

    def _update_master_slave_assignments(self):
        """Update master and slave window assignments"""
        if not self._windows:
            self._master_windows = []
            self._slave_windows = []
            return
            
        # Ensure we have at least one master window
        if not self._master_windows or self._master_windows[0] not in self._windows:
            if self._windows:
                self._master_windows = [self._windows[0]]
            else:
                self._master_windows = []
        
        # All other windows are slaves
        self._slave_windows = [w for w in self._windows if w not in self._master_windows]
        
        # Limit master windows
        if len(self._master_windows) > self._max_master_windows:
            excess_windows = self._master_windows[self._max_master_windows:]
            self._slave_windows.extend(excess_windows)
            self._master_windows = self._master_windows[:self._max_master_windows]

    def _get_screen_geometry(self):
        """Get current screen geometry"""
        try:
            result = subprocess.run("xdotool getdisplaygeometry", shell=True, capture_output=True, text=True)
            if result.returncode == 0:
                width, height = map(int, result.stdout.split())
                return width, height
        except Exception as e:
            print(f"Error getting screen geometry: {e}")
        return 1920, 1080  # Fallback

    def _calculate_smart_gaps(self, window_count):
        """Calculate smart gaps based on window count"""
        if not self._smart_gaps or window_count <= 1:
            return self._gap_size, self._outer_gap
        
        gap_reduction = max(0, (window_count - 2) * 2)
        smart_gap = max(2, self._gap_size - gap_reduction)
        smart_outer = max(2, self._outer_gap - (gap_reduction // 2))
        
        return smart_gap, smart_outer

    def _get_usable_area(self, width, height, outer_gap):
        """Calculate usable area after accounting for gaps"""
        usable_width = width - (2 * outer_gap)
        usable_height = height - (2 * outer_gap)
        return usable_width, usable_height, outer_gap, outer_gap

    import math # Add this import if not already present


    # Inside the AdvancedTiler class definition:
    def _tile_tall_master_stack(self, width, height):
        """Tall layout with master and stack areas (cortile style) - Improved Alignment"""
        smart_gap, outer_gap = self._calculate_smart_gaps(len(self._windows))
        usable_width, usable_height, start_x, start_y = self._get_usable_area(width, height, outer_gap)

        if not self._windows:
            return

        # Calculate master area (left)
        if self._master_windows:
            master_width = int(usable_width * self._master_ratio)
            # Calculate available height for masters considering gaps between them
            total_master_gaps = (len(self._master_windows) - 1) * smart_gap if len(self._master_windows) > 1 else 0
            total_available_height_for_masters = usable_height - total_master_gaps
            # Calculate base height and distribute rounding error
            base_master_height = total_available_height_for_masters // len(self._master_windows)
            remaining_height_error = total_available_height_for_masters % len(self._master_windows)

            current_y = start_y
            for i, win_id in enumerate(self._master_windows):
                # Distribute the rounding error: first 'remaining_height_error' windows get +1 pixel
                current_height = base_master_height + (1 if i < remaining_height_error else 0)
                subprocess.run(f"wmctrl -i -r {win_id} -e 0,{start_x},{current_y},{master_width},{current_height}", shell=True)
                current_y += current_height + smart_gap # Update Y for the next window
                # Note: The last master window will end at current_y - smart_gap,
                # which should align correctly with the start of the slave area if calculated properly below.

        # Calculate slave area (right)
        if self._slave_windows:
            # The slave area starts after the master area plus the gap between master and slave
            slave_x = start_x + master_width + smart_gap # Use calculated master_width
            slave_width = usable_width - master_width - smart_gap # Calculate remaining width
            # Calculate available height for slaves considering gaps between them
            total_slave_gaps = (len(self._slave_windows) - 1) * smart_gap if len(self._slave_windows) > 1 else 0
            total_available_height_for_slaves = usable_height - total_slave_gaps
            # Calculate base height and distribute rounding error
            base_slave_height = total_available_height_for_slaves // len(self._slave_windows)
            remaining_slave_height_error = total_available_height_for_slaves % len(self._slave_windows)

            current_y = start_y # Slaves start at the same Y as masters
            for i, win_id in enumerate(self._slave_windows):
                # Distribute the rounding error: first 'remaining_slave_height_error' windows get +1 pixel
                current_height = base_slave_height + (1 if i < remaining_slave_height_error else 0)
                subprocess.run(f"wmctrl -i -r {win_id} -e 0,{slave_x},{current_y},{slave_width},{current_height}", shell=True)
                current_y += current_height + smart_gap # Update Y for the next window
                # Note: The last slave window will end at current_y - smart_gap.
                # The total height used by masters/slaves should ideally match usable_height.

    def _tile_wide_master_stack(self, width, height):
        """Wide layout with master and stack areas"""
        smart_gap, outer_gap = self._calculate_smart_gaps(len(self._windows))
        usable_width, usable_height, start_x, start_y = self._get_usable_area(width, height, outer_gap)
        
        if not self._windows:
            return

        # Master area (top)
        if self._master_windows:
            master_height = int(usable_height * self._master_ratio)
            master_width = usable_width // len(self._master_windows)
            
            for i, win_id in enumerate(self._master_windows):
                x_pos = start_x + (i * master_width)
                if i > 0:
                    x_pos += smart_gap * i
                subprocess.run(f"wmctrl -i -r {win_id} -e 0,{x_pos},{start_y},{master_width},{master_height}", shell=True)

        # Slave area (bottom)
        if self._slave_windows:
            slave_y = start_y + int(usable_height * self._master_ratio) + smart_gap
            slave_height = usable_height - int(usable_height * self._master_ratio) - smart_gap
            slave_width = usable_width // len(self._slave_windows) if self._slave_windows else 0
            
            for i, win_id in enumerate(self._slave_windows):
                x_pos = start_x + (i * slave_width)
                if i > 0:
                    x_pos += smart_gap * i
                subprocess.run(f"wmctrl -i -r {win_id} -e 0,{x_pos},{slave_y},{slave_width},{slave_height}", shell=True)

    def _tile_grid(self, width, height):
        """Grid layout"""
        smart_gap, outer_gap = self._calculate_smart_gaps(len(self._windows))
        usable_width, usable_height, start_x, start_y = self._get_usable_area(width, height, outer_gap)
        
        cols = int(math.ceil(math.sqrt(len(self._windows))))
        rows = int(math.ceil(len(self._windows) / cols))
        
        cell_width = (usable_width - (smart_gap * (cols - 1))) // cols
        cell_height = (usable_height - (smart_gap * (rows - 1))) // rows
        
        for i, win_id in enumerate(self._windows):
            col = i % cols
            row = i // cols
            x = start_x + (col * (cell_width + smart_gap))
            y = start_y + (row * (cell_height + smart_gap))
            subprocess.run(f"wmctrl -i -r {win_id} -e 0,{x},{y},{cell_width},{cell_height}", shell=True)

    def _tile_even_grid(self, width, height):
        """Even grid layout (equal spacing)"""
        smart_gap, outer_gap = self._calculate_smart_gaps(len(self._windows))
        usable_width, usable_height, start_x, start_y = self._get_usable_area(width, height, outer_gap)
        
        if not self._windows:
            return
            
        # Calculate optimal grid that fits all windows evenly
        best_fit = None
        best_waste = float('inf')
        
        for cols in range(1, len(self._windows) + 1):
            rows = math.ceil(len(self._windows) / cols)
            cell_width = (usable_width - (smart_gap * (cols - 1))) // cols
            cell_height = (usable_height - (smart_gap * (rows - 1))) // rows
            
            # Calculate wasted space
            used_width = cols * cell_width + (cols - 1) * smart_gap
            used_height = rows * cell_height + (rows - 1) * smart_gap
            waste = (usable_width - used_width) ** 2 + (usable_height - used_height) ** 2
            
            if waste < best_waste:
                best_waste = waste
                best_fit = (cols, rows, cell_width, cell_height)
        
        if best_fit:
            cols, rows, cell_width, cell_height = best_fit
            for i, win_id in enumerate(self._windows):
                col = i % cols
                row = i // cols
                x = start_x + (col * (cell_width + smart_gap))
                y = start_y + (row * (cell_height + smart_gap))
                subprocess.run(f"wmctrl -i -r {win_id} -e 0,{x},{y},{cell_width},{cell_height}", shell=True)

    def _tile_center_master(self, width, height):
        """Center master layout (master in center, slaves around)"""
        smart_gap, outer_gap = self._calculate_smart_gaps(len(self._windows))
        usable_width, usable_height, start_x, start_y = self._get_usable_area(width, height, outer_gap)
        
        if not self._windows:
            return
            
        if self._master_windows:
            # Center master window(s)
            master_count = len(self._master_windows)
            if master_count == 1:
                # Single master in center
                master_width = usable_width // 2
                master_height = usable_height // 2
                master_x = start_x + (usable_width - master_width) // 2
                master_y = start_y + (usable_height - master_height) // 2
                subprocess.run(f"wmctrl -i -r {self._master_windows[0]} -e 0,{master_x},{master_y},{master_width},{master_height}", shell=True)
            else:
                # Multiple masters in center row
                master_width = usable_width // master_count
                master_height = usable_height // 2
                master_y = start_y + (usable_height - master_height) // 2
                
                for i, win_id in enumerate(self._master_windows):
                    master_x = start_x + (i * master_width)
                    if i > 0:
                        master_x += smart_gap * i
                    subprocess.run(f"wmctrl -i -r {win_id} -e 0,{master_x},{master_y},{master_width},{master_height}", shell=True)
        
        # Tile slaves around the center
        if self._slave_windows:
            slave_positions = []
            slave_count = len(self._slave_windows)
            
            if slave_count >= 1:
                # Top
                slave_positions.append(("top", 0))
            if slave_count >= 2:
                # Right
                slave_positions.append(("right", 1))
            if slave_count >= 3:
                # Bottom
                slave_positions.append(("bottom", 2))
            if slave_count >= 4:
                # Left
                slave_positions.append(("left", 3))
            
            for i, (position, slave_index) in enumerate(slave_positions):
                if slave_index < len(self._slave_windows):
                    win_id = self._slave_windows[slave_index]
                    
                    if position == "top":
                        slave_width = usable_width // 2
                        slave_height = usable_height // 4
                        slave_x = start_x + (usable_width - slave_width) // 2
                        slave_y = start_y
                    elif position == "right":
                        slave_width = usable_width // 4
                        slave_height = usable_height // 2
                        slave_x = start_x + usable_width - slave_width
                        slave_y = start_y + (usable_height - slave_height) // 2
                    elif position == "bottom":
                        slave_width = usable_width // 2
                        slave_height = usable_height // 4
                        slave_x = start_x + (usable_width - slave_width) // 2
                        slave_y = start_y + usable_height - slave_height
                    else:  # left
                        slave_width = usable_width // 4
                        slave_height = usable_height // 2
                        slave_x = start_x
                        slave_y = start_y + (usable_height - slave_height) // 2
                    
                    subprocess.run(f"wmctrl -i -r {win_id} -e 0,{slave_x},{slave_y},{slave_width},{slave_height}", shell=True)

    def _tile_monocle(self, width, height):
        """Monocle layout (fullscreen)"""
        smart_gap, outer_gap = self._calculate_smart_gaps(len(self._windows))
        usable_width, usable_height, start_x, start_y = self._get_usable_area(width, height, outer_gap)
        
        for win_id in self._windows:
            subprocess.run(f"wmctrl -i -r {win_id} -e 0,{start_x},{start_y},{usable_width},{usable_height}", shell=True)

    def _apply_layout(self):
        """Apply the current layout to all windows"""
        if not self._is_active or self._current_layout == "floating":
            return
            
        width, height = self._get_screen_geometry()
        
        if self._current_layout == "tall":
            self._tile_tall_master_stack(width, height)
        elif self._current_layout == "wide":
            self._tile_wide_master_stack(width, height)
        elif self._current_layout == "grid":
            self._tile_grid(width, height)
        elif self._current_layout == "even":
            self._tile_even_grid(width, height)
        elif self._current_layout == "center":
            self._tile_center_master(width, height)
        elif self._current_layout == "monocle":
            self._tile_monocle(width, height)
        elif self._current_layout == "spiral":
            self._tile_spiral(width, height)
        elif self._current_layout == "dwindle":
            self._tile_dwindle(width, height)

    # Window management methods (cortile-like)
    def add_window(self, window_id):
        """Add a window to the tiling manager"""
        if window_id not in self._windows:
            self._windows.append(window_id)
            self._update_master_slave_assignments()
            if self._is_active and self._auto_tile:
                self._apply_layout()

    def remove_window(self, window_id):
        """Remove a window from the tiling manager"""
        if window_id in self._windows:
            self._windows.remove(window_id)
            if window_id in self._master_windows:
                self._master_windows.remove(window_id)
            if window_id in self._slave_windows:
                self._slave_windows.remove(window_id)
            self._update_master_slave_assignments()
            if self._is_active and self._auto_tile:
                self._apply_layout()

    def focus_window(self, window_id):
        """Focus a window and bring it to front"""
        if window_id in self._windows:
            subprocess.run(f"wmctrl -i -a {window_id}", shell=True)
            self._focused_window = window_id
            
            # Follow focus behavior
            if self._follow_focus and window_id in self._slave_windows:
                self.promote_to_master(window_id)

    def promote_to_master(self, window_id):
        """Promote a window to master area"""
        if window_id in self._slave_windows:
            self._slave_windows.remove(window_id)
            self._master_windows.insert(0, window_id)
            
            # Ensure we don't exceed max master windows
            if len(self._master_windows) > self._max_master_windows:
                demoted = self._master_windows.pop()
                self._slave_windows.insert(0, demoted)
            
            if self._is_active and self._auto_tile:
                self._apply_layout()

    def demote_to_slave(self, window_id):
        """Demote a window to slave area"""
        if window_id in self._master_windows:
            self._master_windows.remove(window_id)
            self._slave_windows.insert(0, window_id)
            if self._is_active and self._auto_tile:
                self._apply_layout()

    def swap_with_master(self):
        """Swap focused window with master"""
        if self._focused_window and self._focused_window in self._slave_windows and self._master_windows:
            # Swap focused slave with first master
            slave_index = self._slave_windows.index(self._focused_window)
            master_window = self._master_windows[0]
            
            self._slave_windows[slave_index] = master_window
            self._master_windows[0] = self._focused_window
            
            if self._is_active and self._auto_tile:
                self._apply_layout()

    def rotate_master(self):
        """Rotate windows in master area"""
        if len(self._master_windows) > 1:
            self._master_windows = self._master_windows[1:] + [self._master_windows[0]]
            if self._is_active and self._auto_tile:
                self._apply_layout()

    def rotate_stack(self):
        """Rotate windows in slave area"""
        if len(self._slave_windows) > 1:
            self._slave_windows = self._slave_windows[1:] + [self._slave_windows[0]]
            if self._is_active and self._auto_tile:
                self._apply_layout()

    def increase_master_count(self):
        """Increase number of windows in master area"""
        if self._slave_windows and self._max_master_windows < len(self._windows):
            self._max_master_windows += 1
            new_master = self._slave_windows.pop(0)
            self._master_windows.append(new_master)
            if self._is_active and self._auto_tile:
                self._apply_layout()

    def decrease_master_count(self):
        """Decrease number of windows in master area"""
        if self._master_windows and self._max_master_windows > 1:
            self._max_master_windows -= 1
            demoted = self._master_windows.pop()
            self._slave_windows.insert(0, demoted)
            if self._is_active and self._auto_tile:
                self._apply_layout()

    def increase_master_size(self):
        """Increase master area size"""
        self._master_ratio = min(0.8, self._master_ratio + 0.05)
        if self._is_active and self._auto_tile:
            self._apply_layout()

    def decrease_master_size(self):
        """Decrease master area size"""
        self._master_ratio = max(0.2, self._master_ratio - 0.05)
        if self._is_active and self._auto_tile:
            self._apply_layout()

    # Public interface
    def toggle_tiling(self):
        """Toggle tiling on/off"""
        was_active = self._is_active
        self._is_active = not self._is_active
        
        if self._is_active:
            # Turning ON - save positions and tile
            print("üíæ Saving window positions before tiling...")
            self._save_current_window_positions()
            self._update_window_list()
            print("Tiling activated")
            self._apply_layout()
        else:
            # Turning OFF - restore positions
            print("Tiling deactivated - restoring window positions...")
            self._restore_window_positions()

    def set_layout(self, layout_name):
        """Set specific layout"""
        if layout_name in self.layouts:
            self._current_layout = layout_name
            print(f"Layout set to: {layout_name}")
            if self._is_active and self._auto_tile:
                self._apply_layout()

    def apply_layout(self):
        """Apply the current layout"""
        self._update_window_list()
        self._apply_layout()

    def restore_all_windows(self):
        """Force restore all windows to their original positions"""
        print("üîÑ Force restoring all windows to original positions...")
        self._restore_window_positions()

    def save_current_layout(self):
        """Save current window positions as the 'restore' state"""
        print("üíæ Saving current window positions as restore state...")
        self._save_current_window_positions()

    def clear_saved_positions(self):
        """Clear all saved window positions"""
        print("üóëÔ∏è  Clearing all saved window positions...")
        self._original_positions.clear()
        self._save_window_positions()

    # Property accessors
    @property
    def is_active(self):
        return self._is_active
    
    @property 
    def auto_tile(self):
        return self._auto_tile
    
    def toggle_auto_tile(self):
        self._auto_tile = not self._auto_tile
        print(f"Auto-tile {'enabled' if self._auto_tile else 'disabled'}")
    
    @property
    def current_layout(self):
        return self._current_layout
    
    @property
    def master_ratio(self):
        return self._master_ratio
    
    @property
    def max_master_windows(self):
        return self._max_master_windows
    
    @property
    def gap_size(self):
        return self._gap_size
    
    @property
    def outer_gap(self):
        return self._outer_gap
    
    @property
    def smart_gaps(self):
        return self._smart_gaps
    
    @property
    def follow_focus(self):
        return self._follow_focus
    
    def set_gap_size(self, size):
        self._gap_size = max(0, min(50, size))
        if self._is_active and self._auto_tile:
            self._apply_layout()
    
    def set_outer_gap(self, size):
        self._outer_gap = max(0, min(20, size))
        if self._is_active and self._auto_tile:
            self._apply_layout()
    
    def toggle_smart_gaps(self):
        self._smart_gaps = not self._smart_gaps
        if self._is_active and self._auto_tile:
            self._apply_layout()
    
    def toggle_follow_focus(self):
        self._follow_focus = not self._follow_focus
        print(f"Follow focus {'enabled' if self._follow_focus else 'disabled'}")

    def cleanup(self):
        """Cleanup resources"""
        pass

    # Spiral and Dwindle layouts (kept for compatibility)
    def _tile_spiral(self, width, height):
        """Spiral layout fallback to grid"""
        self._tile_grid(width, height)

    def _tile_dwindle(self, width, height):
        """Dwindle layout fallback to grid"""
        self._tile_grid(width, height)

class CortileAdapter(QObject):
    """Advanced cortile-like adapter with proper window management"""
    
    def __init__(self):
        super().__init__()
        self.cortile_instance = AdvancedTiler()
        
        self.layouts = self.cortile_instance.layouts
        self.current_layout = self.cortile_instance.current_layout

        # Expose all properties
        self.gap_size = self.cortile_instance.gap_size
        self.outer_gap = self.cortile_instance.outer_gap
        self.smart_gaps = self.cortile_instance.smart_gaps
        self.master_ratio = self.cortile_instance.master_ratio
        self.max_master_windows = self.cortile_instance.max_master_windows
        self.follow_focus = self.cortile_instance.follow_focus

    # Core tiling methods
    def toggle_tiling(self):
        self.cortile_instance.toggle_tiling()
        self.current_layout = self.cortile_instance.current_layout

    def set_layout(self, layout_name):
        self.cortile_instance.set_layout(layout_name)
        self.current_layout = layout_name

    def apply_layout(self):
        self.cortile_instance.apply_layout()

    # Restoration methods
    def restore_all_windows(self):
        self.cortile_instance.restore_all_windows()

    def save_current_layout(self):
        self.cortile_instance.save_current_layout()

    def clear_saved_positions(self):
        self.cortile_instance.clear_saved_positions()

    # Gap control
    def set_gap_size(self, size):
        self.cortile_instance.set_gap_size(size)
        self.gap_size = self.cortile_instance.gap_size

    def set_outer_gap(self, size):
        self.cortile_instance.set_outer_gap(size)
        self.outer_gap = self.cortile_instance.outer_gap

    def toggle_smart_gaps(self):
        self.cortile_instance.toggle_smart_gaps()
        self.smart_gaps = self.cortile_instance.smart_gaps

    # Master area control
    def set_master_ratio(self, ratio):
        self.cortile_instance._master_ratio = max(0.2, min(0.8, ratio))
        self.master_ratio = self.cortile_instance._master_ratio
        if self.cortile_instance.is_active and self.cortile_instance.auto_tile:
            self.cortile_instance._apply_layout()

    def set_max_master_windows(self, count):
        self.cortile_instance._max_master_windows = max(1, min(5, count))
        self.max_master_windows = self.cortile_instance._max_master_windows
        self.cortile_instance._update_master_slave_assignments()
        if self.cortile_instance.is_active and self.cortile_instance.auto_tile:
            self.cortile_instance._apply_layout()

    def toggle_follow_focus(self):
        self.cortile_instance.toggle_follow_focus()
        self.follow_focus = self.cortile_instance.follow_focus

    # Advanced window management (cortile-like)
    def promote_to_master(self):
        """Promote focused window to master"""
        if self.cortile_instance._focused_window:
            self.cortile_instance.promote_to_master(self.cortile_instance._focused_window)

    def demote_to_slave(self):
        """Demote focused window to slave"""
        if self.cortile_instance._focused_window:
            self.cortile_instance.demote_to_slave(self.cortile_instance._focused_window)

    def swap_with_master(self):
        """Swap focused window with master"""
        self.cortile_instance.swap_with_master()

    def rotate_master(self):
        """Rotate master windows"""
        self.cortile_instance.rotate_master()

    def rotate_stack(self):
        """Rotate slave windows"""
        self.cortile_instance.rotate_stack()

    def increase_master_count(self):
        """Increase master window count"""
        self.cortile_instance.increase_master_count()
        self.max_master_windows = self.cortile_instance.max_master_windows

    def decrease_master_count(self):
        """Decrease master window count"""
        self.cortile_instance.decrease_master_count()
        self.max_master_windows = self.cortile_instance.max_master_windows

    def increase_master_size(self):
        """Increase master area size"""
        self.cortile_instance.increase_master_size()
        self.master_ratio = self.cortile_instance.master_ratio

    def decrease_master_size(self):
        """Decrease master area size"""
        self.cortile_instance.decrease_master_size()
        self.master_ratio = self.cortile_instance.master_ratio

    def focus_next_window(self):
        """Focus next window in stacking order"""
        try:
            if self.cortile_instance._windows:
                current_index = 0
                if self.cortile_instance._focused_window and self.cortile_instance._focused_window in self.cortile_instance._windows:
                    current_index = self.cortile_instance._windows.index(self.cortile_instance._focused_window)
                
                next_index = (current_index + 1) % len(self.cortile_instance._windows)
                next_window = self.cortile_instance._windows[next_index]
                self.cortile_instance.focus_window(next_window)
        except Exception as e:
            print(f"Focus next window error: {e}")

    def focus_previous_window(self):
        """Focus previous window in stacking order"""
        try:
            if self.cortile_instance._windows:
                current_index = 0
                if self.cortile_instance._focused_window and self.cortile_instance._focused_window in self.cortile_instance._windows:
                    current_index = self.cortile_instance._windows.index(self.cortile_instance._focused_window)
                
                prev_index = (current_index - 1) % len(self.cortile_instance._windows)
                prev_window = self.cortile_instance._windows[prev_index]
                self.cortile_instance.focus_window(prev_window)
        except Exception as e:
            print(f"Focus previous window error: {e}")

    @property
    def is_active(self):
        """Check if tiling is currently active."""
        return self.cortile_instance.is_active

    @property
    def auto_tile(self):
        """Check if auto-tiling is enabled."""
        return self.cortile_instance.auto_tile

    def toggle_auto_tile(self):
        """Toggle auto-tiling."""
        self.cortile_instance.toggle_auto_tile()

    def cleanup(self):
        """Cleanup resources."""
        self.cortile_instance.cleanup()
























class TokyoNight:
    # Base colors - deeper, more night-like
    BACKGROUND = "#0d0f1a"  # Deeper dark blue-black
    FOREGROUND = "#c0caf5"
    # Content colors
    COMMENT = "#3a415e"  # Slightly lighter comment color
    SELECTION = "#1a2332"  # Darker selection
    # Ansi colors - adjusted for night theme
    BLACK = "#0a0b14"  # Almost pure black
    RED = "#f7768e"
    GREEN = "#9ece6a"
    YELLOW = "#e0af68"
    BLUE = "#5a7fc7"  # Slightly muted blue
    PURPLE = "#9b7fc7"  # Muted purple
    CYAN = "#5abfcf"  # Muted cyan
    WHITE = "#a9b1d6"
    # Bright colors - adjusted for night theme
    BRIGHT_BLACK = "#2a3146"  # Darker bright black
    BRIGHT_RED = "#f7768e"
    BRIGHT_GREEN = "#9ece6a"
    BRIGHT_YELLOW = "#e0af68"
    BRIGHT_BLUE = "#5a7fc7"  # Muted bright blue
    BRIGHT_PURPLE = "#9b7fc7"  # Muted bright purple
    BRIGHT_CYAN = "#5abfcf"  # Muted bright cyan
    BRIGHT_WHITE = "#c0caf5"
    # Additional accents - night-themed
    ORANGE = "#ff9e64"
    PINK = "#ff007c"
    TEAL = "#2ac3de"
    # Night sky gradient colors
    NIGHT_TOP = "#0a0b14"  # Deep space black
    NIGHT_BOTTOM = "#1a1b26"  # Tokyo night background
    NIGHT_HIGHLIGHT = "#1f2335"  # Subtle highlight
    # Moon and stars colors
    MOON_GLOW = "#e0e6ff"  # Soft moon glow
    STAR_COLOR = "#ffffff"  # White stars
    NEBULA = "#3a415e"  # Nebula clouds

@dataclass
class Application:
    name: str
    command: str
    icon: str = "üöÄ"
    args: str = ""  # Additional arguments for the command
    workspace: int = -1  # -1 means current workspace, 0+ means specific workspace

@dataclass
class Window:
    id: str
    desktop: int
    pid: int
    x: int
    y: int
    width: int
    height: int
    title: str
    class_name: str


import subprocess
import os
import signal
import threading
import time
import re

class NonBlockingProcess:
    """
    Helper class for non-blocking subprocess execution with timeouts
    and comprehensive error handling to prevent freezing.
    """
    
    @staticmethod
    def run_command(cmd, timeout=2, shell=False, capture_output=True):
        """
        Run command with timeout protection and non-blocking behavior
        
        Args:
            cmd: Command to run (list for shell=False, string for shell=True)
            timeout: Maximum time to wait for command completion
            shell: Whether to use shell execution
            capture_output: Whether to capture stdout/stderr
            
        Returns:
            tuple: (success, stdout, stderr)
        """
        stdout_data = ""
        stderr_data = ""
        
        try:
            # Format command properly
            if shell and isinstance(cmd, list):
                cmd = " ".join(cmd)
            elif not shell and isinstance(cmd, str):
                cmd = cmd.split()
                
            # Prepare subprocess arguments
            kwargs = {
                'shell': shell,
                'start_new_session': True  # Important for proper signal handling
            }
            
            if capture_output:
                kwargs.update({
                    'stdout': subprocess.PIPE,
                    'stderr': subprocess.PIPE,
                    'text': True
                })
            else:
                kwargs.update({
                    'stdout': subprocess.DEVNULL,
                    'stderr': subprocess.DEVNULL
                })
            
            process = subprocess.Popen(cmd, **kwargs)
            
            try:
                if capture_output:
                    stdout, stderr = process.communicate(timeout=timeout)
                    stdout_data = stdout.strip() if stdout else ""
                    stderr_data = stderr.strip() if stderr else ""
                else:
                    process.wait(timeout=timeout)
                
                success = (process.returncode == 0)
                return success, stdout_data, stderr_data
                
            except subprocess.TimeoutExpired:
                # Kill the entire process group to ensure cleanup
                print(f"‚è∞ Command timeout after {timeout}s: {cmd}")
                NonBlockingProcess._kill_process_tree(process)
                return False, "", "Timeout"
                
        except FileNotFoundError as e:
            print(f"üìÅ Command not found: {cmd} - {e}")
            return False, "", "Command not found"
        except Exception as e:
            print(f"‚ùå Command execution error: {cmd} - {e}")
            return False, "", str(e)
    
    @staticmethod
    def _kill_process_tree(process):
        """Kill process and all its children"""
        try:
            # Try to kill the entire process group
            pgid = os.getpgid(process.pid)
            os.killpg(pgid, signal.SIGTERM)
            
            # Wait a bit for graceful termination
            try:
                process.wait(timeout=1)
            except subprocess.TimeoutExpired:
                # Force kill if still running
                os.killpg(pgid, signal.SIGKILL)
                process.wait()
        except ProcessLookupError:
            # Process already dead
            pass
        except Exception as e:
            print(f"‚ö†Ô∏è  Process tree kill warning: {e}")
            # Fallback: just kill the main process
            try:
                process.kill()
                process.wait()
            except:
                pass
    
    @staticmethod
    def run_background(cmd, shell=True, description=""):
        """
        Run command in background without waiting for completion
        
        Args:
            cmd: Command to run
            shell: Whether to use shell execution
            description: Description for logging
            
        Returns:
            bool: True if process started successfully
        """
        try:
            process = subprocess.Popen(
                cmd,
                shell=shell,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                start_new_session=True
            )
            if description:
                print(f"üöÄ Started background process: {description}")
            return True
        except Exception as e:
            print(f"‚ùå Background command failed: {description} - {e}")
            return False
    
    @staticmethod
    def run_with_callback(cmd, callback, timeout=2, shell=False, description=""):
        """
        Run command and call callback with result in a separate thread
        
        Args:
            cmd: Command to run
            callback: Function to call with (success, stdout, stderr)
            timeout: Command timeout
            shell: Whether to use shell execution
            description: Description for logging
        """
        def run_in_thread():
            if description:
                print(f"üßµ Starting threaded command: {description}")
            
            success, stdout, stderr = NonBlockingProcess.run_command(cmd, timeout, shell)
            
            if description:
                status = "‚úÖ" if success else "‚ùå"
                print(f"{status} Threaded command completed: {description}")
            
            try:
                callback(success, stdout, stderr)
            except Exception as e:
                print(f"‚ö†Ô∏è  Callback error for {description}: {e}")
        
        thread = threading.Thread(target=run_in_thread, daemon=True)
        thread.start()
        return thread
    
    @staticmethod
    def run_series(commands, timeout_per_command=2, shell=False):
        """
        Run a series of commands with individual timeouts
        
        Args:
            commands: List of commands to run
            timeout_per_command: Timeout for each command
            shell: Whether to use shell execution
            
        Returns:
            list: List of (success, stdout, stderr) tuples
        """
        results = []
        for i, cmd in enumerate(commands):
            print(f"üîß Running command {i+1}/{len(commands)}: {cmd}")
            result = NonBlockingProcess.run_command(cmd, timeout_per_command, shell)
            results.append(result)
            
            # Small delay between commands
            time.sleep(0.1)
        
        return results
    
    @staticmethod
    def check_command_available(cmd, check_cmd=None):
        """
        Check if a command is available in the system
        
        Args:
            cmd: Command to check
            check_cmd: Alternative command to check availability
            
        Returns:
            bool: True if command is available
        """
        test_cmd = check_cmd or ["which", cmd] if isinstance(cmd, str) else cmd
        
        success, stdout, stderr = NonBlockingProcess.run_command(
            test_cmd, timeout=1, shell=isinstance(test_cmd, str)
        )
        
        available = success and stdout.strip() != ""
        status = "‚úÖ" if available else "‚ùå"
        print(f"{status} Command availability: {cmd} - {'Available' if available else 'Not available'}")
        
        return available
    
    @staticmethod
    def get_command_output(cmd, timeout=2, shell=False, default=""):
        """
        Get command output with safe defaults
        
        Args:
            cmd: Command to run
            timeout: Command timeout
            shell: Whether to use shell execution
            default: Default value if command fails
            
        Returns:
            str: Command output or default value
        """
        success, stdout, stderr = NonBlockingProcess.run_command(cmd, timeout, shell)
        return stdout if success and stdout else default







import subprocess
import os
import time
import re
from PyQt5.QtCore import QThread, pyqtSignal

class SystemMonitorThread(QThread):
    """
    System monitoring thread with non-blocking operations and comprehensive
    error handling to prevent freezing the main GUI.
    """
    
    # Signals for UI updates
    cpu_updated = pyqtSignal(float)
    memory_updated = pyqtSignal(float)
    battery_updated = pyqtSignal(int, str, str)  # capacity, status, time
    volume_updated = pyqtSignal(int, bool)
    network_updated = pyqtSignal(str, str)  # ssid, status
    brightness_updated = pyqtSignal(int)
    workspace_updated = pyqtSignal(int)
    active_window_updated = pyqtSignal(str)
    monitor_status = pyqtSignal(str)  # Status messages
    
    def __init__(self):
        super().__init__()
        self.battery_path = self.find_battery_path()
        self.error_count = 0
        self.max_errors = 10
        self._stop_flag = False
        self.iteration_count = 0
        self.last_successful_update = time.time()
        
        # Command availability cache
        self._command_cache = {}
        
        print("üîç System Monitor Thread initialized")

    def find_battery_path(self):
        """Find the correct battery path using non-blocking methods"""
        battery_base = "/sys/class/power_supply"
        try:
            if os.path.exists(battery_base):
                devices = os.listdir(battery_base)
                for device in devices:
                    if device.startswith(('BAT', 'bat')):
                        capacity_file = os.path.join(battery_base, device, 'capacity')
                        if os.path.exists(capacity_file):
                            print(f"üîã Found battery: {device}")
                            return os.path.join(battery_base, device)
        except Exception as e:
            print(f"‚ö†Ô∏è  Battery path discovery error: {e}")
        
        print("‚ö†Ô∏è  Using default battery path")
        return os.path.join(battery_base, 'BAT0')

    def stop(self):
        """Stop the monitoring thread gracefully"""
        print("üõë Stopping system monitor thread...")
        self._stop_flag = True
        self.wait(3000)  # Wait up to 3 seconds for clean shutdown

    def run(self):
        """Main monitoring loop with non-blocking operations and comprehensive
        error handling to prevent freezing.
        """
        
        # Signals for UI updates
        cpu_updated = pyqtSignal(float)
        memory_updated = pyqtSignal(float)
        battery_updated = pyqtSignal(int, str, str)  # capacity, status, time
        volume_updated = pyqtSignal(int, bool)
        network_updated = pyqtSignal(str, str)  # ssid, status
        brightness_updated = pyqtSignal(int)
        workspace_updated = pyqtSignal(int)
        active_window_updated = pyqtSignal(str)
        # FIXED: Remove monitor_status signal or ensure it emits proper types

        def __init__(self):
            super().__init__()
            self.battery_path = self.find_battery_path()
            self.error_count = 0
            self.max_errors = 10
            self._stop_flag = False
            self.iteration_count = 0
            self.last_successful_update = time.time()
            
            # Command availability cache
            self._command_cache = {}
            
            print("üîç System Monitor Thread initialized")

        def run(self):
            """Main monitoring loop with comprehensive error handling"""
            self.prev_cpu_total = 0
            self.prev_cpu_idle = 0
            
            print("üöÄ System monitor thread started")
            # FIXED: Remove the problematic signal emission
            # self.monitor_status.emit("started")  # This was causing the error
            
            while not self._stop_flag:
                self.iteration_count += 1
                
                try:
                    if self.iteration_count % 10 == 0:
                        print(f"üîç Monitor iteration {self.iteration_count}, errors: {self.error_count}")
                    
                    # Update all system metrics
                    self.update_cpu_usage()
                    self.update_memory_usage()
                    self.update_battery_info()
                    self.update_volume_info()
                    self.update_network_info()
                    
                    # Update less frequently to reduce load
                    if self.iteration_count % 2 == 0:
                        self.update_brightness_info()
                        self.update_workspace_info()
                        self.update_active_window()
                    
                    # Reset error count on successful iteration
                    self.error_count = 0
                    self.last_successful_update = time.time()
                    
                    # Adaptive sleep based on system load
                    sleep_time = self.calculate_sleep_time()
                    
                    # Sleep with frequent stop checks
                    for i in range(sleep_time * 10):
                        if self._stop_flag:
                            print("‚úÖ System monitor thread stopped gracefully")
                            return
                        time.sleep(0.1)
                        
                except Exception as e:
                    self.error_count += 1
                    error_msg = f"Monitor error #{self.error_count}: {e}"
                    print(f"üö® {error_msg}")
                    # FIXED: Remove problematic signal
                    # self.monitor_status.emit(f"error:{error_msg}")
                    
                    if self.error_count >= self.max_errors:
                        crash_msg = "Too many errors, stopping monitor thread"
                        print(f"‚ùå {crash_msg}")
                        # self.monitor_status.emit(f"crashed:{crash_msg}")
                        break
                    
                    # Longer delay on error with exponential backoff
                    error_delay = min(30, 5 * (2 ** (self.error_count - 1)))
                    print(f"‚è≥ Waiting {error_delay}s after error...")
                    
                    for i in range(error_delay * 10):
                        if self._stop_flag:
                            return
                        time.sleep(0.1)
            
            print("üîç System monitor thread ended")
            # FIXED: Remove problematic signal
            # self.monitor_status.emit("stopped")

    def calculate_sleep_time(self):
        """Calculate adaptive sleep time based on system state"""
        base_sleep = 3  # seconds
        
        # Increase sleep time if many errors
        if self.error_count > 0:
            return min(10, base_sleep + self.error_count)
        
        # Check system load
        try:
            with open('/proc/loadavg', 'r') as f:
                load = float(f.read().split()[0])
                if load > 2.0:
                    return base_sleep + 2  # Longer sleep under high load
        except:
            pass
        
        return base_sleep

    def update_cpu_usage(self):
        """Update CPU usage using non-blocking file read"""
        try:
            with open('/proc/stat', 'r') as f:
                for line in f:
                    if line.startswith('cpu '):
                        parts = line.split()
                        user = int(parts[1])
                        nice = int(parts[2])
                        system = int(parts[3])
                        idle = int(parts[4])
                        total = user + nice + system + idle
                        
                        if self.prev_cpu_total > 0:
                            usage = ((total - self.prev_cpu_total) - (idle - self.prev_cpu_idle)) / (total - self.prev_cpu_total) * 100
                            self.cpu_updated.emit(min(100, max(0, usage)))
                        
                        self.prev_cpu_total = total
                        self.prev_cpu_idle = idle
                        break
        except Exception as e:
            print(f"‚ö†Ô∏è  CPU update error: {e}")
            self.cpu_updated.emit(0)

    def update_memory_usage(self):
        """Update memory usage using non-blocking file read"""
        try:
            with open('/proc/meminfo', 'r') as f:
                meminfo = {}
                for line in f:
                    if ':' in line:
                        key, value = line.split(':', 1)
                        meminfo[key.strip()] = value.strip().split(' ')[0]
                
                total = int(meminfo.get('MemTotal', 0))
                available = int(meminfo.get('MemAvailable', 0))
                
                if total > 0 and available > 0:
                    used = total - available
                    percent = (used / total) * 100
                    self.memory_updated.emit(min(100, max(0, percent)))
                else:
                    self.memory_updated.emit(0)
                    
        except Exception as e:
            print(f"‚ö†Ô∏è  Memory update error: {e}")
            self.memory_updated.emit(0)

    def update_battery_info(self):
        """Update battery information using non-blocking methods"""
        try:
            capacity, status, time_str = self.get_battery_info()
            self.battery_updated.emit(capacity, status, time_str)
        except Exception as e:
            print(f"‚ö†Ô∏è  Battery update error: {e}")
            self.battery_updated.emit(0, "Unknown", "")

    def update_volume_info(self):
        """Update volume information using non-blocking commands"""
        try:
            volume, muted = self.get_volume_info()
            self.volume_updated.emit(volume, muted)
        except Exception as e:
            print(f"‚ö†Ô∏è  Volume update error: {e}")
            self.volume_updated.emit(50, False)

    def update_network_info(self):
        """Update network information using non-blocking commands"""
        try:
            ssid, status = self.get_network_info()
            self.network_updated.emit(ssid, status)
        except Exception as e:
            print(f"‚ö†Ô∏è  Network update error: {e}")
            self.network_updated.emit("", "disconnected")

    def update_brightness_info(self):
        """Update brightness information using non-blocking commands"""
        try:
            brightness = self.get_brightness_info()
            self.brightness_updated.emit(brightness)
        except Exception as e:
            print(f"‚ö†Ô∏è  Brightness update error: {e}")

    def update_workspace_info(self):
        """Update workspace information using non-blocking commands"""
        try:
            workspace = self.get_current_workspace()
            self.workspace_updated.emit(workspace)
        except Exception as e:
            print(f"‚ö†Ô∏è  Workspace update error: {e}")
            self.workspace_updated.emit(0)

    def update_active_window(self):
        """Update active window using non-blocking commands"""
        try:
            active_window = self.get_active_window()
            self.active_window_updated.emit(active_window)
        except Exception as e:
            print(f"‚ö†Ô∏è  Active window update error: {e}")
            self.active_window_updated.emit("")

    def get_battery_info(self):
        """Get battery information using non-blocking file reads"""
        capacity = 0
        status = "Unknown"
        time_str = ""
        
        try:
            # Capacity
            capacity_file = os.path.join(self.battery_path, 'capacity')
            if os.path.exists(capacity_file):
                with open(capacity_file, 'r') as f:
                    capacity = int(f.read().strip())
            
            # Status
            status_file = os.path.join(self.battery_path, 'status')
            if os.path.exists(status_file):
                with open(status_file, 'r') as f:
                    status = f.read().strip()
            
            # Time estimation (simplified)
            if status.lower() == "discharging" and capacity < 100:
                # Simple estimation: 5 hours at 100%, proportional to capacity
                estimated_minutes = int((capacity / 100.0) * 300)  # 5 hours = 300 minutes
                if estimated_minutes > 60:
                    time_str = f"{estimated_minutes//60}h{estimated_minutes%60:02d}m"
                else:
                    time_str = f"{estimated_minutes}m"
            elif status.lower() == "charging" and capacity < 100:
                remaining = 100 - capacity
                estimated_minutes = int(remaining * 1.5)  # ~1.5 minutes per percent
                if estimated_minutes > 60:
                    time_str = f"{estimated_minutes//60}h{estimated_minutes%60:02d}m"
                else:
                    time_str = f"{estimated_minutes}m"
            elif status.lower() == "full":
                time_str = "Full"
                
        except Exception as e:
            print(f"üîã Battery info error: {e}")
        
        return capacity, status, time_str

    def get_volume_info(self):
        """Get volume information using non-blocking commands"""
        # Try PipeWire/PulseAudio first
        success, stdout, stderr = NonBlockingProcess.run_command(
            "pactl get-sink-volume @DEFAULT_SINK@", 
            timeout=1, shell=True
        )
        
        if success:
            try:
                volume_match = re.search(r'(\d+)%', stdout)
                if volume_match:
                    volume = int(volume_match.group(1))
                    # Check mute status
                    success_mute, stdout_mute, stderr_mute = NonBlockingProcess.run_command(
                        "pactl get-sink-mute @DEFAULT_SINK@",
                        timeout=1, shell=True
                    )
                    muted = success_mute and "yes" in stdout_mute.lower()
                    return volume, muted
            except Exception as e:
                print(f"‚ö†Ô∏è  PulseAudio volume error: {e}")
        
        # Fallback to ALSA
        success, stdout, stderr = NonBlockingProcess.run_command(
            "amixer sget Master 2>/dev/null | grep -o '[0-9]*%' | head -1",
            timeout=1, shell=True
        )
        
        if success and stdout:
            try:
                volume = int(stdout.rstrip('%'))
                # Check mute status
                success_mute, stdout_mute, stderr_mute = NonBlockingProcess.run_command(
                    "amixer sget Master 2>/dev/null | grep -q '\\[off\\]' && echo muted",
                    timeout=1, shell=True
                )
                muted = success_mute and "muted" in stdout_mute
                return volume, muted
            except Exception as e:
                print(f"‚ö†Ô∏è  ALSA volume error: {e}")
        
        return 50, False  # Default fallback

    def get_network_info(self):
        """Get network information using non-blocking commands"""
        # Try WiFi first
        success, stdout, stderr = NonBlockingProcess.run_command(
            "iwgetid -r 2>/dev/null", timeout=1, shell=True
        )
        
        if success and stdout:
            return stdout, "connected"
        
        # Try Ethernet
        success, stdout, stderr = NonBlockingProcess.run_command(
            "ip route show default 2>/dev/null | head -1 | awk '{print $5}'", 
            timeout=1, shell=True
        )
        
        if success and stdout:
            return stdout, "connected"
        
        return "", "disconnected"

    def get_brightness_info(self):
        """Get brightness information using non-blocking commands"""
        success, stdout, stderr = NonBlockingProcess.run_command(
            "brightnessctl get 2>/dev/null", timeout=1, shell=True
        )
        
        if success and stdout.strip().isdigit():
            current = int(stdout.strip())
            
            success_max, stdout_max, stderr_max = NonBlockingProcess.run_command(
                "brightnessctl max 2>/dev/null", timeout=1, shell=True
            )
            
            if success_max and stdout_max.strip().isdigit():
                max_val = int(stdout_max.strip())
                if max_val > 0:
                    return int((current / max_val) * 100)
        
        return 75  # Default fallback

    def get_current_workspace(self):
        """Get current workspace using non-blocking commands"""
        # Try wmctrl first
        success, stdout, stderr = NonBlockingProcess.run_command(
            "wmctrl -d 2>/dev/null | grep '*' | awk '{print $1}'", 
            timeout=1, shell=True
        )
        
        if success and stdout.strip().isdigit():
            return int(stdout.strip())
        
        # Fallback to xdotool
        success, stdout, stderr = NonBlockingProcess.run_command(
            "xdotool get_desktop 2>/dev/null", timeout=1, shell=True
        )
        
        if success and stdout.strip().isdigit():
            return int(stdout.strip())
        
        return 0

    def get_active_window(self):
        """Get active window using non-blocking commands"""
        success, stdout, stderr = NonBlockingProcess.run_command(
            "xdotool getactivewindow 2>/dev/null", timeout=1, shell=True
        )
        
        if success and stdout.strip():
            return stdout.strip()
        
        return ""





    def stop(self):
        """Stop the monitoring thread gracefully"""
        print("üõë Stopping system monitor thread...")
        self._stop_flag = True
        if not self.wait(3000):  # Wait up to 3 seconds
            print("‚ö†Ô∏è  Monitor thread didn't stop gracefully, terminating...")
            self.terminate()
            self.wait(2000)
        print("‚úÖ Monitor thread stopped")

    def run(self):
        """Main monitoring loop with better resource management"""
        self.prev_cpu_total = 0
        self.prev_cpu_idle = 0
        self.error_count = 0
        self.max_errors = 5
        
        print("üöÄ System monitor thread started")
        
        while not self._stop_flag:
            try:
                # CPU usage
                with open('/proc/stat', 'r') as f:
                    for line in f:
                        if line.startswith('cpu '):
                            parts = line.split()
                            user = int(parts[1])
                            nice = int(parts[2])
                            system = int(parts[3])
                            idle = int(parts[4])
                            total = user + nice + system + idle
                            
                            if self.prev_cpu_total > 0:
                                usage = ((total - self.prev_cpu_total) - (idle - self.prev_cpu_idle)) / (total - self.prev_cpu_total) * 100
                                self.cpu_updated.emit(min(100, max(0, usage)))
                            
                            self.prev_cpu_total = total
                            self.prev_cpu_idle = idle
                            break

                # Memory usage
                with open('/proc/meminfo', 'r') as f:
                    meminfo = {}
                    for line in f:
                        if ':' in line:
                            key, value = line.split(':', 1)
                            meminfo[key.strip()] = value.strip().split(' ')[0]
                    
                    total = int(meminfo.get('MemTotal', 0))
                    available = int(meminfo.get('MemAvailable', 0))
                    
                    if total > 0 and available > 0:
                        used = total - available
                        percent = (used / total) * 100
                        self.memory_updated.emit(min(100, max(0, percent)))
                    else:
                        self.memory_updated.emit(0)

                # Reset error count on success
                self.error_count = 0
                
                # Sleep with stop flag checking
                for _ in range(20):  # Break sleep into smaller chunks
                    if self._stop_flag:
                        break
                    time.sleep(0.1)
                    
            except Exception as e:
                self.error_count += 1
                print(f"üö® Monitor error #{self.error_count}: {e}")
                
                if self.error_count >= self.max_errors:
                    print("üí• Too many monitor errors, stopping thread")
                    break
                    
                # Longer sleep on error
                for _ in range(50):  # 5 seconds
                    if self._stop_flag:
                        break
                    time.sleep(0.1)
        
        print("‚úÖ System monitor thread ended cleanly")












        
import time
import traceback
from PyQt5.QtCore import QTimer

class PanelCrashHandler:
    """
    Handles panel crashes and automatic recovery with exponential backoff
    and comprehensive cleanup to prevent system instability.
    """
    
    def __init__(self, max_crashes=3, crash_timeout=60):
        self.crash_count = 0
        self.max_crashes = max_crashes
        self.crash_timeout = crash_timeout  # seconds
        self.last_crash_time = 0
        self.start_time = time.time()
        self.cleanup_commands = [
            "pkill -f 'wmctrl'",
            "pkill -f 'xdotool'", 
            "pkill -f 'brightnessctl'",
            "pkill -f 'pactl'",
            "pkill -f 'amixer'"
        ]
        
        print("üõ°Ô∏è  Crash Handler initialized")
    
    def should_restart(self):
        """
        Check if we should attempt restart based on crash history
        
        Returns:
            bool: True if restart should be attempted
        """
        current_time = time.time()
        
        # Reset crash count if enough time has passed since last crash
        if current_time - self.last_crash_time > self.crash_timeout:
            if self.crash_count > 0:
                print(f"üîÑ Crash count reset (timeout: {self.crash_timeout}s)")
            self.crash_count = 0
        
        # Check if we haven't exceeded max crashes
        can_restart = self.crash_count < self.max_crashes
        
        if not can_restart:
            uptime = current_time - self.start_time
            print(f"üí• Max crashes reached: {self.crash_count}/{self.max_crashes}")
            print(f"‚è∞ Uptime: {uptime:.1f}s")
        
        return can_restart
    
    def record_crash(self, error=None):
        """
        Record a crash occurrence with error details
        
        Args:
            error: Exception object or error message
        """
        self.crash_count += 1
        self.last_crash_time = time.time()
        
        error_msg = str(error) if error else "Unknown error"
        print(f"üö® Crash #{self.crash_count} recorded: {error_msg}")
        
        if self.crash_count >= self.max_crashes:
            print(f"üí• CRITICAL: Maximum crashes reached ({self.max_crashes})")
            print("üí° Suggestions:")
            print("  - Check system logs for errors")
            print("  - Verify required packages are installed")
            print("  - Restart the panel manually")
            print("  - Check for conflicting applications")
    
    def get_restart_delay(self):
        """
        Get restart delay based on crash count (exponential backoff)
        
        Returns:
            int: Delay in seconds
        """
        base_delay = 5  # seconds
        max_delay = 60  # maximum delay
        
        if self.crash_count == 0:
            return base_delay
        
        delay = base_delay * (2 ** (self.crash_count - 1))
        return min(delay, max_delay)
    
    def cleanup_before_restart(self):
        """
        Cleanup resources before restart to prevent process accumulation
        """
        print("üßπ Cleaning up before restart...")
        
        cleanup_success = 0
        cleanup_failed = 0
        
        for cmd in self.cleanup_commands:
            try:
                # Use NonBlockingProcess for cleanup
                success, stdout, stderr = NonBlockingProcess.run_command(
                    cmd, timeout=2, shell=True, capture_output=False
                )
                if success:
                    cleanup_success += 1
                else:
                    cleanup_failed += 1
            except Exception as e:
                cleanup_failed += 1
                print(f"‚ö†Ô∏è  Cleanup command failed: {cmd} - {e}")
        
        # Additional cleanup: wait a moment for processes to terminate
        time.sleep(1)
        
        print(f"‚úÖ Cleanup completed: {cleanup_success} successful, {cleanup_failed} failed")
        
        return cleanup_success > 0
    
    def get_status_report(self):
        """
        Get a status report of the crash handler state
        
        Returns:
            dict: Status information
        """
        current_time = time.time()
        time_since_last_crash = current_time - self.last_crash_time if self.last_crash_time > 0 else 0
        uptime = current_time - self.start_time
        
        return {
            'crash_count': self.crash_count,
            'max_crashes': self.max_crashes,
            'time_since_last_crash': time_since_last_crash,
            'uptime': uptime,
            'can_restart': self.should_restart(),
            'next_restart_delay': self.get_restart_delay() if self.should_restart() else 0
        }
    
    def reset(self):
        """Reset crash counter and state"""
        old_count = self.crash_count
        self.crash_count = 0
        self.last_crash_time = 0
        print(f"üîÑ Crash handler reset (previous crashes: {old_count})")
    
    def is_healthy(self):
        """
        Check if the system is in a healthy state
        
        Returns:
            bool: True if system appears healthy
        """
        status = self.get_status_report()
        
        # Consider healthy if no crashes or only recent single crash
        if status['crash_count'] == 0:
            return True
        elif status['crash_count'] == 1 and status['time_since_last_crash'] > 30:
            return True
        else:
            return False

class PanelHealthMonitor:
    """
    Monitors panel health and can trigger preventive measures
    before complete crashes occur.
    """
    
    def __init__(self, crash_handler):
        self.crash_handler = crash_handler
        self.health_check_interval = 30  # seconds
        self.last_health_check = 0
        self.consecutive_failures = 0
        self.max_consecutive_failures = 3
        
        print("‚ù§Ô∏è  Health Monitor initialized")
    
    def check_health(self, panel_instance=None):
        """
        Perform health check on the panel
        
        Args:
            panel_instance: Optional panel instance for deeper checks
            
        Returns:
            dict: Health status information
        """
        current_time = time.time()
        self.last_health_check = current_time
        
        health_status = {
            'timestamp': current_time,
            'overall_health': 'healthy',
            'checks': {},
            'recommendations': []
        }
        
        # Check crash handler status
        crash_status = self.crash_handler.get_status_report()
        health_status['checks']['crash_handler'] = crash_status
        
        if crash_status['crash_count'] > 0:
            health_status['overall_health'] = 'degraded'
            health_status['recommendations'].append(
                f"Panel has crashed {crash_status['crash_count']} times recently"
            )
        
        # Check if we can still restart
        if not crash_status['can_restart']:
            health_status['overall_health'] = 'critical'
            health_status['recommendations'].append(
                "Maximum crash limit reached - manual intervention required"
            )
        
        # Check system resource usage (if panel instance provided)
        if panel_instance:
            resource_health = self.check_system_resources(panel_instance)
            health_status['checks']['system_resources'] = resource_health
            
            if resource_health.get('high_load', False):
                health_status['overall_health'] = 'degraded'
                health_status['recommendations'].append(
                    "High system load detected - reducing update frequency"
                )
        
        # Update consecutive failures counter
        if health_status['overall_health'] == 'healthy':
            self.consecutive_failures = 0
        else:
            self.consecutive_failures += 1
        
        health_status['consecutive_failures'] = self.consecutive_failures
        
        # Log health status
        status_emoji = '‚úÖ' if health_status['overall_health'] == 'healthy' else '‚ö†Ô∏è' if health_status['overall_health'] == 'degraded' else 'üí•'
        print(f"{status_emoji} Health check: {health_status['overall_health']}")
        
        return health_status
    
    def check_system_resources(self, panel_instance):
        """
        Check system resource usage
        
        Args:
            panel_instance: Panel instance to check
            
        Returns:
            dict: Resource health information
        """
        resource_info = {
            'high_load': False,
            'timers_active': True,
            'threads_running': True
        }
        
        try:
            # Check system load
            with open('/proc/loadavg', 'r') as f:
                load = float(f.read().split()[0])
                resource_info['load_average'] = load
                resource_info['high_load'] = load > 3.0
            
            # Check if essential timers are running
            essential_timers = ['clock_timer', 'window_timer']
            active_timers = 0
            
            for timer_name in essential_timers:
                if hasattr(panel_instance, timer_name):
                    timer = getattr(panel_instance, timer_name)
                    if timer and timer.isActive():
                        active_timers += 1
            
            resource_info['timers_active'] = active_timers >= len(essential_timers) // 2
            
            # Check if monitor thread is running
            if hasattr(panel_instance, 'monitor_thread'):
                resource_info['threads_running'] = panel_instance.monitor_thread.isRunning()
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Resource check error: {e}")
            resource_info['check_error'] = str(e)
        
        return resource_info
    
    def should_trigger_preventive_restart(self):
        """
        Check if preventive restart should be triggered
        
        Returns:
            bool: True if preventive restart is recommended
        """
        return self.consecutive_failures >= self.max_consecutive_failures
    
    def get_preventive_measures(self, health_status):
        """
        Get recommended preventive measures based on health status
        
        Args:
            health_status: Current health status
            
        Returns:
            list: List of recommended actions
        """
        measures = []
        
        if health_status['overall_health'] == 'degraded':
            measures.extend([
                "Reduce UI update frequency",
                "Increase monitoring intervals", 
                "Clear temporary caches",
                "Restart non-essential components"
            ])
        
        elif health_status['overall_health'] == 'critical':
            measures.extend([
                "Perform graceful restart",
                "Reset crash counter if stable",
                "Log detailed system state",
                "Notify user of issues"
            ])
        
        return measures






























class TilingControlWidget(QWidget):
    """Enhanced widget for integrated STILE window tiling control with position restoration"""
    def __init__(self, parent=None):
        super().__init__(parent)
        # Replace with enhanced CortileAdapter with restoration
        self.tiler = CortileAdapter()
        self.setup_ui()
        # Update display immediately
        self.update_display()

    def setup_ui(self):
        """Setup the enhanced tiling control UI with gap controls"""
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(5)
        
        # Tiling button (clickable to toggle tiling)
        self.tiling_button = QPushButton("‚äû")  # Tiling icon
        self.tiling_button.setFixedSize(32, 32)
        self.tiling_button.setStyleSheet(f"""
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                color: {TokyoNight.FOREGROUND};
                border: none;
                border-radius: 6px;
                font-size: 12pt;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}40, 
                    stop:1 {TokyoNight.PURPLE}40);
            }}
        """)
        self.tiling_button.setCursor(Qt.PointingHandCursor)
        self.tiling_button.clicked.connect(self.toggle_tiling)
        self.tiling_button.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tiling_button.customContextMenuRequested.connect(self.show_tiling_menu)
        layout.addWidget(self.tiling_button)
        
        # Layout indicator
        self.layout_label = QLabel("TALL")
        self.layout_label.setStyleSheet(f"""
            padding: 4px 8px;
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 {TokyoNight.SELECTION}, 
                stop:1 {TokyoNight.NIGHT_BOTTOM});
            border-radius: 6px;
            font-size: 9pt;
            color: {TokyoNight.FOREGROUND};
        """)
        layout.addWidget(self.layout_label)
        
        # Gap indicator (new)
        self.gap_label = QLabel(f"G:{self.tiler.gap_size}")
        self.gap_label.setStyleSheet(f"""
            padding: 4px 6px;
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 {TokyoNight.SELECTION}, 
                stop:1 {TokyoNight.NIGHT_BOTTOM});
            border-radius: 6px;
            font-size: 8pt;
            color: {TokyoNight.FOREGROUND};
        """)
        self.gap_label.setToolTip("Inner gap size")
        layout.addWidget(self.gap_label)
        
        # Start monitoring timer
        self.monitor_timer = QTimer()
        self.monitor_timer.timeout.connect(self.monitor_windows)
        self.monitor_timer.start(1000)  # Check every second

    def refresh_layout(self):
        """Refresh the current layout to fix alignment issues"""
        print("üîÑ Refreshing layout to fix alignment")
        self.tiler.apply_layout()
        self.update_display()

    def correct_alignment(self):
        """Correct alignment for all windows"""
        print("üîß Correcting window alignment")
        self.tiler.apply_layout()
        self.update_display()

    def cleanup(self):
        """Clean up tiling control resources"""
        print("üßπ Cleaning up tiling control...")
        if hasattr(self, 'monitor_timer'):
            self.monitor_timer.stop()
        # Cleanup the tiler adapter
        self.tiler.cleanup()

    def force_apply_layout(self):
        """Force apply the current layout regardless of tiler's active/auto-tile status."""
        print("üîÑ Force applying tiling layout (from TilingControlWidget)")
        self.tiler.apply_layout()
        self.update_display()

    def monitor_windows(self):
        """Monitor windows and apply tiling if needed"""
        if self.tiler.is_active and self.tiler.auto_tile:
            pass

        self.update_display()

    def update_display(self):
        """Update the display based on tiler status"""
        if self.tiler.is_active:
            if self.tiler.auto_tile:
                color = TokyoNight.GREEN
                status_text = "ON"
            else:
                color = TokyoNight.YELLOW
                status_text = "PAUSED"
            
            layout_name = self.tiler.current_layout.upper()
            self.tiling_button.setText(f"<font color='{color}'>‚äû</font>")
            self.layout_label.setText(f"<font color='{color}'>{layout_name}</font>")
            self.layout_label.setVisible(True)
            self.gap_label.setVisible(True)
            self.gap_label.setText(f"<font color='{color}'>G:{self.tiler.gap_size}</font>")
            self.tiling_button.setToolTip(f"‚äû Tiling {status_text}\nLayout: {layout_name}\nGap: {self.tiler.gap_size}px\nLeft click: Toggle\nRight click: Options")
        else:
            self.tiling_button.setText(f"<font color='{TokyoNight.RED}'>‚äû</font>")
            self.layout_label.setVisible(False)
            self.gap_label.setVisible(False)
            self.tiling_button.setToolTip("‚äû Tiling OFF\nLeft click: Enable tiling\nRight click: Options")

    def toggle_tiling(self):
        """Toggle tiling on/off"""
        self.tiler.toggle_tiling()
        self.update_display()

    def cycle_layout(self):
        """Cycle to next layout"""
        layouts = ["tall", "wide", "grid", "spiral", "dwindle", "monocle", "floating"]
        current_layout_name = self.tiler.current_layout
        try:
            current_index = layouts.index(current_layout_name.lower())
            next_index = (current_index + 1) % len(layouts)
            next_layout = layouts[next_index]
        except ValueError:
            next_layout = layouts[0]
        self.tiler.set_layout(next_layout)
        self.update_display()

    def set_layout(self, layout_name):
        """Set specific layout"""
        self.tiler.set_layout(layout_name)
        self.update_display()

    def set_master(self):
        """Set currently focused window as master"""
        self.tiler.swap_with_master()
        self.update_display()

    def apply_layout(self):
        """Apply the current tiling layout"""
        self.tiler.apply_layout()
        self.update_display()

    # NEW RESTORATION METHODS
    def restore_all_windows(self):
        """Force restore all windows to their original positions"""
        print("üîÑ Restoring all windows to original positions...")
        self.tiler.restore_all_windows()
        # Also deactivate tiling when restoring
        if self.tiler.is_active:
            self.tiler.toggle_tiling()
        self.update_display()

    def save_current_positions(self):
        """Save current window positions as restore state"""
        print("üíæ Saving current window positions...")
        self.tiler.save_current_layout()

    def clear_saved_positions(self):
        """Clear all saved window positions"""
        print("üóëÔ∏è Clearing saved window positions...")
        self.tiler.clear_saved_positions()

    # Gap control methods
    def set_gap_size(self, size):
        """Set gap size between windows"""
        self.tiler.set_gap_size(size)
        self.gap_label.setText(f"G:{self.tiler.gap_size}")
        self.update_display()

    def set_outer_gap(self, size):
        """Set gap from screen edges"""
        self.tiler.set_outer_gap(size)
        self.update_display()

    def toggle_smart_gaps(self):
        """Toggle smart gap adjustment"""
        self.tiler.toggle_smart_gaps()
        self.update_display()

    def set_master_ratio(self, ratio):
        """Set master area ratio"""
        self.tiler.set_master_ratio(ratio)
        self.update_display()

    def set_max_master_windows(self, count):
        """Set maximum number of windows in master area"""
        self.tiler.set_max_master_windows(count)
        self.update_display()

    # Window control methods
    def focus_next_window(self):
        """Focus next window"""
        self.tiler.focus_next_window()

    def focus_previous_window(self):
        """Focus previous window"""
        self.tiler.focus_previous_window()

    def swap_with_master(self):
        """Swap current window with master"""
        self.tiler.swap_with_master()

    def toggle_auto_tile(self):
        """Toggle auto-tiling"""
        self.tiler.toggle_auto_tile()
        self.update_display()

    def show_tiling_menu(self, position):
        """Enhanced context menu for tiling options with restoration"""
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 6px;
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 16px;
                border-radius: 4px;
            }}
            QMenu::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
        """)

        # Status info
        status_text = "ON" if self.tiler.is_active else "OFF"
        status_color = TokyoNight.GREEN if self.tiler.is_active else TokyoNight.RED
        status_action = QAction(f"Status: {status_text}", self)
        status_action.setEnabled(False)
        menu.addAction(status_action)

        menu.addSeparator()

        # Toggle tiling
        toggle_action = QAction("‚äû Toggle Tiling", self)
        toggle_action.triggered.connect(self.toggle_tiling)
        menu.addAction(toggle_action)

        # NEW: Restoration options (always available)
        menu.addSeparator()
        restore_menu = QMenu("üíæ Window Restoration", self)
        restore_menu.setStyleSheet(menu.styleSheet())
        
        save_positions_action = QAction("üì∏ Save Current Positions", self)
        save_positions_action.triggered.connect(self.save_current_positions)
        restore_menu.addAction(save_positions_action)
        
        restore_action = QAction("üîÑ Restore All Windows", self)
        restore_action.triggered.connect(self.restore_all_windows)
        restore_menu.addAction(restore_action)
        
        clear_positions_action = QAction("üóëÔ∏è Clear Saved Positions", self)
        clear_positions_action.triggered.connect(self.clear_saved_positions)
        restore_menu.addAction(clear_positions_action)
        
        menu.addMenu(restore_menu)

        if self.tiler.is_active:
            # Auto-tile toggle
            auto_action = QAction("ü§ñ Auto-tile", self)
            auto_action.setCheckable(True)
            auto_action.setChecked(self.tiler.auto_tile)
            auto_action.triggered.connect(self.toggle_auto_tile)
            menu.addAction(auto_action)

            # Gap control submenu
            gap_menu = QMenu("üìê Gap Control", self)
            gap_menu.setStyleSheet(menu.styleSheet())
            
            # Inner gap control
            inner_gap_menu = QMenu(f"üî≤ Inner: {self.tiler.gap_size}px", self)
            inner_gap_menu.setStyleSheet(menu.styleSheet())
            for gap_size in [0, 5, 10, 15, 20]:
                action = QAction(f"{gap_size}px", self)
                action.triggered.connect(lambda checked, g=gap_size: self.set_gap_size(g))
                inner_gap_menu.addAction(action)
            gap_menu.addMenu(inner_gap_menu)
            
            # Outer gap control
            outer_gap_menu = QMenu(f"üì± Outer: {self.tiler.outer_gap}px", self)
            outer_gap_menu.setStyleSheet(menu.styleSheet())
            for gap_size in [0, 5, 10, 15]:
                action = QAction(f"{gap_size}px", self)
                action.triggered.connect(lambda checked, g=gap_size: self.set_outer_gap(g))
                outer_gap_menu.addAction(action)
            gap_menu.addMenu(outer_gap_menu)
            
            # Smart gaps toggle
            smart_gaps_action = QAction("üß† Smart Gaps", self)
            smart_gaps_action.setCheckable(True)
            smart_gaps_action.setChecked(self.tiler.smart_gaps)
            smart_gaps_action.triggered.connect(self.toggle_smart_gaps)
            gap_menu.addAction(smart_gaps_action)
            
            menu.addMenu(gap_menu)

            # Layout options
            menu.addSeparator()
            layout_menu = QMenu("üìê Layout", self)
            layout_menu.setStyleSheet(menu.styleSheet())
            layouts = ["tall", "wide", "grid", "monocle", "spiral", "dwindle", "floating"]
            for layout in layouts:
                action = QAction(layout.capitalize(), self)
                action.setCheckable(True)
                action.setChecked(self.tiler.current_layout == layout)
                action.triggered.connect(lambda checked, l=layout: self.set_layout(l))
                layout_menu.addAction(action)
            menu.addMenu(layout_menu)

            # Cycle layout
            cycle_action = QAction("üîÑ Cycle Layout", self)
            cycle_action.triggered.connect(self.cycle_layout)
            menu.addAction(cycle_action)

            # Window control submenu
            window_menu = QMenu("ü™ü Window Control", self)
            window_menu.setStyleSheet(menu.styleSheet())
            
            focus_next_action = QAction("‚è≠Ô∏è Focus Next", self)
            focus_next_action.triggered.connect(self.focus_next_window)
            window_menu.addAction(focus_next_action)
            
            focus_prev_action = QAction("‚èÆÔ∏è Focus Previous", self)
            focus_prev_action.triggered.connect(self.focus_previous_window)
            window_menu.addAction(focus_prev_action)
            
            swap_master_action = QAction("üîÑ Swap with Master", self)
            swap_master_action.triggered.connect(self.swap_with_master)
            window_menu.addAction(swap_master_action)
            
            menu.addMenu(window_menu)

            # Master area control submenu
            master_menu = QMenu("üéØ Master Area", self)
            master_menu.setStyleSheet(menu.styleSheet())
            
            # Master ratio
            ratio_menu = QMenu(f"üìê Ratio: {int(self.tiler.master_ratio * 100)}%", self)
            ratio_menu.setStyleSheet(menu.styleSheet())
            for ratio in [30, 40, 50, 60, 70, 80]:
                action = QAction(f"{ratio}%", self)
                action.triggered.connect(lambda checked, r=ratio/100: self.set_master_ratio(r))
                ratio_menu.addAction(action)
            master_menu.addMenu(ratio_menu)
            
            # Max master windows
            max_master_menu = QMenu(f"üî¢ Max Windows: {self.tiler.max_master_windows}", self)
            max_master_menu.setStyleSheet(menu.styleSheet())
            for count in [1, 2, 3]:
                action = QAction(f"{count} window{'s' if count > 1 else ''}", self)
                action.triggered.connect(lambda checked, c=count: self.set_max_master_windows(c))
                max_master_menu.addAction(action)
            master_menu.addMenu(max_master_menu)
            
            menu.addMenu(master_menu)

        menu.exec_(self.tiling_button.mapToGlobal(position))

class GlobalKeyHandler(QObject):
    """Global key handler for volume keys"""
    def __init__(self, volume_widget):
        super().__init__()
        self.volume_widget = volume_widget
        print("Global key handler installed - volume keys may not work in all environments")

    def handle_volume_up(self):
        """Handle volume up"""
        print("Volume up key pressed")
        new_volume = min(100, self.volume_widget.current_volume + 5)
        self.volume_widget.set_volume(new_volume)

    def handle_volume_down(self):
        """Handle volume down"""
        print("Volume down key pressed")
        new_volume = max(0, self.volume_widget.current_volume - 5)
        self.volume_widget.set_volume(new_volume)

    def handle_volume_mute(self):
        """Handle volume mute"""
        print("Volume mute key pressed")
        self.volume_widget.toggle_mute()

class NightSkyWidget(QWidget):
    """Widget with animated night sky background"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.stars = []
        self.animation_timer = QTimer()
        self.animation_timer.timeout.connect(self.update_stars)
        self.animation_timer.start(100)  # Update every 100ms
        self.generate_stars()

    def generate_stars(self):
        """Generate random stars for the night sky"""
        import random
        width = self.width() if self.width() > 0 else 1920
        height = self.height() if self.height() > 0 else 40
        # Create stars with varying sizes and brightness
        for _ in range(50):  # Create 50 stars
            x = random.randint(0, width)
            y = random.randint(0, height)
            size = random.uniform(0.5, 2.0)
            brightness = random.uniform(0.3, 1.0)
            twinkle_speed = random.uniform(0.01, 0.05)
            self.stars.append({
                'x': x, 'y': y, 'size': size, 
                'brightness': brightness, 
                'twinkle_speed': twinkle_speed,
                'phase': random.uniform(0, 2 * 3.14159)  # Random phase
            })

    def update_stars(self):
        """Update star brightness for twinkling effect"""
        import math
        for star in self.stars:
            star['phase'] += star['twinkle_speed']
            star['current_brightness'] = star['brightness'] * (0.5 + 0.5 * math.sin(star['phase']))
        self.update()

    def paintEvent(self, event):
        """Paint the night sky with stars"""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        # Create night sky gradient
        gradient = QLinearGradient(0, 0, 0, self.height())
        gradient.setColorAt(0, QColor(TokyoNight.NIGHT_TOP))
        gradient.setColorAt(0.7, QColor(TokyoNight.NIGHT_BOTTOM))
        gradient.setColorAt(1, QColor(TokyoNight.NIGHT_HIGHLIGHT))
        painter.fillRect(self.rect(), gradient)
        # Draw stars
        for star in self.stars:
            color = QColor(TokyoNight.STAR_COLOR)
            color.setAlphaF(star.get('current_brightness', star['brightness']))
            painter.setPen(QPen(color, star['size']))
            painter.drawPoint(star['x'], star['y'])
        # Draw nebula clouds
        nebula_brush = QBrush(QColor(TokyoNight.NEBULA))
        nebula_brush.setStyle(Qt.Dense6Pattern)
        painter.setBrush(nebula_brush)
        painter.setPen(Qt.NoPen)
        painter.setOpacity(0.1)
        painter.drawEllipse(100, 10, 200, 30)
        painter.drawEllipse(500, 5, 150, 20)
        painter.drawEllipse(900, 15, 180, 25)

class WirelessNetworkDialog(QDialog):
    """Dialog for managing wireless network connections"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_ui()
        self.scan_networks()

    def setup_ui(self):
        self.setWindowTitle("Wireless Networks")
        self.setFixedSize(500, 600)
        self.setStyleSheet(f"""
            QDialog {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border-radius: 8px;
                border: 1px solid {TokyoNight.NEBULA};
            }}
            QListWidget {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 4px;
                padding: 5px;
            }}
            QListWidget::item {{
                padding: 8px;
                border-radius: 3px;
            }}
            QListWidget::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}, 
                    stop:1 {TokyoNight.PURPLE});
                color: {TokyoNight.BACKGROUND};
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.CYAN}, 
                    stop:1 {TokyoNight.BLUE});
            }}
            QLabel {{
                color: {TokyoNight.FOREGROUND};
            }}
            QLineEdit {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                padding: 5px;
                border-radius: 3px;
            }}
            QCheckBox {{
                color: {TokyoNight.FOREGROUND};
            }}
            QGroupBox {{
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
                background: {TokyoNight.NIGHT_BOTTOM}80;
            }}
            QGroupBox::title {{
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }}
        """)
        layout = QVBoxLayout()
        
        # Title
        title = QLabel("Wireless Networks")
        title.setStyleSheet(f"font-size: 14pt; font-weight: bold; color: {TokyoNight.CYAN};")
        layout.addWidget(title)
        
        # Network list
        self.network_list = QListWidget()
        self.network_list.itemDoubleClicked.connect(self.connect_to_network)
        layout.addWidget(self.network_list)
        
        # Buttons
        button_layout = QHBoxLayout()
        self.refresh_btn = QPushButton("Û∞ëê Refresh")
        self.refresh_btn.clicked.connect(self.scan_networks)
        button_layout.addWidget(self.refresh_btn)
        
        self.connect_btn = QPushButton("Û∞ñ© Connect")
        self.connect_btn.clicked.connect(self.connect_to_selected)
        button_layout.addWidget(self.connect_btn)
        
        self.disconnect_btn = QPushButton("Û∞ñ™ Disconnect")
        self.disconnect_btn.clicked.connect(self.disconnect_current)
        button_layout.addWidget(self.disconnect_btn)
        
        button_layout.addStretch()
        self.close_btn = QPushButton("Close")
        self.close_btn.clicked.connect(self.close)
        button_layout.addWidget(self.close_btn)
        
        layout.addLayout(button_layout)
        
        # Connection details section
        self.details_group = QGroupBox("Connection Details")
        details_layout = QFormLayout()
        self.ssid_label = QLabel("--")
        self.signal_label = QLabel("--")
        self.security_label = QLabel("--")
        self.status_label = QLabel("--")
        details_layout.addRow("SSID:", self.ssid_label)
        details_layout.addRow("Signal:", self.signal_label)
        details_layout.addRow("Security:", self.security_label)
        details_layout.addRow("Status:", self.status_label)
        self.details_group.setLayout(details_layout)
        layout.addWidget(self.details_group)
        
        # Password input for secured networks
        self.password_group = QGroupBox("Network Password")
        password_layout = QVBoxLayout()
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.password_input.setPlaceholderText("Enter network password")



        password_layout.addWidget(self.password_input)
        
        self.show_password_check = QCheckBox("Show password")
        self.show_password_check.stateChanged.connect(self.toggle_password_visibility)
        password_layout.addWidget(self.show_password_check)
        
        self.password_group.setLayout(password_layout)
        self.password_group.setVisible(False)
        layout.addWidget(self.password_group)

        self.setLayout(layout)
        
        # Update connection details when selection changes
        self.network_list.itemSelectionChanged.connect(self.update_connection_details)

    def toggle_password_visibility(self, state):
        """Toggle password visibility"""
        if state == Qt.Checked:
            self.password_input.setEchoMode(QLineEdit.Normal)
        else:
            self.password_input.setEchoMode(QLineEdit.Password)

    def scan_networks(self):
        """Scan for available wireless networks"""
        self.network_list.clear()
        try:
            # Try to get wireless networks using nmcli
            result = subprocess.run(
                "nmcli -t -f SSID,SIGNAL,SECURITY dev wifi list",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0:
                networks = []
                for line in result.stdout.splitlines():
                    parts = line.split(':')
                    if len(parts) >= 3:
                        ssid = parts[0]
                        signal = parts[1]
                        security = parts[2]
                        # Skip empty SSIDs
                        if not ssid:
                            continue
                        networks.append({
                            'ssid': ssid,
                            'signal': signal,
                            'security': security,
                            'connected': False
                        })
                
                # Check which network is currently connected
                try:
                    current_result = subprocess.run(
                        "nmcli -t -f NAME,TYPE connection show --active | grep wifi",
                        shell=True, capture_output=True, text=True
                    )
                    if current_result.returncode == 0:
                        current_ssid = current_result.stdout.split(':')[0]
                        for network in networks:
                            if network['ssid'] == current_ssid:
                                network['connected'] = True
                except:
                    pass
                
                # Sort networks by signal strength (descending) and connection status
                networks.sort(key=lambda x: (not x['connected'], -int(x['signal'])))
                
                # Add networks to the list
                for network in networks:
                    icon = "Û∞ñ©" if network['connected'] else "Û∞ñ™"
                    security_icon = "üîí" if network['security'] else "üîì"
                    item_text = f"{icon} {network['ssid']} {security_icon} ({network['signal']}%)"
                    item = QListWidgetItem(item_text)
                    item.setData(Qt.UserRole, network)
                    if network['connected']:
                        item.setForeground(QColor(TokyoNight.GREEN))
                    self.network_list.addItem(item)
            else:
                # Fallback to iwlist if nmcli fails
                self.scan_with_iwlist()
        except Exception as e:
            print(f"Error scanning networks: {e}")
            # Try fallback method
            self.scan_with_iwlist()

    def scan_with_iwlist(self):
        """Fallback method using iwlist to scan networks"""
        try:
            result = subprocess.run(
                "iwlist scan 2>/dev/null | grep -E 'ESSID|Quality|Encryption key'",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0:
                networks = []
                current_network = {}
                for line in result.stdout.splitlines():
                    if "ESSID" in line:
                        if current_network:
                            networks.append(current_network)
                        ssid = line.split('"')[1] if '"' in line else "Hidden Network"
                        current_network = {'ssid': ssid}
                    elif "Quality" in line:
                        quality = line.split('=')[1].split('/')[0]
                        current_network['signal'] = int(quality)
                    elif "Encryption key" in line:
                        encrypted = "on" in line.split(':')[1]
                        current_network['security'] = "WPA/WPA2" if encrypted else "Open"
                if current_network:
                    networks.append(current_network)
                
                # Add networks to the list
                for network in networks:
                    security_icon = "üîí" if network.get('security') != "Open" else "üîì"
                    signal = network.get('signal', 0)
                    item_text = f"Û∞ñ™ {network['ssid']} {security_icon} ({signal}%)"
                    item = QListWidgetItem(item_text)
                    item.setData(Qt.UserRole, network)
                    self.network_list.addItem(item)
        except Exception as e:
            print(f"Error with iwlist scan: {e}")
            self.network_list.addItem(QListWidgetItem("Error scanning networks"))

    def update_connection_details(self):
        """Update connection details when selection changes"""
        try:
            current_item = self.network_list.currentItem()
            if not current_item:
                self.password_group.setVisible(False)
                return
            
            network = current_item.data(Qt.UserRole)
            if not network:
                self.password_group.setVisible(False)
                return

            self.ssid_label.setText(network.get('ssid', '--'))
            self.signal_label.setText(f"{network.get('signal', '--')}%")
            self.security_label.setText(network.get('security', '--'))
            
            # Handle connection status
            connected_value = network.get('connected', False)
            if isinstance(connected_value, str):
                connected = connected_value.lower() in ['true', 'yes', '1', 'connected', 'on']
            else:
                connected = bool(connected_value)
            
            status = "Connected" if connected else "Available"
            self.status_label.setText(status)
            
            # Handle security status
            security_value = network.get('security', '')
            is_secured = bool(security_value and security_value != "Open" and security_value != "open")
            
            # Determine if password group should be visible
            should_show = bool(is_secured and not connected)
            self.password_group.setVisible(should_show)
            
        except Exception as e:
            print(f"Error in update_connection_details: {e}")
            # On error, hide the password group
            self.password_group.setVisible(False)

    def connect_to_selected(self):
        """Connect to the selected network with troubleshooting option"""
        current_item = self.network_list.currentItem()
        if not current_item:
            QMessageBox.information(self, "No Selection", "Please select a network to connect to.")
            return
        
        network = current_item.data(Qt.UserRole)
        if not network:
            return
        
        # Show troubleshooting option for difficult connections
        if network.get('security') and not network.get('connected'):
            reply = QMessageBox.question(
                self, "Connection Options",
                f"Connect to '{network.get('ssid')}'?\n\nIf connection fails, you can:\n‚Ä¢ Check troubleshooting guide\n‚Ä¢ Try manual connection\n‚Ä¢ Use system network manager",
                QMessageBox.Yes | QMessageBox.Help | QMessageBox.Cancel,
                QMessageBox.Yes
            )
            
            if reply == QMessageBox.Yes:
                self.connect_to_network(current_item)
            elif reply == QMessageBox.Help:
                self.show_connection_troubleshooting()
                # Ask again after showing help
                self.connect_to_network(current_item)
        else:
            self.connect_to_network(current_item)




    def connect_to_network(self, item):
        """Connect to a wireless network with proper SSID handling for special characters"""
        network = item.data(Qt.UserRole)
        if not network:
            return
        ssid = network.get('ssid')
        if not ssid:
            return

        try:
            # Check if already connected
            if network.get('connected', False):
                return
            
            # Check if network requires password
            is_secured = network.get('security') and network.get('security') != "Open"
            
            # FIRST: Try to find existing saved connection in NetworkManager
            connection_name = self.get_existing_connection_name(ssid)
            
            # If we found an existing connection, USE IT
            if connection_name:
                print(f"Using existing saved connection: {connection_name}")
                self.status_label.setText("Connecting to saved network...")
                
                result = subprocess.run(
                    f"nmcli connection up '{connection_name}'",
                    shell=True, capture_output=True, text=True, timeout=30
                )
                
                if result.returncode == 0:
                    print(f"Successfully connected using saved connection: {connection_name}")
                    self.status_label.setText("Connected")
                    QTimer.singleShot(2000, self.scan_networks)
                    return
                else:
                    print(f"Saved connection failed: {result.stderr}")
                    # If saved connection fails, delete it so we can create a fresh one
                    subprocess.run(f"nmcli connection delete '{connection_name}'", 
                                 shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    self.status_label.setText("Saved connection outdated, recreating...")
            
            # SECOND: Handle password input for secured networks
            if is_secured:
                password = self.password_input.text()
                if not password:
                    self.password_group.setVisible(True)
                    self.password_input.setFocus()
                    self.status_label.setText("Enter password for network")
                    return
                
                print(f"Creating new connection for: {ssid}")
                self.status_label.setText("Creating connection...")
                
                # METHOD 1: Use nmcli with proper escaping for SSID with special characters
                # This handles SSIDs with spaces, quotes, and special characters
                success = self.connect_with_nmcli_direct(ssid, password)
                
                if success:
                    print("‚úì Connected via direct nmcli method")
                    self.status_label.setText("Connected")
                    QTimer.singleShot(2000, self.scan_networks)
                    return
                else:
                    # METHOD 2: Create connection using file-based approach (most reliable)
                    success = self.create_connection_file_advanced(ssid, password)
                    
                    if success:
                        print("‚úì Connected via file-based method")
                        self.status_label.setText("Connected & Saved")
                        QTimer.singleShot(2000, self.scan_networks)
                        return
                    else:
                        # METHOD 3: Try alternative connection method
                        success = self.connect_with_wpa_supplicant(ssid, password)
                        
                        if success:
                            print("‚úì Connected via wpa_supplicant method")
                            self.status_label.setText("Connected")
                            QTimer.singleShot(2000, self.scan_networks)
                            return
                        else:
                            self.status_label.setText("All connection methods failed")
                            QMessageBox.warning(
                                self, "Connection Failed", 
                                f"Failed to connect to '{ssid}'.\n\nPossible issues:\n‚Ä¢ Wrong password\n‚Ä¢ Network not in range\n‚Ä¢ Driver issues\n‚Ä¢ Special characters in SSID\n\nTry connecting manually via NetworkManager."
                            )
                            return
            else:
                # Open network - use direct connection method
                success = self.connect_open_network(ssid)
                
                if success:
                    self.status_label.setText("Connected")
                    QTimer.singleShot(2000, self.scan_networks)
                else:
                    self.status_label.setText("Failed to connect to open network")
                    QMessageBox.warning(self, "Connection Failed", f"Failed to connect to open network {ssid}")
            
        except subprocess.TimeoutExpired:
            self.status_label.setText("Error: Timeout")
            QMessageBox.warning(self, "Connection Timeout", "Connection took too long.")
        except Exception as e:
            print(f"Error connecting to network: {e}")
            self.status_label.setText(f"Error: {str(e)}")
            QMessageBox.warning(self, "Connection Error", f"Error: {str(e)}")

    def connect_with_nmcli_direct(self, ssid, password):
        """Connect using nmcli with proper SSID handling"""
        try:
            # Escape single quotes in SSID for shell command
            escaped_ssid = ssid.replace("'", "'\\''")
            
            # Method 1: Direct connection with proper quoting
            cmd = f"nmcli dev wifi connect '{escaped_ssid}' password '{password}'"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0:
                return True
            
            # Method 2: Alternative approach - create temporary connection
            temp_name = f"temp_{int(time.time())}"
            cmd = f"nmcli connection add type wifi con-name '{temp_name}' ssid '{escaped_ssid}' wifi-sec.psk '{password}'"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=10)
            
            if result.returncode == 0:
                # Try to connect
                connect_result = subprocess.run(
                    f"nmcli connection up '{temp_name}'", 
                    shell=True, capture_output=True, text=True, timeout=20
                )
                
                if connect_result.returncode == 0:
                    return True
                else:
                    # Clean up temporary connection
                    subprocess.run(f"nmcli connection delete '{temp_name}'", 
                                 shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            
            return False
            
        except Exception as e:
            print(f"nmcli direct connection error: {e}")
            return False

    def create_connection_file_advanced(self, ssid, password):
        """Create connection file with advanced error handling"""
        try:
            import uuid
            import base64
            
            # Create a safe connection name
            safe_name = self.create_safe_connection_name(ssid)
            conn_dir = os.path.expanduser("~/.config/NetworkManager/system-connections/")
            os.makedirs(conn_dir, mode=0o700, exist_ok=True)
            
            conn_file = os.path.join(conn_dir, f"{safe_name}.nmconnection")
            
            # Generate UUID for connection
            connection_uuid = str(uuid.uuid4())
            
            # Create the connection file content with proper encoding
            connection_content = f"""[connection]
    id={safe_name}
    uuid={connection_uuid}
    type=wifi
    interface-name=*

    [wifi]
    mode=infrastructure
    ssid={self.encode_ssid(ssid)}

    [wifi-security]
    key-mgmt=wpa-psk
    psk={password}

    [ipv4]
    method=auto

    [ipv6]
    method=auto
    """
            # Write the connection file
            with open(conn_file, 'w') as f:
                f.write(connection_content)
            
            # Set secure permissions (NetworkManager requires this)
            os.chmod(conn_file, 0o600)
            
            print(f"‚úì Created connection file: {conn_file}")
            
            # Reload NetworkManager to recognize the new connection
            subprocess.run("nmcli connection reload", shell=True, timeout=10)
            
            # Wait for NetworkManager to recognize the connection
            time.sleep(3)
            
            # Try to connect using the new profile
            result = subprocess.run(
                f"nmcli connection up '{safe_name}'",
                shell=True, capture_output=True, text=True, timeout=30
            )
            
            if result.returncode == 0:
                return True
            else:
                # If connection fails, delete the file and try another method
                try:
                    os.remove(conn_file)
                except:
                    pass
                return False
                
        except Exception as e:
            print(f"File-based connection error: {e}")
            return False

    def connect_with_wpa_supplicant(self, ssid, password):
        """Alternative method using wpa_supplicant (fallback)"""
        try:
            # Create wpa_supplicant configuration
            wpa_conf = f"""
    network={{
        ssid="{ssid}"
        psk="{password}"
    }}
    """
            # Write temporary configuration
            temp_conf = "/tmp/wpa_supplicant_temp.conf"
            with open(temp_conf, 'w') as f:
                f.write(wpa_conf)
            
            # Get WiFi interface
            interface_result = subprocess.run(
                "iwconfig 2>/dev/null | grep 'IEEE 802.11' | awk '{print $1}' | head -1",
                shell=True, capture_output=True, text=True
            )
            
            if interface_result.returncode == 0 and interface_result.stdout.strip():
                interface = interface_result.stdout.strip()
                
                # Stop any existing wpa_supplicant
                subprocess.run("sudo pkill wpa_supplicant", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                time.sleep(2)
                
                # Start wpa_supplicant with new configuration
                cmd = f"sudo wpa_supplicant -B -i {interface} -c {temp_conf}"
                result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=10)
                
                if result.returncode == 0:
                    time.sleep(3)
                    # Try to get DHCP address
                    dhcp_result = subprocess.run(f"sudo dhclient {interface}", shell=True, timeout=15)
                    return dhcp_result.returncode == 0
            
            return False
            
        except Exception as e:
            print(f"wpa_supplicant connection error: {e}")
            return False

    def connect_open_network(self, ssid):
        """Connect to open (unsecured) network"""
        try:
            escaped_ssid = ssid.replace("'", "'\\''")
            
            # Method 1: Direct connection
            cmd = f"nmcli dev wifi connect '{escaped_ssid}'"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0:
                return True
            
            # Method 2: Create connection profile
            safe_name = self.create_safe_connection_name(ssid)
            cmd = f"nmcli connection add type wifi con-name '{safe_name}' ssid '{escaped_ssid}'"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=10)
            
            if result.returncode == 0:
                connect_result = subprocess.run(
                    f"nmcli connection up '{safe_name}'",
                    shell=True, capture_output=True, text=True, timeout=20
                )
                return connect_result.returncode == 0
            
            return False
            
        except Exception as e:
            print(f"Open network connection error: {e}")
            return False

    def encode_ssid(self, ssid):
        """Encode SSID for connection files - handles special characters"""
        try:
            # For connection files, we need to encode non-ASCII characters
            if all(ord(c) < 128 for c in ssid):
                return ssid
            else:
                # Encode as hex for non-ASCII characters
                encoded = ""
                for char in ssid:
                    if ord(char) < 128:
                        encoded += char
                    else:
                        encoded += f"\\x{ord(char):02x}"
                return encoded
        except:
            return ssid

    def create_safe_connection_name(self, ssid):
        """Create a safe connection name from SSID"""
        import re
        # Remove or replace problematic characters
        safe_name = re.sub(r'[^a-zA-Z0-9_-]', '_', ssid)
        # Limit length and ensure it starts with letter/number
        if safe_name and not safe_name[0].isalnum():
            safe_name = 'wifi_' + safe_name
        # Ensure reasonable length
        safe_name = safe_name[:30]
        
        # Add timestamp to make it unique
        import time
        timestamp = str(int(time.time()))[-4:]
        return f"{safe_name}_{timestamp}"

    def get_existing_connection_name(self, ssid):
        """Get existing connection name with better SSID matching"""
        try:
            # Get all WiFi connections
            result = subprocess.run(
                "nmcli -t -f NAME,UUID,TYPE connection show",
                shell=True, capture_output=True, text=True, timeout=10
            )
            
            if result.returncode == 0:
                for line in result.stdout.splitlines():
                    parts = line.split(':')
                    if len(parts) >= 2:
                        conn_name = parts[0]
                        
                        # Skip non-wifi connections
                        if len(parts) >= 3 and 'wifi' not in parts[2].lower():
                            continue
                        
                        # Get the SSID for this connection with better error handling
                        ssid_result = subprocess.run(
                            f"nmcli -t -g 802-11-wireless.ssid connection show '{conn_name}' 2>/dev/null",
                            shell=True, capture_output=True, text=True, timeout=5
                        )
                        
                        if ssid_result.returncode == 0:
                            connection_ssid = ssid_result.stdout.strip()
                            # Compare SSIDs (handle special characters)
                            if connection_ssid == ssid:
                                print(f"Found exact SSID match: '{conn_name}' -> '{connection_ssid}'")
                                return conn_name
                        
                        # Also check by connection name pattern
                        if ssid.replace(' ', '_').lower() in conn_name.lower():
                            print(f"Found connection by name pattern: '{conn_name}'")
                            return conn_name
            
            return None
            
        except Exception as e:
            print(f"Error checking existing connections: {e}")
            return None




    def show_connection_troubleshooting(self):
        """Show troubleshooting dialog for connection issues"""
        msg = QMessageBox(self)
        msg.setWindowTitle("Connection Troubleshooting")
        msg.setIcon(QMessageBox.Information)
        msg.setText("""
    <h3>WiFi Connection Troubleshooting</h3>

    <strong>Common Issues & Solutions:</strong>

    <strong>1. Special Characters in SSID:</strong>
    ‚Ä¢ Try connecting manually via NetworkManager applet
    ‚Ä¢ Use nmcli command: <code>nmcli dev wifi connect "SSID" password "password"</code>

    <strong>2. Wrong Password:</strong>
    ‚Ä¢ Double-check the password
    ‚Ä¢ Try forgetting the network and reconnecting

    <strong>3. Driver Issues:</strong>
    ‚Ä¢ Check if WiFi adapter is detected: <code>iwconfig</code>
    ‚Ä¢ Restart NetworkManager: <code>sudo systemctl restart NetworkManager</code>

    <strong>4. Signal Strength:</strong>
    ‚Ä¢ Move closer to the router
    ‚Ä¢ Check for interference from other devices

    <strong>5. NetworkManager Issues:</strong>
    ‚Ä¢ Reset NetworkManager: <code>sudo systemctl restart NetworkManager</code>
    ‚Ä¢ Check logs: <code>journalctl -u NetworkManager</code>

    <strong>Manual Connection Command:</strong>
    <code>nmcli dev wifi connect "Your SSID" password "YourPassword"</code>
    """)
        msg.setStandardButtons(QMessageBox.Ok)
        msg.exec_()

    def manual_connection_dialog(self, ssid):
        """Show dialog for manual connection command"""
        command = f'nmcli dev wifi connect "{ssid}" password "YOUR_PASSWORD"'
        
        msg = QMessageBox(self)
        msg.setWindowTitle("Manual Connection")
        msg.setIcon(QMessageBox.Information)
        msg.setText(f"""
    <h3>Manual Connection for '{ssid}'</h3>

    If automatic connection fails, you can try manually:

    <strong>Terminal Command:</strong>
    <code>{command}</code>

    <strong>Steps:</strong>
    1. Open terminal
    2. Replace YOUR_PASSWORD with actual password
    3. Run the command
    4. Check connection with: <code>nmcli connection show --active</code>

    <strong>Alternative GUI Method:</strong>
    ‚Ä¢ Click the network icon in system tray
    ‚Ä¢ Select your network
    ‚Ä¢ Enter password when prompted
    """)
        msg.setStandardButtons(QMessageBox.Ok)
        msg.exec_()














    def clean_ssid_for_nm(self, ssid):
        """Clean SSID for use in NetworkManager connection names"""
        # Remove or replace problematic characters
        cleaned = re.sub(r'[^a-zA-Z0-9_-]', '_', ssid)
        # Limit length and ensure it starts with letter/number
        if cleaned and not cleaned[0].isalnum():
            cleaned = 'wifi_' + cleaned
        return cleaned[:30]  # Reasonable length limit

    def create_permanent_profile(self, ssid, password):
        """Create a permanent connection profile after successful connection"""
        try:
            safe_ssid = self.clean_ssid_for_nm(ssid)
            safe_name = f"hotspot_{safe_ssid}"
            
            # Get the temporary connection that was just created
            result = subprocess.run(
                "nmcli -t -f NAME,UUID connection show --active | grep wifi | tail -1",
                shell=True, capture_output=True, text=True, timeout=10
            )
            
            if result.returncode == 0 and result.stdout.strip():
                temp_conn = result.stdout.split(':')[0]
                print(f"Found temporary connection: {temp_conn}")
                
                # Clone the temporary connection to a permanent one
                clone_cmd = f"nmcli connection clone '{temp_conn}' '{safe_name}'"
                clone_result = subprocess.run(clone_cmd, shell=True, capture_output=True, text=True, timeout=10)
                
                if clone_result.returncode == 0:
                    print(f"‚úì Created permanent profile: {safe_name}")
                else:
                    print(f"Clone failed: {clone_result.stderr}")
                    
        except Exception as e:
            print(f"Error creating permanent profile: {e}")

    def create_connection_file(self, ssid, password, connection_name):
        """Create connection using direct file creation (most reliable method)"""
        try:
            # Create the connection directory if it doesn't exist
            conn_dir = os.path.expanduser("~/.config/NetworkManager/system-connections/")
            os.makedirs(conn_dir, mode=0o700, exist_ok=True)
            
            # Create the connection file
            conn_file = os.path.join(conn_dir, f"{connection_name}.nmconnection")
            
            connection_content = f"""[connection]
    id={connection_name}
    uuid={str(uuid.uuid4())}
    type=wifi
    interface-name=*

    [wifi]
    mode=infrastructure
    ssid={ssid}

    [wifi-security]
    key-mgmt=wpa-psk
    psk={password}

    [ipv4]
    method=auto

    [ipv6]
    method=auto
    """
            # Write the connection file with secure permissions
            with open(conn_file, 'w') as f:
                f.write(connection_content)
            
            # Set secure permissions (NetworkManager requires this)
            os.chmod(conn_file, 0o600)
            
            print(f"‚úì Created connection file: {conn_file}")
            
            # Reload NetworkManager to recognize the new connection
            subprocess.run("nmcli connection reload", shell=True, timeout=10)
            
            # Wait a moment for NetworkManager to recognize the connection
            time.sleep(2)
            
            # Try to connect using the new profile
            result = subprocess.run(
                f"nmcli connection up '{connection_name}'",
                shell=True, capture_output=True, text=True, timeout=30
            )
            
            return result.returncode == 0
            
        except Exception as e:
            print(f"Error creating connection file: {e}")
            return False

    def get_existing_connection_name(self, ssid):
        """Get the exact connection name for an SSID from NetworkManager"""
        try:
            # Clean the SSID for searching
            safe_ssid = self.clean_ssid_for_nm(ssid)
            hotspot_name = f"hotspot_{safe_ssid}"
            
            # Method 1: Check if our hotspot connection exists
            check_result = subprocess.run(
                f"nmcli -t -g name connection show | grep '{hotspot_name}'",
                shell=True, capture_output=True, text=True, timeout=5
            )
            
            if check_result.returncode == 0 and hotspot_name in check_result.stdout:
                print(f"Found hotspot connection: {hotspot_name}")
                return hotspot_name
            
            # Method 2: Look for connections with matching SSID
            result = subprocess.run(
                "nmcli -t -f NAME,UUID,TYPE connection show",
                shell=True, capture_output=True, text=True, timeout=10
            )
            
            if result.returncode == 0:
                for line in result.stdout.splitlines():
                    parts = line.split(':')
                    if len(parts) >= 2:
                        conn_name = parts[0]
                        
                        # Skip non-wifi connections
                        if len(parts) >= 3 and 'wifi' not in parts[2].lower():
                            continue
                        
                        # Get the SSID for this connection
                        check_ssid = subprocess.run(
                            f"nmcli -t -g 802-11-wireless.ssid connection show '{conn_name}'",
                            shell=True, capture_output=True, text=True, timeout=5
                        )
                        
                        if check_ssid.returncode == 0:
                            connection_ssid = check_ssid.stdout.strip()
                            if connection_ssid == ssid:
                                print(f"Found exact SSID match: '{conn_name}'")
                                return conn_name
            
            print(f"No existing connection found for SSID: {ssid}")
            return None
            
        except Exception as e:
            print(f"Error checking existing connections: {e}")
            return None



















    def disconnect_current(self):
        """Disconnect from current network"""
        try:
            # Get active WiFi connection
            result = subprocess.run(
                "nmcli -t -f NAME,TYPE connection show --active | grep wifi",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0 and result.stdout.strip():
                connection_name = result.stdout.split(':')[0]
                # Disconnect the specific connection
                result = subprocess.run(
                    f"nmcli connection down '{connection_name}'",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode == 0:
                    self.status_label.setText("Disconnected")
                    # Refresh network list after a short delay
                    QTimer.singleShot(2000, self.scan_networks)
                else:
                    print(f"Failed to disconnect: {result.stderr}")
                    self.status_label.setText(f"Error: {result.stderr.strip()}")
                    # Show a more user-friendly error dialog
                    QMessageBox.warning(
                        self, "Disconnection Failed",
                        f"Failed to disconnect from {connection_name}.\nError: {result.stderr.strip()}"
                    )
            else:
                # Try alternative method if no active WiFi connection found
                result = subprocess.run(
                    "nmcli dev disconnect $(nmcli dev status | grep wifi | head -1 | awk '{print $1}')",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode == 0:
                    self.status_label.setText("Disconnected")
                    # Refresh network list after a short delay
                    QTimer.singleShot(2000, self.scan_networks)
                else:
                    print(f"Failed to disconnect: {result.stderr}")
                    self.status_label.setText(f"Error: {result.stderr.strip()}")
                    # Show a more user-friendly error dialog
                    QMessageBox.warning(
                        self, "Disconnection Failed",
                        f"Failed to disconnect from WiFi.\nError: {result.stderr.strip()}"
                    )
        except Exception as e:
            print(f"Error disconnecting: {e}")
            self.status_label.setText(f"Error: {str(e)}")
            # Show a more user-friendly error dialog
            QMessageBox.warning(
                self, "Disconnection Error",
                f"An error occurred while disconnecting from WiFi.\nError: {str(e)}"
            )




class EnhancedWirelessNetworkDialog(WirelessNetworkDialog):
    """Enhanced wireless network dialog with real-time signal monitoring"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Enhanced Wireless Networks")
        self.signal_monitor_timer = QTimer()
        self.signal_monitor_timer.timeout.connect(self.update_signal_strengths)
        self.signal_monitor_timer.start(5000)  # Update every 5 seconds
        # Initial signal strength update
        QTimer.singleShot(1000, self.update_signal_strengths)

    def update_signal_strengths(self):
        """Update signal strengths for all networks in real-time"""
        try:
            # Get current signal strengths using nmcli
            result = subprocess.run(
                "nmcli -t -f SSID,SIGNAL,SECURITY dev wifi list",
                shell=True, capture_output=True, text=True, timeout=5
            )
            
            if result.returncode == 0:
                signal_data = {}
                for line in result.stdout.splitlines():
                    parts = line.split(':')
                    if len(parts) >= 3:
                        ssid = parts[0]
                        signal = parts[1] if parts[1].isdigit() else "0"
                        security = parts[2] if len(parts) > 2 else ""
                        signal_data[ssid] = {
                            'signal': int(signal),
                            'security': security
                        }
                
                # Update list items with signal strength
                for i in range(self.network_list.count()):
                    item = self.network_list.item(i)
                    if item:
                        network = item.data(Qt.UserRole)
                        if network and 'ssid' in network:
                            ssid = network['ssid']
                            current_data = signal_data.get(ssid, {})
                            current_signal = current_data.get('signal', network.get('signal', 0))
                            
                            # Update network data
                            network['signal'] = current_signal
                            if 'security' in current_data:
                                network['security'] = current_data['security']
                            item.setData(Qt.UserRole, network)
                            
                            # Update display text with signal bars
                            signal_bars = self.get_signal_bars(current_signal)
                            status_icon = "Û∞ñ©" if network.get('connected') else "Û∞ñ™"
                            security_icon = "üîí" if network.get('security') and network.get('security') != "Open" else "üîì"
                            
                            # Truncate long SSIDs
                            display_ssid = ssid[:20] + "..." if len(ssid) > 23 else ssid
                            item_text = f"{status_icon} {display_ssid} {security_icon} {signal_bars} {current_signal}%"
                            item.setText(item_text)
                            
                            # Color code based on signal strength and connection status
                            if network.get('connected'):
                                item.setForeground(QColor(TokyoNight.GREEN))
                            else:
                                if current_signal >= 75:
                                    color = TokyoNight.GREEN
                                elif current_signal >= 50:
                                    color = TokyoNight.YELLOW
                                elif current_signal >= 25:
                                    color = TokyoNight.ORANGE
                                else:
                                    color = TokyoNight.RED
                                item.setForeground(QColor(color))
                
                # Update details if current selection exists
                self.update_connection_details()
                
        except Exception as e:
            print(f"Signal strength update error: {e}")

    def get_signal_bars(self, strength):
        """Get visual signal bars for display"""
        bars = "‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá"
        bar_count = max(1, min(len(bars), (strength * len(bars)) // 100))
        
        if strength >= 75:
            color = TokyoNight.GREEN
        elif strength >= 50:
            color = TokyoNight.YELLOW
        elif strength >= 25:
            color = TokyoNight.ORANGE
        else:
            color = TokyoNight.RED
            
        return f"<font color='{color}'>{bars[:bar_count]}</font>"

    def scan_networks(self):
        """Enhanced network scan with better signal information"""
        self.network_list.clear()
        try:
            # Get wireless networks with detailed information
            result = subprocess.run(
                "nmcli -t -f SSID,SIGNAL,SECURITY,BSSID dev wifi list",
                shell=True, capture_output=True, text=True, timeout=10
            )
            
            if result.returncode == 0:
                networks = []
                for line in result.stdout.splitlines():
                    parts = line.split(':')
                    if len(parts) >= 3:
                        ssid = parts[0]
                        signal = parts[1] if parts[1].isdigit() else "0"
                        security = parts[2] if len(parts) > 2 else ""
                        bssid = parts[3] if len(parts) > 3 else ""
                        
                        # Skip empty SSIDs
                        if not ssid:
                            continue
                            
                        networks.append({
                            'ssid': ssid,
                            'signal': int(signal),
                            'security': security,
                            'bssid': bssid,
                            'connected': False
                        })
                
                # Check which network is currently connected
                try:
                    current_result = subprocess.run(
                        "nmcli -t -f NAME,DEVICE connection show --active | grep -E '(wlan|wifi)'",
                        shell=True, capture_output=True, text=True, timeout=3
                    )
                    if current_result.returncode == 0:
                        for line in current_result.stdout.splitlines():
                            if ':' in line:
                                conn_name = line.split(':')[0]
                                # Get SSID for this connection
                                ssid_result = subprocess.run(
                                    f"nmcli -t -g 802-11-wireless.ssid connection show '{conn_name}'",
                                    shell=True, capture_output=True, text=True, timeout=2
                                )
                                if ssid_result.returncode == 0:
                                    current_ssid = ssid_result.stdout.strip()
                                    for network in networks:
                                        if network['ssid'] == current_ssid:
                                            network['connected'] = True
                except:
                    pass
                
                # Sort networks by signal strength (descending) and connection status
                networks.sort(key=lambda x: (not x['connected'], -x['signal']))
                
                # Add networks to the list
                for network in networks:
                    signal_bars = self.get_signal_bars(network['signal'])
                    status_icon = "Û∞ñ©" if network['connected'] else "Û∞ñ™"
                    security_icon = "üîí" if network['security'] and network['security'] != "Open" else "üîì"
                    
                    # Truncate long SSIDs
                    display_ssid = network['ssid'][:20] + "..." if len(network['ssid']) > 23 else network['ssid']
                    item_text = f"{status_icon} {display_ssid} {security_icon} {signal_bars} {network['signal']}%"
                    
                    item = QListWidgetItem(item_text)
                    item.setData(Qt.UserRole, network)
                    
                    if network['connected']:
                        item.setForeground(QColor(TokyoNight.GREEN))
                    else:
                        if network['signal'] >= 75:
                            color = TokyoNight.GREEN
                        elif network['signal'] >= 50:
                            color = TokyoNight.YELLOW
                        elif network['signal'] >= 25:
                            color = TokyoNight.ORANGE
                        else:
                            color = TokyoNight.RED
                        item.setForeground(QColor(color))
                    
                    self.network_list.addItem(item)
            else:
                # Fallback to simpler scan
                super().scan_networks()
        except Exception as e:
            print(f"Enhanced network scan error: {e}")
            # Fallback to parent method
            super().scan_networks()
        
        # Start signal monitoring after scan
        self.update_signal_strengths()

    def update_connection_details(self):
        """Update connection details with enhanced information"""
        try:
            current_item = self.network_list.currentItem()
            if not current_item:
                self.password_group.setVisible(False)
                return
            
            network = current_item.data(Qt.UserRole)
            if not network:
                self.password_group.setVisible(False)
                return

            self.ssid_label.setText(network.get('ssid', '--'))
            self.signal_label.setText(f"{network.get('signal', '--')}%")
            self.security_label.setText(network.get('security', '--'))
            
            # Enhanced signal quality description
            signal_strength = network.get('signal', 0)
            if signal_strength >= 75:
                quality = "Excellent"
                color = TokyoNight.GREEN
            elif signal_strength >= 50:
                quality = "Good"
                color = TokyoNight.YELLOW
            elif signal_strength >= 25:
                quality = "Fair"
                color = TokyoNight.ORANGE
            else:
                quality = "Poor"
                color = TokyoNight.RED
            
            self.signal_label.setText(f"<font color='{color}'>{signal_strength}% ({quality})</font>")
            
            # Handle connection status
            connected = network.get('connected', False)
            status = "Connected" if connected else "Available"
            status_color = TokyoNight.GREEN if connected else TokyoNight.FOREGROUND
            self.status_label.setText(f"<font color='{status_color}'>{status}</font>")
            
            # Handle security status
            security_value = network.get('security', '')
            is_secured = bool(security_value and security_value != "Open" and security_value != "open")
            
            # Determine if password group should be visible
            should_show = bool(is_secured and not connected)
            self.password_group.setVisible(should_show)
            
        except Exception as e:
            print(f"Error in enhanced connection details: {e}")
            self.password_group.setVisible(False)








class NetworkManagerWidget(QWidget):
    """Widget for Network Manager control with wireless network dialog"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_ui()

    def setup_ui(self):
        """Setup the network manager control UI"""
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(5)
        # Network manager button (clickable to launch network manager)
        self.network_button = QPushButton("Û∞§®")  # Network icon
        self.network_button.setFixedSize(32, 32)
        self.network_button.setStyleSheet(f"""
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                color: {TokyoNight.FOREGROUND};
                border: none;
                border-radius: 6px;
                font-size: 12pt;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}40, 
                    stop:1 {TokyoNight.PURPLE}40);
            }}
        """)
        self.network_button.setCursor(Qt.PointingHandCursor)
        self.network_button.setToolTip("Left click: Wireless Networks\nRight click: Network Manager")
        self.network_button.clicked.connect(self.launch_wireless_dialog)
        self.network_button.setContextMenuPolicy(Qt.CustomContextMenu)
        self.network_button.customContextMenuRequested.connect(self.show_network_menu)
        layout.addWidget(self.network_button)

    def launch_wireless_dialog(self):
        """Launch wireless network dialog"""
        try:
            dialog = WirelessNetworkDialog(self)
            dialog.exec_()
        except Exception as e:
            print(f"Failed to launch wireless dialog: {e}")
            # Fallback to network manager
            self.launch_network_manager()

    def show_network_menu(self, position):
        """Show context menu for network options"""
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 6px;
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 16px;
                border-radius: 4px;
            }}
            QMenu::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
        """)
        wireless_action = QAction("Û∞ñ© Wireless Networks", self)
        wireless_action.triggered.connect(self.launch_wireless_dialog)
        menu.addAction(wireless_action)
        menu.addSeparator()
        manager_action = QAction("Û∞íì Network Manager", self)
        manager_action.triggered.connect(self.launch_network_manager)
        menu.addAction(manager_action)
        menu.exec_(self.network_button.mapToGlobal(position))

    def launch_network_manager(self):
        """Launch network manager when button is clicked"""
        try:
            # Try nm-connection-editor first (GUI version)
            result = subprocess.run(
                "which nm-connection-editor",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0:
                # Check if nm-connection-editor is already running
                result = subprocess.run(
                    "pgrep -f nm-connection-editor",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode == 0:
                    # If running, focus it
                    subprocess.run(
                        "wmctrl -a 'Network Connections'",
                        shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
                    )
                else:
                    # Launch nm-connection-editor
                    subprocess.Popen(
                        ["nm-connection-editor"],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
            else:
                # Fallback to nm-applet
                subprocess.Popen(
                    ["nm-applet"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
        except Exception as e:
            print(f"Failed to launch network manager: {e}")
            # Try alternative command
            try:
                subprocess.Popen(
                    ["nm-applet"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
            except Exception as e2:
                print(f"Failed to launch nm-applet: {e2}")

class BluetoothManagerWidget(QWidget):
    """Widget for Bluetooth Manager control that launches blueman-manager"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_ui()

    def setup_ui(self):
        """Setup the bluetooth manager control UI"""
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(5)
        # Bluetooth manager button (clickable to launch bluetooth manager)
        self.bluetooth_button = QPushButton("Û∞ÇØ")  # Bluetooth icon
        self.bluetooth_button.setFixedSize(32, 32)
        self.bluetooth_button.setStyleSheet(f"""
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                color: {TokyoNight.FOREGROUND};
                border: none;
                border-radius: 6px;
                font-size: 12pt;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}40, 
                    stop:1 {TokyoNight.PURPLE}40);
            }}
        """)
        self.bluetooth_button.setCursor(Qt.PointingHandCursor)
        self.bluetooth_button.setToolTip("Click to open Bluetooth Manager")
        self.bluetooth_button.clicked.connect(self.launch_bluetooth_manager)
        layout.addWidget(self.bluetooth_button)

    def launch_bluetooth_manager(self):
        """Launch bluetooth manager when button is clicked"""
        try:
            # Check if blueman-manager is available
            result = subprocess.run(
                "which blueman-manager",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0:
                # Check if blueman-manager is already running
                result = subprocess.run(
                    "pgrep -f blueman-manager",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode == 0:
                    # If running, focus it
                    subprocess.run(
                        "wmctrl -a 'Bluetooth Manager'",
                        shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
                    )
                else:
                    # Launch blueman-manager
                    subprocess.Popen(
                        ["blueman-manager"],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
            else:
                print("Blueman-manager not found. Please install it with: sudo apt install blueman")
                # Try alternative bluetooth managers
                try:
                    # Try blueberry (alternative)
                    subprocess.Popen(
                        ["blueberry"],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
                except:
                    # Try gnome-bluetooth
                    subprocess.Popen(
                        ["gnome-bluetooth"],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
        except Exception as e:
            print(f"Failed to launch bluetooth manager: {e}")

class VolumeControlWidget(QWidget):
    """Widget for volume control with interactive slider, scroll wheel support, and global key bindings"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.current_volume = 50
        self.is_muted = False
        self.audio_backend = None
        self.default_sink = None
        self.global_key_handler = None
        self.setup_ui()
        self.detect_audio_backend()
        self.start_volume_monitor()
        # Add global key handler
        self.setup_global_key_handler()

    def setup_global_key_handler(self):
        """Setup global key handler for volume keys"""
        try:
            # Create global key handler
            self.global_key_handler = GlobalKeyHandler(self)
            print("Global volume key handler installed successfully")
        except Exception as e:
            print(f"Failed to setup global key handler: {e}")

    def start_volume_monitor(self):
        """Monitor for volume changes"""
        self.volume_timer = QTimer()
        self.volume_timer.timeout.connect(self.check_system_volume)
        self.volume_timer.start(500)  # Check every 500ms

    def check_system_volume(self):
        """Check current system volume and update display"""
        try:
            volume, muted = self.get_current_volume()
            if volume is not None and (volume != self.current_volume or muted != self.is_muted):
                self.current_volume = volume
                self.is_muted = muted
                self.update_volume_display(volume, muted)
                # Update slider
                self.volume_slider.blockSignals(True)
                self.volume_slider.setValue(volume)
                self.volume_slider.blockSignals(False)
        except Exception as e:
            print(f"Error checking system volume: {e}")

    def get_current_volume(self):
        """Get current volume using pactl"""
        try:
            # Get volume from default sink
            result = subprocess.run(
                ["pactl", "get-sink-volume", "@DEFAULT_SINK@"],
                capture_output=True, text=True, timeout=2
            )
            if result.returncode == 0:
                # Parse volume from output
                import re
                volume_matches = re.findall(r'(\d+)%', result.stdout)
                if volume_matches:
                    volume = int(volume_matches[0])
                    # Check if muted
                    mute_result = subprocess.run(
                        ["pactl", "get-sink-mute", "@DEFAULT_SINK@"],
                        capture_output=True, text=True, timeout=2
                    )
                    muted = (mute_result.returncode == 0 and 
                           "yes" in mute_result.stdout.lower())
                    return volume, muted
        except Exception as e:
            print(f"Volume check error: {e}")
        return None, None

    def setup_ui(self):
        """Setup the volume control UI"""
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(5)

        # Volume icon (clickable to toggle mute)
        self.volume_icon = QLabel("Û∞ïæ")
        self.volume_icon.setStyleSheet(f"""
            padding: 4px;
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 {TokyoNight.SELECTION}, 
                stop:1 {TokyoNight.NIGHT_BOTTOM});
            border-radius: 6px;
            font-size: 12pt;
            color: {TokyoNight.FOREGROUND};
        """)
        self.volume_icon.setCursor(Qt.PointingHandCursor)
        self.volume_icon.mousePressEvent = self.volume_icon_mouse_press
        self.volume_icon.setToolTip("Click to toggle mute\nScroll to adjust volume\nVolume keys work globally")
        layout.addWidget(self.volume_icon)

        # Volume slider
        self.volume_slider = QSlider(Qt.Horizontal)
        self.volume_slider.setRange(0, 100)
        self.volume_slider.setValue(self.current_volume)
        self.volume_slider.setFixedWidth(80)
        self.volume_slider.valueChanged.connect(self.set_volume)
        self.volume_slider.setStyleSheet(f"""
            QSlider::groove:horizontal {{
                border: none;
                height: 4px;
                background: {TokyoNight.NEBULA};
                border-radius: 2px;
            }}
            QSlider::handle:horizontal {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}, 
                    stop:1 {TokyoNight.PURPLE});
                border: none;
                width: 12px;
                margin: -4px 0;
                border-radius: 6px;
            }}
            QSlider::handle:horizontal:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.CYAN}, 
                    stop:1 {TokyoNight.BLUE});
            }}
        """)
        layout.addWidget(self.volume_slider)

        # Volume label (clickable to launch pavucontrol)
        self.volume_label = QLabel("50%")
        self.volume_label.setStyleSheet(f"""
            padding: 4px 8px;
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 {TokyoNight.SELECTION}, 
                stop:1 {TokyoNight.NIGHT_BOTTOM});
            border-radius: 6px;
            font-size: 9pt;
            color: {TokyoNight.FOREGROUND};
        """)
        self.volume_label.setCursor(Qt.PointingHandCursor)
        self.volume_label.mousePressEvent = self.volume_label_mouse_press
        self.volume_label.setToolTip("Click to open Volume Control")
        layout.addWidget(self.volume_label)

        # Enable mouse tracking for the whole widget
        self.setMouseTracking(True)

    def volume_icon_mouse_press(self, event):
        """Handle mouse press on volume icon"""
        if event.button() == Qt.LeftButton:
            self.toggle_mute()

    def volume_label_mouse_press(self, event):
        """Handle mouse press on volume label"""
        if event.button() == Qt.LeftButton:
            self.launch_pavucontrol()

    def mousePressEvent(self, event):
        """Handle mouse press events for the entire widget."""
        if event.button() == Qt.LeftButton:
            # Don't handle clicks on child widgets - let their handlers deal with it
            child_widget = self.childAt(event.pos())
            if child_widget in [self.volume_icon, self.volume_label, self.volume_slider]:
                # Let the child widget handle the click
                super().mousePressEvent(event)
                return
                
            # Handle click on empty space in the widget
            # Calculate the volume based on the click position relative to the widget
            widget_rect = self.rect()
            click_x = event.pos().x()
            
            # Calculate volume based on click position
            if widget_rect.width() > 0:
                volume = int((click_x / widget_rect.width()) * 100)
                volume = max(0, min(100, volume))
                self.set_volume(volume)
                
        super().mousePressEvent(event)

    def wheelEvent(self, event):
        """Handle mouse wheel events for the entire widget to change volume."""
        # Calculate volume change
        delta = event.angleDelta().y()
        if delta > 0:
            # Scroll up - increase volume
            new_volume = min(100, self.current_volume + 5)
        else:
            # Scroll down - decrease volume
            new_volume = max(0, self.current_volume - 5)
        # Set the new volume
        self.set_volume(new_volume)
        event.accept()

    def set_volume(self, volume):
        """Set system volume and update display"""
        # Update current volume
        self.current_volume = volume
        # Update slider position (block signals to avoid recursion)
        self.volume_slider.blockSignals(True)
        self.volume_slider.setValue(volume)
        self.volume_slider.blockSignals(False)
        # Set system volume using pactl
        success = self.set_volume_pactl(volume)
        if not success:
            print(f"Failed to set volume to {volume}%")
        # Update display
        self.update_volume_display(volume, self.is_muted)

    def set_volume_pactl(self, volume):
        """Set volume using pactl command"""
        try:
            result = subprocess.run(
                ["pactl", "set-sink-volume", "@DEFAULT_SINK@", f"{volume}%"],
                capture_output=True, text=True, timeout=2
            )
            return result.returncode == 0
        except Exception as e:
            print(f"Volume set error: {e}")
            return False

    def toggle_mute(self):
        """Toggle mute state"""
        success = self.toggle_mute_pactl()
        if not success:
            print("Failed to toggle mute")
        else:
            # Toggle mute state locally
            self.is_muted = not self.is_muted
            self.update_volume_display(self.current_volume, self.is_muted)

    def toggle_mute_event(self, event):
        """Toggle mute state (for key binding)"""
        success = self.toggle_mute_pactl()
        if not success:
            print("Failed to toggle mute")
        else:
            # Toggle mute state locally
            self.is_muted = not self.is_muted
            self.update_volume_display(self.current_volume, self.is_muted)

    def toggle_mute_pactl(self):
        """Toggle mute using pactl"""
        try:
            result = subprocess.run(
                ["pactl", "set-sink-mute", "@DEFAULT_SINK@", "toggle"],
                capture_output=True, text=True, timeout=2
            )
            return result.returncode == 0
        except Exception as e:
            print(f"Mute toggle error: {e}")
            return False

    def launch_pavucontrol(self):
        """Launch volume control when label is clicked"""
        try:
            # Try pavucontrol first (works with PipeWire)
            # Check if pavucontrol is already running
            result = subprocess.run(
                ["pgrep", "-f", "pavucontrol"],
                capture_output=True, text=True
            )
            if result.returncode == 0:
                # If running, focus it
                subprocess.run(
                    ["wmctrl", "-a", "pavucontrol"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
            else:
                # Launch pavucontrol
                subprocess.Popen(
                    ["pavucontrol"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
        except Exception as e:
            print(f"Failed to launch pavucontrol: {e}")

    def update_volume_display(self, volume, muted):
        """Update the volume label display"""
        self.current_volume = volume
        self.is_muted = muted
        icon = "Û∞ñÅ" if muted else "Û∞ïæ"  # Muted vs volume icon
        color = TokyoNight.RED if muted else TokyoNight.CYAN
        # Update icon
        self.volume_icon.setText(f"<font color='{color}'>{icon}</font>")
        # Update label
        self.volume_label.setText(f"<font color='{color}'>{volume}%</font>")

    def detect_audio_backend(self):
        """Detect which audio backend is available"""
        try:
            # Check if pactl works
            result = subprocess.run(
                ["pactl", "info"],
                capture_output=True, text=True, timeout=3
            )
            if result.returncode == 0:
                if "PipeWire" in result.stdout or "pipewire" in result.stdout.lower():
                    self.audio_backend = 'pipewire'
                    print("Using PipeWire backend")
                else:
                    self.audio_backend = 'pulse'
                    print("Using PulseAudio backend")
                return
        except Exception as e:
            print(f"PulseAudio/PipeWire check failed: {e}")

        # Fallback to ALSA
        try:
            result = subprocess.run(
                ["amixer", "scontrols"],
                capture_output=True, text=True, timeout=3
            )
            if result.returncode == 0 and "Master" in result.stdout:
                self.audio_backend = 'alsa'
                print("Using ALSA backend")
                return
        except:
            pass
        print("Warning: No supported audio backend found")
        self.audio_backend = None

class SystemMonitorThread(QThread):
    cpu_updated = pyqtSignal(float)
    memory_updated = pyqtSignal(float)
    battery_updated = pyqtSignal(int, str, str)  # capacity, status, time
    volume_updated = pyqtSignal(int, bool)
    network_updated = pyqtSignal(str, str)  # ssid, status
    brightness_updated = pyqtSignal(int)
    workspace_updated = pyqtSignal(int)  # Current workspace index
    active_window_updated = pyqtSignal(str)  # Active window ID

    def __init__(self):
        super().__init__()
        self.battery_path = self.find_battery_path()

    def find_battery_path(self):
        """Find the correct battery path"""
        battery_base = "/sys/class/power_supply"
        try:
            # List all power supply devices
            devices = os.listdir(battery_base)
            for device in devices:
                if device.startswith(('BAT', 'bat')):
                    # Check if capacity file exists
                    capacity_file = os.path.join(battery_base, device, 'capacity')
                    if os.path.exists(capacity_file):
                        return os.path.join(battery_base, device)
        except:
            pass
        return os.path.join(battery_base, 'BAT0')  # Default fallback

    def format_time(self, seconds):
        """Format seconds into hours and minutes"""
        if seconds <= 0:
            return ""
        hours = seconds // 3600
        minutes = (seconds % 3600) // 60
        if hours > 0:
            return f"{hours}h{minutes:02d}m"
        else:
            return f"{minutes}m"

    def get_battery_time_upower(self, status):
        """Get battery time using upower command"""
        try:
            if status.lower() == "discharging":
                result = subprocess.run(
                    "upower -i $(upower -e | grep battery) 2>/dev/null | grep 'time to empty' | cut -d':' -f2 | tr -d ' ' | head -1",
                    shell=True, capture_output=True, text=True
                )
            elif status.lower() == "charging":
                result = subprocess.run(
                    "upower -i $(upower -e | grep battery) 2>/dev/null | grep 'time to full' | cut -d':' -f2 | tr -d ' ' | head -1",
                    shell=True, capture_output=True, text=True
                )
            else:
                return ""
            if result.returncode == 0 and result.stdout.strip():
                time_str = result.stdout.strip()
                # Parse time format like "1.5h" or "45min"
                if 'h' in time_str and 'min' in time_str:
                    # Format: "1.5h 30min"
                    hours_part = time_str.split('h')[0]
                    minutes_part = time_str.split('min')[0].split()[-1]
                    try:
                        hours = int(float(hours_part))
                        minutes = int(minutes_part)
                        return f"{hours}h{minutes:02d}m"
                    except:
                        return time_str
                elif 'h' in time_str:
                    return time_str.replace('h', 'h')
                elif 'min' in time_str:
                    return time_str.replace('min', 'm')
        except:
            pass
        return ""

    def get_battery_info(self):
        """Get comprehensive battery information"""
        capacity = 0
        status = "Unknown"
        time_str = ""
        try:
            # Get capacity
            capacity_file = os.path.join(self.battery_path, 'capacity')
            if os.path.exists(capacity_file):
                with open(capacity_file, 'r') as f:
                    capacity = int(f.read().strip())
            else:
                # Try alternative location
                capacity_result = subprocess.run(
                    "cat /sys/class/power_supply/BAT*/capacity 2>/dev/null | head -1 || echo 0",
                    shell=True, capture_output=True, text=True
                )
                capacity = int(capacity_result.stdout.strip()) if capacity_result.stdout.strip().isdigit() else 0

            # Get status
            status_file = os.path.join(self.battery_path, 'status')
            if os.path.exists(status_file):
                with open(status_file, 'r') as f:
                    status = f.read().strip()
            else:
                status_result = subprocess.run(
                    "cat /sys/class/power_supply/BAT*/status 2>/dev/null | head -1 || echo Unknown",
                    shell=True, capture_output=True, text=True
                )
                status = status_result.stdout.strip()

            # Get time information with multiple fallback methods
            time_str = self.get_battery_time(status, capacity)
        except Exception as e:
            print(f"Battery info error: {e}")
        return capacity, status, time_str

    def get_battery_time(self, status, capacity):
        """Get battery time with multiple fallback methods"""
        time_str = ""
        try:
            # Method 1: Direct kernel files (most accurate)
            if status.lower() == "discharging":
                time_file = os.path.join(self.battery_path, 'time_to_empty')
                if os.path.exists(time_file):
                    with open(time_file, 'r') as f:
                        time_value = f.read().strip()
                    if time_value and time_value.isdigit() and int(time_value) > 0:
                        seconds = int(time_value) * 60  # Convert minutes to seconds
                        time_str = self.format_time(seconds)
                else:
                    # Try alternative naming
                    time_file = os.path.join(self.battery_path, 'time_to_empty_now')
                    if os.path.exists(time_file):
                        with open(time_file, 'r') as f:
                            time_value = f.read().strip()
                        if time_value and time_value.isdigit() and int(time_value) > 0:
                            seconds = int(time_value)
                            time_str = self.format_time(seconds)

            elif status.lower() == "charging":
                time_file = os.path.join(self.battery_path, 'time_to_full')
                if os.path.exists(time_file):
                    with open(time_file, 'r') as f:
                        time_value = f.read().strip()
                    if time_value and time_value.isdigit() and int(time_value) > 0:
                        seconds = int(time_value) * 60  # Convert minutes to seconds
                        time_str = self.format_time(seconds)
                else:
                    # Try alternative naming
                    time_file = os.path.join(self.battery_path, 'time_to_full_now')
                    if os.path.exists(time_file):
                        with open(time_file, 'r') as f:
                            time_value = f.read().strip()
                        if time_value and time_value.isdigit() and int(time_value) > 0:
                            seconds = int(time_value)
                            time_str = self.format_time(seconds)

            # Method 2: Use upower if available (good fallback)
            if not time_str:
                time_str = self.get_battery_time_upower(status)

            # Method 3: Estimate based on capacity and average consumption
            if not time_str and status.lower() == "discharging":
                # Very rough estimate: assume 5 hours total battery life
                estimated_minutes = int((capacity / 100.0) * 300)  # 5 hours = 300 minutes
                if estimated_minutes > 60:
                    time_str = f"{estimated_minutes // 60}h{estimated_minutes % 60:02d}m"
                else:
                    time_str = f"{estimated_minutes}m"
            elif not time_str and status.lower() == "charging":
                # Rough estimate for charging
                remaining_percent = 100 - capacity
                estimated_minutes = int(remaining_percent * 1.5)  # ~1.5 minutes per percent
                if estimated_minutes > 60:
                    time_str = f"{estimated_minutes // 60}h{estimated_minutes % 60:02d}m"
                else:
                    time_str = f"{estimated_minutes}m"
            elif status.lower() == "full":
                time_str = "Full"
        except Exception as e:
            print(f"Battery time error: {e}")
        return time_str

    def get_volume_pulse(self):
        """Get volume using PipeWire/PulseAudio pactl commands"""
        try:
            # Get default sink
            sink_result = subprocess.run(
                ["pactl", "get-default-sink"],
                capture_output=True, text=True, timeout=2
            )
            default_sink = None
            if sink_result.returncode == 0:
                default_sink = sink_result.stdout.strip()
            # If no default sink, try to find one
            if not default_sink:
                list_result = subprocess.run(
                    ["pactl", "list", "sinks", "short"],
                    capture_output=True, text=True, timeout=2
                )
                if list_result.returncode == 0:
                    lines = list_result.stdout.splitlines()
                    if lines:
                        default_sink = lines[0].split()[1]

            if default_sink:
                # Get volume
                result = subprocess.run(
                    ["pactl", "get-sink-volume", default_sink],
                    capture_output=True, text=True, timeout=2
                )
                if result.returncode == 0:
                    # Parse volume from output (PipeWire/PulseAudio format)
                    import re
                    # Look for volume percentage in the output
                    volume_matches = re.findall(r'(\d+)%', result.stdout)
                    if volume_matches:
                        # Take the left channel volume (usually first match)
                        volume = int(volume_matches[0])
                        # Check if muted
                        mute_result = subprocess.run(
                            ["pactl", "get-sink-mute", default_sink],
                            capture_output=True, text=True, timeout=2
                        )
                        muted = (mute_result.returncode == 0 and 
                               "yes" in mute_result.stdout.lower())
                        return volume, muted
        except Exception as e:
            print(f"PipeWire/PulseAudio volume error: {e}")
        return None, None

    def get_volume_amixer(self):
        """Get volume using amixer"""
        try:
            result = subprocess.run(
                "amixer sget Master 2>/dev/null | grep -o '[0-9]*%' | head -1",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0 and result.stdout.strip():
                volume_str = result.stdout.strip().rstrip('%')
                if volume_str.isdigit():
                    # Check if muted
                    muted_result = subprocess.run(
                        "amixer sget Master 2>/dev/null | grep -q '\\[off\\]'",
                        shell=True
                    )
                    muted = muted_result.returncode == 0
                    return int(volume_str), muted
        except:
            pass
        return None, None

    def get_current_workspace(self):
        """Get the current workspace index more reliably"""
        try:
            # Method 1: wmctrl
            result = subprocess.run(
                "wmctrl -d | grep '*' | awk '{print $1}'",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0 and result.stdout.strip().isdigit():
                return int(result.stdout.strip())
            
            # Method 2: xdotool
            result = subprocess.run(
                "xdotool get_desktop",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0 and result.stdout.strip().isdigit():
                return int(result.stdout.strip())
                
        except Exception as e:
            print(f"Error getting current workspace: {e}")
        
        return 0  # Fallback

    def get_active_window(self):
        """Get the ID of the currently active window more reliably"""
        try:
            # Method 1: xdotool (most reliable for active window)
            result = subprocess.run(
                "xdotool getwindowfocus",
                shell=True, capture_output=True, text=True, timeout=1
            )
            if result.returncode == 0 and result.stdout.strip():
                return result.stdout.strip()
                
            # Method 2: wmctrl fallback
            result = subprocess.run(
                "wmctrl -l | grep ' *' | cut -d' ' -f1",
                shell=True, capture_output=True, text=True, timeout=1
            )
            if result.returncode == 0 and result.stdout.strip():
                return result.stdout.strip().split('\n')[0]  # Take first window
                
        except Exception as e:
            print(f"Error getting active window: {e}")
        
        return ""

    def run(self):
        self.prev_cpu_total = 0
        self.prev_cpu_idle = 0
        while True:
            # CPU usage
            try:
                with open('/proc/stat', 'r') as f:
                    for line in f:
                        if line.startswith('cpu '):
                            parts = line.split()
                            user = int(parts[1])
                            nice = int(parts[2])
                            system = int(parts[3])
                            idle = int(parts[4])
                            total = user + nice + system + idle
                            if self.prev_cpu_total > 0:
                                usage = ((total - self.prev_cpu_total) - (idle - self.prev_cpu_idle)) / (total - self.prev_cpu_total) * 100
                                self.cpu_updated.emit(usage)
                            self.prev_cpu_total = total
                            self.prev_cpu_idle = idle
                            break
            except:
                self.cpu_updated.emit(0)

            # Memory usage
            try:
                with open('/proc/meminfo', 'r') as f:
                    meminfo = {}
                    for line in f:
                        key, value = line.split(':', 1)
                        meminfo[key] = value.strip().split(' ')[0]
                total = int(meminfo['MemTotal'])
                available = int(meminfo['MemAvailable'])
                used = total - available
                percent = (used / total) * 100
                self.memory_updated.emit(percent)
            except:
                self.memory_updated.emit(0)

            # Battery - Enhanced with time information
            try:
                capacity, status, time_str = self.get_battery_info()
                self.battery_updated.emit(capacity, status, time_str)
            except:
                self.battery_updated.emit(0, "Unknown", "")

            # Volume - try multiple methods with proper backend detection
            volume, muted = None, None
            # Try PipeWire/PulseAudio first
            volume, muted = self.get_volume_pulse()
            # If PipeWire/PulseAudio failed, try ALSA
            if volume is None:
                volume, muted = self.get_volume_amixer()
            # If all failed, emit default values
            if volume is None:
                volume, muted = 0, False
                print("Warning: Could not get volume - no audio tool found")
            self.volume_updated.emit(volume, muted)

            # Network
            try:
                ssid = subprocess.run(
                    "iwgetid -r 2>/dev/null || echo ''",
                    shell=True, capture_output=True, text=True
                ).stdout.strip()
                if ssid:
                    self.network_updated.emit(ssid, "connected")
                else:
                    # Check ethernet
                    ethernet = subprocess.run(
                        "ip route | grep default | head -1 | awk '{print $5}' 2>/dev/null || echo ''",
                        shell=True, capture_output=True, text=True
                    ).stdout.strip()
                    if ethernet:
                        self.network_updated.emit(ethernet, "connected")
                    else:
                        self.network_updated.emit("", "disconnected")
            except:
                self.network_updated.emit("", "disconnected")

            # Brightness
            try:
                result = subprocess.run(
                    "brightnessctl get && brightnessctl max",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode == 0:
                    current, max_val = map(int, result.stdout.splitlines())
                    brightness = int((current / max_val) * 100)
                    self.brightness_updated.emit(brightness)
            except:
                pass

            # Current workspace
            current_workspace = self.get_current_workspace()
            self.workspace_updated.emit(current_workspace)

            # Active window
            active_window = self.get_active_window()
            self.active_window_updated.emit(active_window)

            time.sleep(2)

class SystemTrayWidget(QWidget):
    """Widget to host system tray icons"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.layout = QHBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.layout.setSpacing(2)
        self.layout.setAlignment(Qt.AlignRight)
        # Set up system tray integration
        self.tray_icons = []
        self.setup_system_tray()

    def setup_system_tray(self):
        """Setup system tray integration using XEmbed"""
        try:
            # Try to find existing system tray
            if HAS_X11 and QX11Info.isPlatformX11():
                # Get the system tray selection atom
                import os
                os.environ['XDG_CURRENT_DESKTOP'] = 'XFCE'
                # Start sni-qt or similar if available
                subprocess.Popen(["which", "snid"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except Exception as e:
            print(f"System tray setup error: {e}")

    def add_tray_icon(self, icon_widget):
        """Add a tray icon widget to the tray area"""
        self.layout.addWidget(icon_widget)
        self.tray_icons.append(icon_widget)

    def clear_tray_icons(self):
        """Clear all tray icons"""
        for icon in self.tray_icons:
            icon.deleteLater()
        self.tray_icons.clear()

@dataclass
class PanelConfig:
    position: str = "top"
    height: int = 40
    opacity: float = 0.95
    blur_effect: bool = True
    show_date: bool = True
    show_battery: bool = True
    show_volume: bool = True
    show_network: bool = True
    show_tray: bool = True
    theme_variant: str = "tokyo_night"
    rounded_corners: bool = True
    corner_radius: int = 10
    show_xfce_launchers: bool = True
    
    # New features
    show_workspace_switcher: bool = True
    show_brightness_control: bool = True
    show_weather: bool = True
    show_notifications: bool = True
    
    # Network and Bluetooth controls
    show_network_control: bool = True
    show_bluetooth_control: bool = True
    weather_location: str = ""
    
    # Tiling control
    show_tiling_control: bool = True
    
    # Auto-hide settings
    auto_hide: bool = False
    auto_hide_delay: int = 2000
    show_on_edge: bool = True
    edge_size: int = 5

    # Built-in launcher configurations
    terminal_command: str = "xfce4-terminal"
    file_manager_command: str = "thunar"
    browser_command: str = "firefox"
    text_editor_command: str = "mousepad"
    settings_command: str = "xfce4-settings-manager"
    calculator_command: str = "gnome-calculator"
    screenshot_command: str = "xfce4-screenshooter"
    image_viewer_command: str = "ristretto"
    music_player_command: str = "vlc"
    music_player_args: str = ""
    
    # Clock and date customization
    clock_font_size: int = 11
    date_font_size: int = 8
    clock_color: str = TokyoNight.MOON_GLOW
    date_color: str = TokyoNight.FOREGROUND
    clock_font_weight: str = "bold"
    date_font_weight: str = "normal"
    show_seconds: bool = False
    date_format: str = "ddd MMM d"
    time_format: str = "hh:mm AP"

    # Custom launchers
    launcher_customizations: List[Application] = None
    custom_launchers: list = None

    def __post_init__(self):
        """Initialize lists after creation"""
        if self.launcher_customizations is None:
            self.launcher_customizations = []
        if self.custom_launchers is None:
            self.custom_launchers = []



class LauncherDialog(QDialog):
    """Dialog for adding/editing a launcher with system icon support and workspace targeting"""
    def __init__(self, parent=None, launcher=None):
        super().__init__(parent)
        self.launcher = launcher
        self.setup_ui()
        if self.launcher:
            # If editing, set the initial values
            self.name_edit.setText(self.launcher.name)
            self.command_edit.setText(self.launcher.command)
            self.args_edit.setText(self.launcher.args)
            self.icon_edit.setText(self.launcher.icon)
            self.workspace_combo.setCurrentIndex(self.launcher.workspace + 1)  # +1 because index 0 is "Current"

    def setup_ui(self):
        self.setWindowTitle("Add Launcher" if not self.launcher else "Edit Launcher")
        self.setFixedSize(450, 350)  # Increased height for workspace option
        self.setStyleSheet(f"""
            QDialog {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border-radius: 8px;
                border: 1px solid {TokyoNight.NEBULA};
            }}
            QLabel {{
                color: {TokyoNight.FOREGROUND};
            }}
            QLineEdit, QComboBox {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                padding: 5px;
                border-radius: 3px;
            }}
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}, 
                    stop:1 {TokyoNight.PURPLE});
                color: {TokyoNight.BACKGROUND};
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.CYAN}, 
                    stop:1 {TokyoNight.BLUE});
            }}
        """)
        layout = QFormLayout()
        
        self.name_edit = QLineEdit()
        if self.launcher:
            self.name_edit.setText(self.launcher.name)
        layout.addRow("Name:", self.name_edit)
        
        self.command_edit = QLineEdit()
        if self.launcher:
            self.command_edit.setText(self.launcher.command)
        layout.addRow("Command:", self.command_edit)
        
        self.args_edit = QLineEdit()
        if self.launcher:
            self.args_edit.setText(self.launcher.args)
        self.args_edit.setPlaceholderText("Optional arguments")
        layout.addRow("Arguments:", self.args_edit)
        
        # Icon selection
        icon_selection_layout = QHBoxLayout()
        self.icon_edit = QLineEdit()
        self.icon_edit.setPlaceholderText("Enter system icon name (e.g., 'firefox', 'thunar') or path")
        if self.launcher:
            self.icon_edit.setText(self.launcher.icon)
        browse_icon_btn = QPushButton("Browse System Icon")
        browse_icon_btn.clicked.connect(self.browse_system_icon)
        icon_selection_layout.addWidget(self.icon_edit)
        icon_selection_layout.addWidget(browse_icon_btn)
        layout.addRow("Icon (name or path):", icon_selection_layout)
        
        # NEW: Workspace selection
        self.workspace_combo = QComboBox()
        # Get available workspaces
        workspaces = self.get_available_workspaces()
        self.workspace_combo.addItem("Current Workspace", -1)  # -1 means current
        for i, workspace_name in enumerate(workspaces):
            self.workspace_combo.addItem(f"Workspace {i+1}: {workspace_name}", i)
        layout.addRow("Open in Workspace:", self.workspace_combo)
        
        buttons_layout = QHBoxLayout()
        save_btn = QPushButton("Save")
        save_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        buttons_layout.addWidget(save_btn)
        buttons_layout.addWidget(cancel_btn)
        layout.addRow(buttons_layout)
        
        self.setLayout(layout)

    def get_available_workspaces(self):
        """Get list of available workspace names"""
        workspaces = []
        try:
            result = subprocess.run("wmctrl -d", shell=True, capture_output=True, text=True)
            if result.returncode == 0:
                for line in result.stdout.splitlines():
                    # Extract workspace name (the part after the resolution)
                    parts = line.split()
                    if len(parts) >= 9:
                        # Join the parts that form the workspace name
                        name_parts = parts[8:]
                        workspace_name = ' '.join(name_parts)
                        workspaces.append(workspace_name)
                    else:
                        workspaces.append(f"Workspace {len(workspaces)}")
        except Exception as e:
            print(f"Error getting workspaces: {e}")
            # Fallback: create generic workspace names
            workspaces = [f"Workspace {i+1}" for i in range(4)]
        return workspaces

    def browse_system_icon(self):
        """Open a simple dialog to enter a system icon name."""
        icon_name, ok = QInputDialog.getText(
            self, "System Icon Name", "Enter system icon name (e.g., 'firefox', 'thunar', 'terminal'):", 
            QLineEdit.Normal, self.icon_edit.text()
        )
        if ok:
            self.icon_edit.setText(icon_name)

    def get_launcher(self):
        """Get the launcher from the dialog."""
        workspace_index = self.workspace_combo.currentData()
        return Application(
            name=self.name_edit.text(),
            command=self.command_edit.text(),
            args=self.args_edit.text(),
            icon=self.icon_edit.text() or "üöÄ",
            workspace=workspace_index
        )
        
class SettingsDialog(QDialog):
    def __init__(self, config: PanelConfig, parent=None):
        super().__init__(parent)
        self.config = config
        self.setup_ui()

    def setup_ui(self):
        self.setWindowTitle("Panel Settings")
        self.setFixedSize(600, 700)
        self.setStyleSheet(self.get_stylesheet())

        layout = QVBoxLayout()
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(8)
        
        # Create tabs
        tabs = QTabWidget()
        tabs.setStyleSheet(f"""
            QTabWidget::pane {{
                border: 1px solid {TokyoNight.SELECTION};
                border-radius: 6px;
                background: {TokyoNight.NIGHT_BOTTOM};
            }}
            QTabBar::tab {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                padding: 8px 12px;
                margin-right: 2px;
                border-top-left-radius: 6px;
                border-top-right-radius: 6px;
                font-size: 9pt;
            }}
            QTabBar::tab:selected {{
                background: {TokyoNight.BLUE};
            }}
            QTabBar::tab:hover {{
                background: {TokyoNight.BLUE}40;
            }}
        """)

        # Appearance tab
        appearance_tab = QWidget()
        appearance_tab.setStyleSheet(f"background: {TokyoNight.NIGHT_BOTTOM};")
        appearance_layout = QFormLayout(appearance_tab)
        appearance_layout.setContentsMargins(8, 8, 8, 8)
        appearance_layout.setSpacing(6)
        
        self.position_combo = QComboBox()
        self.position_combo.addItems(["top", "bottom"])
        self.position_combo.setCurrentText(self.config.position)
        appearance_layout.addRow("Position:", self.position_combo)
        
        self.height_spin = QSpinBox()
        self.height_spin.setRange(30, 100)
        self.height_spin.setValue(self.config.height)
        appearance_layout.addRow("Height:", self.height_spin)
        
        opacity_layout = QHBoxLayout()
        self.opacity_slider = QSlider(Qt.Horizontal)
        self.opacity_slider.setRange(50, 100)
        self.opacity_slider.setValue(int(self.config.opacity * 100))
        self.opacity_label = QLabel(f"{self.opacity_slider.value()}%")
        self.opacity_slider.valueChanged.connect(lambda v: self.opacity_label.setText(f"{v}%"))
        opacity_layout.addWidget(self.opacity_slider)
        opacity_layout.addWidget(self.opacity_label)
        opacity_layout.setStretch(0, 3)
        opacity_layout.setStretch(1, 1)
        appearance_layout.addRow("Opacity:", opacity_layout)
        
        self.theme_combo = QComboBox()
        self.theme_combo.addItems(["tokyo_night", "tokyo_storm", "tokyo_day"])
        self.theme_combo.setCurrentText(self.config.theme_variant)
        appearance_layout.addRow("Theme:", self.theme_combo)
        
        # Rounded corners
        corners_layout = QHBoxLayout()
        self.rounded_corners_check = QCheckBox("Rounded Corners")
        self.rounded_corners_check.setChecked(self.config.rounded_corners)
        self.corner_radius_spin = QSpinBox()
        self.corner_radius_spin.setRange(0, 30)
        self.corner_radius_spin.setValue(self.config.corner_radius)
        self.corner_radius_spin.setEnabled(self.config.rounded_corners)
        self.rounded_corners_check.toggled.connect(self.corner_radius_spin.setEnabled)
        corners_layout.addWidget(self.rounded_corners_check)
        corners_layout.addWidget(QLabel("Radius:"))
        corners_layout.addWidget(self.corner_radius_spin)
        corners_layout.addStretch()
        appearance_layout.addRow("Corners:", corners_layout)

        # Auto-hide settings
        auto_hide_group = QGroupBox("Auto-Hide")
        auto_hide_group.setStyleSheet(f"""
            QGroupBox {{
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
                background: {TokyoNight.NIGHT_BOTTOM}80;
            }}
            QGroupBox::title {{
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }}
        """)
        auto_hide_layout = QFormLayout(auto_hide_group)
        auto_hide_layout.setContentsMargins(8, 15, 8, 8)
        auto_hide_layout.setSpacing(6)
        
        self.auto_hide_check = QCheckBox("Enable Auto-Hide")
        self.auto_hide_check.setChecked(self.config.auto_hide)
        auto_hide_layout.addRow(self.auto_hide_check)
        
        self.auto_hide_delay_spin = QSpinBox()
        self.auto_hide_delay_spin.setRange(500, 5000)
        self.auto_hide_delay_spin.setValue(self.config.auto_hide_delay)
        self.auto_hide_delay_spin.setSuffix(" ms")
        auto_hide_layout.addRow("Hide Delay:", self.auto_hide_delay_spin)
        
        self.show_on_edge_check = QCheckBox("Show on Edge Hover")
        self.show_on_edge_check.setChecked(self.config.show_on_edge)
        auto_hide_layout.addRow(self.show_on_edge_check)
        
        self.edge_size_spin = QSpinBox()
        self.edge_size_spin.setRange(1, 20)
        self.edge_size_spin.setValue(self.config.edge_size)
        self.edge_size_spin.setSuffix(" px")
        auto_hide_layout.addRow("Edge Size:", self.edge_size_spin)
        
        appearance_layout.addRow(auto_hide_group)

        # Modules tab
        modules_tab = QWidget()
        modules_tab.setStyleSheet(f"background: {TokyoNight.NIGHT_BOTTOM};")
        modules_layout = QVBoxLayout(modules_tab)
        modules_layout.setContentsMargins(8, 8, 8, 8)
        
        # Create scroll area for modules
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        scroll.setStyleSheet(f"""
            QScrollArea {{
                border: none;
                background: {TokyoNight.NIGHT_BOTTOM};
            }}
            QScrollBar:vertical {{
                background: {TokyoNight.SELECTION};
                width: 8px;
                border-radius: 4px;
            }}
            QScrollBar::handle:vertical {{
                background: {TokyoNight.BLUE};
                border-radius: 4px;
                min-height: 20px;
            }}
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{
                border: none;
                background: none;
            }}
        """)
        
        modules_widget = QWidget()
        modules_widget.setStyleSheet(f"background: {TokyoNight.NIGHT_BOTTOM};")
        modules_scroll_layout = QVBoxLayout(modules_widget)
        modules_scroll_layout.setSpacing(8)
        modules_scroll_layout.setContentsMargins(5, 5, 5, 5)
        
        modules = [
            ("Show Date", "show_date_check", self.config.show_date),
            ("Show Battery", "show_battery_check", self.config.show_battery),
            ("Show Volume", "show_volume_check", self.config.show_volume),
            ("Show Network Status", "show_network_check", self.config.show_network),
            ("Show System Tray", "show_tray_check", self.config.show_tray),
            ("Show XFCE Launchers", "show_xfce_launchers_check", self.config.show_xfce_launchers),
            ("Show Workspace Switcher", "show_workspace_switcher_check", self.config.show_workspace_switcher),
            ("Show Brightness Control", "show_brightness_control_check", self.config.show_brightness_control),
            ("Show Weather Widget", "show_weather_check", self.config.show_weather),
            ("Show Notification Center", "show_notifications_check", self.config.show_notifications),
            ("Show Network Manager Control", "show_network_control_check", self.config.show_network_control),
            ("Show Bluetooth Manager Control", "show_bluetooth_control_check", self.config.show_bluetooth_control),
            ("Show Tiling Control", "show_tiling_control_check", self.config.show_tiling_control),
        ]
        
        for name, attr, value in modules:
            checkbox = QCheckBox(name)
            checkbox.setChecked(value)
            checkbox.setStyleSheet(f"""
                QCheckBox {{
                    color: {TokyoNight.FOREGROUND};
                    background: transparent;
                    spacing: 8px;
                }}
                QCheckBox::indicator {{
                    width: 16px;
                    height: 16px;
                    border-radius: 3px;
                }}
                QCheckBox::indicator:unchecked {{
                    background: {TokyoNight.SELECTION};
                    border: 1px solid {TokyoNight.NEBULA};
                }}
                QCheckBox::indicator:checked {{
                    background: {TokyoNight.BLUE};
                    border: 1px solid {TokyoNight.BLUE};
                }}
                QCheckBox:hover {{
                    color: {TokyoNight.BRIGHT_WHITE};
                }}
            """)
            setattr(self, attr, checkbox)
            modules_scroll_layout.addWidget(checkbox)
        
        modules_scroll_layout.addStretch()
        scroll.setWidget(modules_widget)
        modules_layout.addWidget(scroll)

        # Weather settings tab
        weather_tab = QWidget()
        weather_tab.setStyleSheet(f"background: {TokyoNight.NIGHT_BOTTOM};")
        weather_layout = QFormLayout(weather_tab)
        weather_layout.setContentsMargins(8, 8, 8, 8)
        weather_layout.setSpacing(6)
        
        self.weather_location_edit = QLineEdit()
        self.weather_location_edit.setPlaceholderText("Leave empty for auto-detection")
        self.weather_location_edit.setText(self.config.weather_location)
        weather_layout.addRow("Location:", self.weather_location_edit)
        
        weather_info = QLabel("Weather data from wttr.in")
        weather_info.setStyleSheet(f"color: {TokyoNight.COMMENT}; font-size: 8pt;")
        weather_layout.addRow(weather_info)

        # Launchers tab - FIXED VERSION
        launchers_tab = QWidget()
        launchers_tab.setStyleSheet(f"background: {TokyoNight.NIGHT_BOTTOM};")
        launchers_layout = QVBoxLayout(launchers_tab)
        launchers_layout.setContentsMargins(8, 8, 8, 8)
        launchers_layout.setSpacing(6)
        
        instructions = QLabel("Manage your custom application launchers:")
        instructions.setStyleSheet(f"color: {TokyoNight.FOREGROUND}; margin-bottom: 5px; font-size: 9pt;")
        launchers_layout.addWidget(instructions)
        
        # List of launchers
        self.launchers_list = QListWidget()
        self.launchers_list.setMaximumHeight(150)
        self.launchers_list.setStyleSheet(f"""
            QListWidget {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 4px;
                padding: 3px;
            }}
            QListWidget::item {{
                padding: 8px;
                border-radius: 3px;
                font-size: 9pt;
                border-bottom: 1px solid {TokyoNight.NEBULA}40;
            }}
            QListWidget::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
            QListWidget::item:hover {{
                background: {TokyoNight.BLUE}20;
            }}
        """)
        launchers_layout.addWidget(self.launchers_list)
        
        # Buttons for launcher management
        buttons_layout = QHBoxLayout()
        
        add_btn = QPushButton("Û∞êï Add")
        add_btn.setFixedHeight(32)
        add_btn.setStyleSheet(f"""
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.GREEN}, 
                    stop:1 {TokyoNight.BRIGHT_GREEN});
                color: {TokyoNight.BACKGROUND};
                border: none;
                border-radius: 4px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BRIGHT_GREEN}, 
                    stop:1 {TokyoNight.GREEN});
            }}
        """)
        add_btn.clicked.connect(self.add_launcher)
        buttons_layout.addWidget(add_btn)
        
        edit_btn = QPushButton("Û∞è´ Edit")
        edit_btn.setFixedHeight(32)
        edit_btn.setStyleSheet(f"""
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}, 
                    stop:1 {TokyoNight.PURPLE});
                color: {TokyoNight.BACKGROUND};
                border: none;
                border-radius: 4px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.PURPLE}, 
                    stop:1 {TokyoNight.BLUE});
            }}
        """)
        edit_btn.clicked.connect(self.edit_launcher)
        buttons_layout.addWidget(edit_btn)
        
        remove_btn = QPushButton("Û∞Ü¥ Remove")
        remove_btn.setFixedHeight(32)
        remove_btn.setStyleSheet(f"""
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.RED}, 
                    stop:1 {TokyoNight.BRIGHT_RED});
                color: {TokyoNight.BACKGROUND};
                border: none;
                border-radius: 4px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BRIGHT_RED}, 
                    stop:1 {TokyoNight.RED});
            }}
        """)
        remove_btn.clicked.connect(self.remove_launcher)
        buttons_layout.addWidget(remove_btn)
        
        buttons_layout.addStretch()
        launchers_layout.addLayout(buttons_layout)
        
        # Info label
        info_label = QLabel("Launchers will appear in the applications menu and panel context menu")
        info_label.setStyleSheet(f"color: {TokyoNight.COMMENT}; font-size: 8pt; margin-top: 8px;")
        launchers_layout.addWidget(info_label)
        
        # Load existing launchers
        self.load_launchers()
        
        # Connect double-click to edit
        self.launchers_list.itemDoubleClicked.connect(self.edit_launcher)

        # Built-in launchers tab
        builtin_tab = QWidget()
        builtin_tab.setStyleSheet(f"background: {TokyoNight.NIGHT_BOTTOM};")
        builtin_layout = QFormLayout(builtin_tab)
        builtin_layout.setContentsMargins(8, 8, 8, 8)
        builtin_layout.setSpacing(6)
        
        builtin_title = QLabel("Configure built-in application launchers:")
        builtin_title.setStyleSheet(f"color: {TokyoNight.FOREGROUND}; font-weight: bold; margin-bottom: 8px; font-size: 9pt;")
        builtin_layout.addRow(builtin_title)
        
        # Group common applications
        apps = [
            ("Terminal:", "terminal_edit", self.config.terminal_command, "xfce4-terminal, gnome-terminal, konsole"),
            ("File Manager:", "file_manager_edit", self.config.file_manager_command, "thunar, nautilus, dolphin"),
            ("Web Browser:", "browser_edit", self.config.browser_command, "firefox, chromium, google-chrome"),
            ("Text Editor:", "text_editor_edit", self.config.text_editor_command, "mousepad, gedit, kate"),
            ("Settings:", "settings_edit", self.config.settings_command, "xfce4-settings-manager, gnome-control-center"),
            ("Calculator:", "calculator_edit", self.config.calculator_command, "gnome-calculator, kcalc"),
            ("Screenshot:", "screenshot_edit", self.config.screenshot_command, "xfce4-screenshooter, gnome-screenshot"),
            ("Image Viewer:", "image_viewer_edit", self.config.image_viewer_command, "ristretto, eog, gwenview"),
            ("Music Player:", "music_player_edit", self.config.music_player_command, "vlc, mpv, audacious"),
        ]
        
        for label, attr, value, placeholder in apps:
            edit = QLineEdit(value)
            edit.setPlaceholderText(placeholder)
            edit.setStyleSheet(f"font-size: 9pt; background: {TokyoNight.SELECTION}; color: {TokyoNight.FOREGROUND}; border: 1px solid {TokyoNight.NEBULA}; border-radius: 3px; padding: 4px;")
            setattr(self, attr, edit)
            builtin_layout.addRow(label, edit)
        
        # Music Player Arguments
        self.music_player_args_edit = QLineEdit()
        self.music_player_args_edit.setText(self.config.music_player_args)
        self.music_player_args_edit.setPlaceholderText("Optional arguments for music player")
        self.music_player_args_edit.setStyleSheet(f"font-size: 9pt; background: {TokyoNight.SELECTION}; color: {TokyoNight.FOREGROUND}; border: 1px solid {TokyoNight.NEBULA}; border-radius: 3px; padding: 4px;")
        builtin_layout.addRow("Music Player Args:", self.music_player_args_edit)

        # Clock & Date tab
        clock_tab = QWidget()
        clock_tab.setStyleSheet(f"background: {TokyoNight.NIGHT_BOTTOM};")
        clock_layout = QFormLayout(clock_tab)
        clock_layout.setContentsMargins(8, 8, 8, 8)
        clock_layout.setSpacing(6)
        
        # Font sizes in a compact row
        font_sizes_layout = QHBoxLayout()
        self.clock_font_size_spin = QSpinBox()
        self.clock_font_size_spin.setRange(8, 20)
        self.clock_font_size_spin.setValue(self.config.clock_font_size)
        self.clock_font_size_spin.setPrefix("Clock: ")
        self.clock_font_size_spin.setSuffix("pt")
        font_sizes_layout.addWidget(self.clock_font_size_spin)
        
        self.date_font_size_spin = QSpinBox()
        self.date_font_size_spin.setRange(6, 16)
        self.date_font_size_spin.setValue(self.config.date_font_size)
        self.date_font_size_spin.setPrefix("Date: ")
        self.date_font_size_spin.setSuffix("pt")
        font_sizes_layout.addWidget(self.date_font_size_spin)
        
        font_sizes_layout.addStretch()
        clock_layout.addRow("Font Sizes:", font_sizes_layout)
        
        # Colors in a compact row
        colors_layout = QHBoxLayout()
        self.clock_color_edit = QLineEdit(self.config.clock_color)
        self.clock_color_edit.setPlaceholderText("Clock color")
        self.clock_color_edit.setStyleSheet(f"font-size: 9pt; background: {TokyoNight.SELECTION}; color: {TokyoNight.FOREGROUND}; border: 1px solid {TokyoNight.NEBULA}; border-radius: 3px; padding: 4px;")
        clock_color_btn = QPushButton("...")
        clock_color_btn.setFixedSize(30, 25)
        clock_color_btn.clicked.connect(lambda: self.pick_color(self.clock_color_edit))
        colors_layout.addWidget(QLabel("Clock:"))
        colors_layout.addWidget(self.clock_color_edit)
        colors_layout.addWidget(clock_color_btn)
        
        self.date_color_edit = QLineEdit(self.config.date_color)
        self.date_color_edit.setPlaceholderText("Date color")
        self.date_color_edit.setStyleSheet(f"font-size: 9pt; background: {TokyoNight.SELECTION}; color: {TokyoNight.FOREGROUND}; border: 1px solid {TokyoNight.NEBULA}; border-radius: 3px; padding: 4px;")
        date_color_btn = QPushButton("...")
        date_color_btn.setFixedSize(30, 25)
        date_color_btn.clicked.connect(lambda: self.pick_color(self.date_color_edit))
        colors_layout.addWidget(QLabel("Date:"))
        colors_layout.addWidget(self.date_color_edit)
        colors_layout.addWidget(date_color_btn)
        
        clock_layout.addRow("Colors:", colors_layout)
        
        # Font weights in a compact row
        weights_layout = QHBoxLayout()
        self.clock_font_weight_combo = QComboBox()
        self.clock_font_weight_combo.addItems(["normal", "bold", "light"])
        self.clock_font_weight_combo.setCurrentText(self.config.clock_font_weight)
        weights_layout.addWidget(QLabel("Clock:"))
        weights_layout.addWidget(self.clock_font_weight_combo)
        
        self.date_font_weight_combo = QComboBox()
        self.date_font_weight_combo.addItems(["normal", "bold", "light"])
        self.date_font_weight_combo.setCurrentText(self.config.date_font_weight)
        weights_layout.addWidget(QLabel("Date:"))
        weights_layout.addWidget(self.date_font_weight_combo)
        
        weights_layout.addStretch()
        clock_layout.addRow("Font Weight:", weights_layout)
        
        # Show seconds
        self.show_seconds_check = QCheckBox("Show Seconds in Clock")
        self.show_seconds_check.setChecked(self.config.show_seconds)
        clock_layout.addRow(self.show_seconds_check)
        
        # Date format
        self.date_format_combo = QComboBox()
        self.date_format_combo.addItems([
            "Mon Jan 1",
            "Monday, January 1", 
            "01/01/2024",
            "01-01-2024",
            "2024-01-01",
            "Custom..."
        ])
        if self.config.date_format in ["ddd MMM d", "dddd, MMMM d", "MM/dd/yyyy", "dd-MM-yyyy", "yyyy-MM-dd"]:
            format_map = {
                "ddd MMM d": "Mon Jan 1",
                "dddd, MMMM d": "Monday, January 1",
                "MM/dd/yyyy": "01/01/2024", 
                "dd-MM-yyyy": "01-01-2024",
                "yyyy-MM-dd": "2024-01-01"
            }
            self.date_format_combo.setCurrentText(format_map.get(self.config.date_format, "Mon Jan 1"))
        else:
            self.date_format_combo.setCurrentText("Custom...")
        self.custom_date_edit = QLineEdit(self.config.date_format)
        self.custom_date_edit.setPlaceholderText("Custom date format")
        self.custom_date_edit.setStyleSheet(f"font-size: 9pt; background: {TokyoNight.SELECTION}; color: {TokyoNight.FOREGROUND}; border: 1px solid {TokyoNight.NEBULA}; border-radius: 3px; padding: 4px;")
        clock_layout.addRow("Date Format:", self.date_format_combo)
        clock_layout.addRow("Custom Format:", self.custom_date_edit)
        
        # Time format  
        self.time_format_combo = QComboBox()
        self.time_format_combo.addItems([
            "12:00 PM",
            "24:00",
            "12:00:00 PM",
            "24:00:00",
            "Custom..."
        ])
        format_map = {
            "hh:mm AP": "12:00 PM",
            "HH:mm": "24:00",
            "hh:mm:ss AP": "12:00:00 PM",
            "HH:mm:ss": "24:00:00"
        }
        if self.config.time_format in format_map:
            self.time_format_combo.setCurrentText(format_map[self.config.time_format])
        else:
            self.time_format_combo.setCurrentText("Custom...")
        self.custom_time_edit = QLineEdit(self.config.time_format)
        self.custom_time_edit.setPlaceholderText("Custom time format")
        self.custom_time_edit.setStyleSheet(f"font-size: 9pt; background: {TokyoNight.SELECTION}; color: {TokyoNight.FOREGROUND}; border: 1px solid {TokyoNight.NEBULA}; border-radius: 3px; padding: 4px;")
        clock_layout.addRow("Time Format:", self.time_format_combo)
        clock_layout.addRow("Custom Format:", self.custom_time_edit)
        
        # Format help
        help_label = QLabel("Format codes: d=day, M=month, y=year, h=hour, m=minute, s=second, AP=AM/PM")
        help_label.setStyleSheet(f"color: {TokyoNight.COMMENT}; font-size: 7pt; margin-top: 8px;")
        clock_layout.addRow(help_label)

        # Add tabs
        tabs.addTab(appearance_tab, "Appearance")
        tabs.addTab(modules_tab, "Modules") 
        tabs.addTab(weather_tab, "Weather")
        tabs.addTab(launchers_tab, "Custom Launchers")
        tabs.addTab(builtin_tab, "Built-in")
        tabs.addTab(clock_tab, "Clock")

        layout.addWidget(tabs)

        # Buttons
        button_layout = QHBoxLayout()
        save_btn = QPushButton("Save Settings")
        save_btn.setFixedHeight(32)
        save_btn.clicked.connect(self.save_settings)
        cancel_btn = QPushButton("Cancel")  
        cancel_btn.setFixedHeight(32)
        cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(save_btn)
        button_layout.addWidget(cancel_btn)
        layout.addLayout(button_layout)

        self.setLayout(layout)

    def load_launchers(self):
        """Load existing launchers into the list"""
        self.launchers_list.clear()
        if self.config.launcher_customizations:
            for launcher in self.config.launcher_customizations:
                # Create a descriptive item text
                workspace_info = "Current" if launcher.workspace == -1 else f"WS{launcher.workspace + 1}"
                item_text = f"{launcher.icon} {launcher.name} ‚Üí {launcher.command}"
                if launcher.args:
                    item_text += f" {launcher.args}"
                item_text += f" [{workspace_info}]"
                
                item = QListWidgetItem(item_text)
                item.setData(Qt.UserRole, launcher)
                self.launchers_list.addItem(item)
        print(f"DEBUG: Loaded {self.launchers_list.count()} launchers")

    def add_launcher(self):
        """Add a new launcher"""
        print("DEBUG: Add launcher clicked")
        dialog = LauncherDialog(self)
        if dialog.exec_() == QDialog.Accepted:
            launcher = dialog.get_launcher()
            if launcher and launcher.name and launcher.command:
                # Add to list
                workspace_info = "Current" if launcher.workspace == -1 else f"WS{launcher.workspace + 1}"
                item_text = f"{launcher.icon} {launcher.name} ‚Üí {launcher.command}"
                if launcher.args:
                    item_text += f" {launcher.args}"
                item_text += f" [{workspace_info}]"
                
                item = QListWidgetItem(item_text)
                item.setData(Qt.UserRole, launcher)
                self.launchers_list.addItem(item)
                print(f"DEBUG: Added launcher: {launcher.name}")
            else:
                QMessageBox.warning(self, "Invalid Launcher", "Please provide both name and command for the launcher.")

    def edit_launcher(self):
        """Edit selected launcher"""
        current_item = self.launchers_list.currentItem()
        if not current_item:
            QMessageBox.information(self, "No Selection", "Please select a launcher to edit.")
            return
        
        launcher = current_item.data(Qt.UserRole)
        if not launcher:
            return
            
        print(f"DEBUG: Editing launcher: {launcher.name}")
        dialog = LauncherDialog(self, launcher)
        if dialog.exec_() == QDialog.Accepted:
            updated_launcher = dialog.get_launcher()
            if updated_launcher and updated_launcher.name and updated_launcher.command:
                # Update the list item
                workspace_info = "Current" if updated_launcher.workspace == -1 else f"WS{updated_launcher.workspace + 1}"
                item_text = f"{updated_launcher.icon} {updated_launcher.name} ‚Üí {updated_launcher.command}"
                if updated_launcher.args:
                    item_text += f" {updated_launcher.args}"
                item_text += f" [{workspace_info}]"
                
                current_item.setText(item_text)
                current_item.setData(Qt.UserRole, updated_launcher)
                print(f"DEBUG: Updated launcher: {updated_launcher.name}")
            else:
                QMessageBox.warning(self, "Invalid Launcher", "Please provide both name and command for the launcher.")

    def remove_launcher(self):
        """Remove selected launcher"""
        current_item = self.launchers_list.currentItem()
        if not current_item:
            QMessageBox.information(self, "No Selection", "Please select a launcher to remove.")
            return
            
        launcher = current_item.data(Qt.UserRole)
        if launcher:
            reply = QMessageBox.question(
                self, "Confirm Removal", 
                f"Are you sure you want to remove '{launcher.name}'?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            if reply == QMessageBox.Yes:
                row = self.launchers_list.row(current_item)
                self.launchers_list.takeItem(row)
                print(f"DEBUG: Removed launcher: {launcher.name}")

    def pick_color(self, line_edit):
        """Open color picker dialog"""
        current_color = QColor(line_edit.text())
        color = QColorDialog.getColor(current_color, self, "Choose Color")
        if color.isValid():
            line_edit.setText(color.name())

    def save_settings(self):
        """Save all settings including clock customization"""
        # Save appearance settings
        self.config.position = self.position_combo.currentText()
        self.config.height = self.height_spin.value()
        self.config.opacity = self.opacity_slider.value() / 100.0
        self.config.theme_variant = self.theme_combo.currentText()
        self.config.rounded_corners = self.rounded_corners_check.isChecked()
        self.config.corner_radius = self.corner_radius_spin.value()
        
        # Save module visibility settings
        self.config.show_date = self.show_date_check.isChecked()
        self.config.show_battery = self.show_battery_check.isChecked()
        self.config.show_volume = self.show_volume_check.isChecked()
        self.config.show_network = self.show_network_check.isChecked()
        self.config.show_tray = self.show_tray_check.isChecked()
        self.config.show_xfce_launchers = self.show_xfce_launchers_check.isChecked()
        self.config.show_workspace_switcher = self.show_workspace_switcher_check.isChecked()
        self.config.show_brightness_control = self.show_brightness_control_check.isChecked()
        self.config.show_weather = self.show_weather_check.isChecked()
        self.config.show_notifications = self.show_notifications_check.isChecked()
        self.config.show_network_control = self.show_network_control_check.isChecked()
        self.config.show_bluetooth_control = self.show_bluetooth_control_check.isChecked()
        # NEW: Tiling control
        self.config.show_tiling_control = self.show_tiling_control_check.isChecked()
        
        # Save weather settings
        self.config.weather_location = self.weather_location_edit.text()
        
        # Save auto-hide settings
        self.config.auto_hide = self.auto_hide_check.isChecked()
        self.config.auto_hide_delay = self.auto_hide_delay_spin.value()
        self.config.show_on_edge = self.show_on_edge_check.isChecked()
        self.config.edge_size = self.edge_size_spin.value()
        
        # Save built-in launcher commands
        self.config.terminal_command = self.terminal_edit.text()
        self.config.file_manager_command = self.file_manager_edit.text()
        self.config.browser_command = self.browser_edit.text()
        self.config.text_editor_command = self.text_editor_edit.text()
        self.config.settings_command = self.settings_edit.text()
        self.config.calculator_command = self.calculator_edit.text()
        self.config.screenshot_command = self.screenshot_edit.text()
        self.config.image_viewer_command = self.image_viewer_edit.text()
        self.config.music_player_command = self.music_player_edit.text()
        self.config.music_player_args = self.music_player_args_edit.text()
        
        # Save clock settings
        self.config.clock_font_size = self.clock_font_size_spin.value()
        self.config.date_font_size = self.date_font_size_spin.value()
        self.config.clock_color = self.clock_color_edit.text()
        self.config.date_color = self.date_color_edit.text()
        self.config.clock_font_weight = self.clock_font_weight_combo.currentText()
        self.config.date_font_weight = self.date_font_weight_combo.currentText()
        self.config.show_seconds = self.show_seconds_check.isChecked()
        
        # Handle date/time formats
        if self.date_format_combo.currentText() == "Custom...":
            self.config.date_format = self.custom_date_edit.text()
        else:
            self.config.date_format = self.date_format_combo.currentText()
            
        if self.time_format_combo.currentText() == "Custom...":
            self.config.time_format = self.custom_time_edit.text()
        else:
            self.config.time_format = self.time_format_combo.currentText()
        
        # CRITICAL FIX: Save custom launchers properly
        custom_launchers = []
        for i in range(self.launchers_list.count()):
            item = self.launchers_list.item(i)
            if item:
                launcher = item.data(Qt.UserRole)
                if launcher:
                    custom_launchers.append(launcher)
        
        self.config.launcher_customizations = custom_launchers
        print(f"DEBUG: Saved {len(custom_launchers)} custom launchers to config")
        
        self.accept()

    def get_stylesheet(self):
        return f"""
            QDialog {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border-radius: 8px;
                border: 1px solid {TokyoNight.NEBULA};
            }}
            QTabWidget::pane {{
                border: 1px solid {TokyoNight.SELECTION};
                background: {TokyoNight.NIGHT_BOTTOM};
                border-radius: 6px;
            }}
            QTabBar::tab {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                padding: 8px 16px;
                margin-right: 2px;
                border-top-left-radius: 6px;
                border-top-right-radius: 6px;
            }}
            QTabBar::tab:selected {{
                background: {TokyoNight.BLUE};
            }}
            QCheckBox {{
                color: {TokyoNight.FOREGROUND};
                spacing: 8px;
            }}
            QCheckBox::indicator {{
                width: 16px;
                height: 16px;
                border-radius: 3px;
            }}
            QCheckBox::indicator:unchecked {{
                background: {TokyoNight.SELECTION};
                border: 1px solid {TokyoNight.NEBULA};
            }}
            QCheckBox::indicator:checked {{
                background: {TokyoNight.BLUE};
                border: 1px solid {TokyoNight.BLUE};
            }}
            QComboBox, QSpinBox, QSlider, QLineEdit {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                padding: 5px;
                border-radius: 3px;
            }}
            QLineEdit {{
                padding: 6px;
            }}
            QComboBox::drop-down {{
                subcontrol-origin: padding;
                subcontrol-position: top right;
                width: 15px;
                border-left-width: 1px;
                border-left-color: {TokyoNight.NEBULA};
                border-left-style: solid;
                border-top-right-radius: 3px;
                border-bottom-right-radius: 3px;
                background-color: {TokyoNight.SELECTION};
            }}
            QComboBox::down-arrow {{
                image: none;
                border-left: 5px solid transparent;
                border-right: 5px solid transparent;
                border-top: 5px solid {TokyoNight.FOREGROUND};
                margin-right: 5px;
            }}
            QComboBox QAbstractItemView {{
                background: {TokyoNight.NIGHT_BOTTOM};
                color: {TokyoNight.FOREGROUND};
                selection-background-color: {TokyoNight.BLUE};
                selection-color: {TokyoNight.BACKGROUND};
                border: 1px solid {TokyoNight.SELECTION};
                border-radius: 4px;
            }}
            QSpinBox::up-button, QSpinBox::down-button {{
                subcontrol-origin: border;
                width: 16px;
                border-radius: 2px;
            }}
            QSpinBox::up-button {{
                subcontrol-position: top right;
            }}
            QSpinBox::down-button {{
                subcontrol-position: bottom right;
            }}
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}, 
                    stop:1 {TokyoNight.PURPLE});
                color: {TokyoNight.BACKGROUND};
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.CYAN}, 
                    stop:1 {TokyoNight.BLUE});
            }}
            QFormLayout {{
                color: {TokyoNight.FOREGROUND};
            }}
            QLabel {{
                color: {TokyoNight.FOREGROUND};
            }}
        """

    def save_settings(self):
        """Save all settings including built-in launcher commands and custom launchers"""
        # Save appearance settings
        self.config.position = self.position_combo.currentText()
        self.config.height = self.height_spin.value()
        self.config.opacity = self.opacity_slider.value() / 100.0
        self.config.theme_variant = self.theme_combo.currentText()
        self.config.rounded_corners = self.rounded_corners_check.isChecked()
        self.config.corner_radius = self.corner_radius_spin.value()
        
        # Save module visibility settings
        self.config.show_date = self.show_date_check.isChecked()
        self.config.show_battery = self.show_battery_check.isChecked()
        self.config.show_volume = self.show_volume_check.isChecked()
        self.config.show_network = self.show_network_check.isChecked()
        self.config.show_tray = self.show_tray_check.isChecked()
        self.config.show_xfce_launchers = self.show_xfce_launchers_check.isChecked()
        self.config.show_workspace_switcher = self.show_workspace_switcher_check.isChecked()
        self.config.show_brightness_control = self.show_brightness_control_check.isChecked()
        self.config.show_weather = self.show_weather_check.isChecked()
        self.config.show_notifications = self.show_notifications_check.isChecked()
        self.config.show_network_control = self.show_network_control_check.isChecked()
        self.config.show_bluetooth_control = self.show_bluetooth_control_check.isChecked()
        # NEW: Tiling control
        self.config.show_tiling_control = self.show_tiling_control_check.isChecked()
        
        # Save weather settings
        self.config.weather_location = self.weather_location_edit.text()
        
        # Save auto-hide settings
        self.config.auto_hide = self.auto_hide_check.isChecked()
        self.config.auto_hide_delay = self.auto_hide_delay_spin.value()
        self.config.show_on_edge = self.show_on_edge_check.isChecked()
        self.config.edge_size = self.edge_size_spin.value()
        
        # Save built-in launcher commands
        self.config.terminal_command = self.terminal_edit.text()
        self.config.file_manager_command = self.file_manager_edit.text()
        self.config.browser_command = self.browser_edit.text()
        self.config.text_editor_command = self.text_editor_edit.text()
        self.config.settings_command = self.settings_edit.text()
        self.config.calculator_command = self.calculator_edit.text()
        self.config.screenshot_command = self.screenshot_edit.text()
        self.config.image_viewer_command = self.image_viewer_edit.text()
        self.config.music_player_command = self.music_player_edit.text()
        self.config.music_player_args = self.music_player_args_edit.text()
        
        # CRITICAL FIX: Save custom launchers properly
        custom_launchers = []
        for i in range(self.launchers_list.count()):
            item = self.launchers_list.item(i)
            if item:
                launcher = item.data(Qt.UserRole)
                if launcher:
                    custom_launchers.append(launcher)
        
        self.config.launcher_customizations = custom_launchers
        print(f"DEBUG: Saved {len(custom_launchers)} custom launchers")  # Debug line
        
        self.accept()

from PyQt5.QtWidgets import QPushButton
from PyQt5.QtCore import Qt, QTimer, pyqtSignal
from PyQt5.QtGui import QMouseEvent

class CustomWindowButton(QPushButton):
    """Custom button that handles both single and double clicks properly"""
    single_clicked = pyqtSignal(str)  # window_id
    double_clicked = pyqtSignal(str)  # window_id
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.is_window_button = False
        self._window_id = None
        self._click_count = 0
        self._click_timer = QTimer()
        self._click_timer.setSingleShot(True)
        self._click_timer.timeout.connect(self._on_single_click_timeout)
        
    def setWindowId(self, window_id):
        self._window_id = window_id
        
    def windowId(self):
        return self._window_id

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self._click_count += 1
            if self._click_timer.isActive():
                # Second click detected within timeout - this is a double-click
                self._click_timer.stop()
                self._click_count = 0  # Reset
                self.double_clicked.emit(self._window_id)
            else:
                # First click - start timer to wait for potential double-click
                self._click_timer.start(400)  # 400ms timeout (adjust as needed)
        else:
            # Handle other mouse buttons normally
            super().mousePressEvent(event)

    def _on_single_click_timeout(self):
        """Called when single click timer expires (no second click within timeout)"""
        if self._click_count > 0:
            self._click_count = 0  # Reset
            self.single_clicked.emit(self._window_id)

class TokyoNightPanelBar(QMainWindow):
    # Define signals at the CLASS level, before __init__
    window_single_clicked = pyqtSignal(str)
    window_double_clicked = pyqtSignal(str)
    
    def __init__(self, config: PanelConfig):
        super().__init__()
        self.config = config
        self.applications = []
        self.window_buttons = {}
        self.xfce_launchers = []
        self.workspace_buttons = []
        self.notification_count = 0
        self.current_workspace = 0
        self.active_window_id = ""
        
        # Initialize garbage collection counter
        self._gc_counter = 0
        
        # Auto-hide properties
        self.auto_hide_timer = QTimer()
        self.auto_hide_timer.setSingleShot(True)
        self.auto_hide_timer.timeout.connect(self.hide_panel)
        self.is_hidden = False
        self.edge_detection_timer = QTimer()
        self.edge_detection_timer.timeout.connect(self.check_mouse_position)
        self.edge_detection_timer.start(100)
        
        # Initialize the rest of your setup
        self.setup_ui()
        self.load_applications()
        self.load_xfce_launchers()
        self.setup_system_monitor()
        self.start_timers()
        self.setup_strut()
        
        # Enable context menu
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_panel_context_menu)
        
        # Set up mouse tracking for auto-hide
        self.setMouseTracking(True)
        QApplication.instance().installEventFilter(self)
        
        # Start health monitoring
        self.start_health_monitor()
        
        # Start memory management
        self.memory_check_timer = QTimer()
        self.memory_check_timer.timeout.connect(self.force_garbage_collection)
        self.memory_check_timer.start(60000)  # Every minute
        
        # Start auto-hide if enabled
        if self.config.auto_hide:
            self.auto_hide_timer.start(self.config.auto_hide_delay)
        
        # Connect the custom signals (now that they're properly defined as class attributes)
        self.window_single_clicked.connect(self.handle_single_click_from_button)
        self.window_double_clicked.connect(self.handle_double_click_from_button)

    def create_window_button(self, window_title, window_id):
        """Create a window button with proper single/double click handling"""
        btn = CustomWindowButton(window_title[:18])
        btn.setFixedHeight(28)
        btn.is_window_button = True
        btn.setWindowId(window_id)
        
        # Connect the custom button signals to our handlers
        btn.single_clicked.connect(self.window_single_clicked.emit)
        btn.double_clicked.connect(self.window_double_clicked.emit)
        
        return btn

    def handle_single_click_from_button(self, window_id):
        """Handle single click from button - focus the window"""
        print(f"üéØ SINGLE CLICK - Focusing window {window_id}")
        self.focus_window_simple(window_id)

    def handle_double_click_from_button(self, window_id):
        """Handle double click from button - minimize the window"""
        print(f"ü™ü DOUBLE-CLICK - Minimizing window {window_id}")
        self.minimize_window(window_id)

    # Keep all your existing methods (focus_window_simple, minimize_window, etc.)
    # ... (rest of your existing methods remain unchanged)

    def handle_window_click(self, window_id):
            """Handle window button clicks with simple double-click detection"""
            print(f"üñ±Ô∏è Click detected for window: {window_id}")
            
            # Check if this is the second click for the same window_id within the timeout
            if self.pending_window_id == window_id and self.click_timer.isActive():
                # Double click detected - cancel single click timer and minimize
                self.click_timer.stop()
                print(f"ü™ü DOUBLE-CLICK - Minimizing window {window_id}")
                self.minimize_window(window_id)
                self.pending_window_id = None
            else:
                # First click - start timer for single click
                self.pending_window_id = window_id
                
                # üí° KEY CHANGE: Increased timeout to 400ms for more reliable double-click detection.
                self.click_timer.start(400)

    def handle_single_click(self):
            """Handle single click after double-click timeout"""
            if self.pending_window_id:
                print(f"üéØ SINGLE CLICK - Focusing window {self.pending_window_id}")
                # Focus/restore the window
                self.focus_window_simple(self.pending_window_id)
                
                # Reset the pending ID after the single click action is complete
                self.pending_window_id = None

    def create_window_button(self, window_title, window_id):
        """Create a window button with click handling"""
        btn = QPushButton(window_title[:18])
        btn.setFixedHeight(28)
        btn.is_window_button = True
        btn.setProperty("window_id", window_id)
        
        # Connect the click event
        btn.clicked.connect(lambda: self.handle_window_click(window_id))
        
        return btn

    def focus_window_simple(self, window_id):
        """Simple focus window"""
        try:
            print(f"Focusing window: {window_id}")
            # First try to unminimize if it's hidden
            subprocess.run(f"wmctrl -i -r {window_id} -b remove,hidden", shell=True)
            # Then focus it
            subprocess.run(f"wmctrl -i -a {window_id}", shell=True)
        except Exception as e:
            print(f"Focus error: {e}")

    def restore_window(self, window_id):
        """Restore a minimized window"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b remove,hidden", shell=True)
            subprocess.run(f"wmctrl -i -a {window_id}", shell=True)
            print(f"‚úÖ Window {window_id} restored and focused")
        except Exception as e:
            print(f"Restore error: {e}")

    def minimize_window(self, window_id):
        """Minimize a window by ID"""
        try:
            print(f"Minimizing window: {window_id}")
            
            # Try multiple methods to ensure it works
            methods = [
                f"wmctrl -i -r {window_id} -b add,hidden",
                f"xdotool windowminimize {window_id}",
                f"wmctrl -i -r {window_id} -b toggle,hidden"
            ]
            
            for method in methods:
                result = subprocess.run(method, shell=True, capture_output=True, text=True)
                if result.returncode == 0:
                    print(f"‚úÖ Window {window_id} minimized using: {method}")
                    return
            
            print(f"‚ùå Could not minimize window {window_id}")
                
        except Exception as e:
            print(f"Minimize error: {e}")

    def update_taskbar(self, wmctrl_output):
        """Update taskbar with current windows"""
        # Get the *currently* active window ID right now using xdotool
        active_window_id = None
        try:
            result = subprocess.run(
                ["xdotool", "getactivewindow"],
                capture_output=True, text=True, timeout=2
            )
            if result.returncode == 0:
                active_window_id = result.stdout.strip()
        except Exception as e:
            print(f"Error getting active window with xdotool: {e}")

        print(f"DEBUG: Active window ID: {active_window_id}")

        # Clear existing window buttons
        for i in reversed(range(self.taskbar_layout.count())):
            widget = self.taskbar_layout.itemAt(i).widget()
            if widget and hasattr(widget, 'is_window_button'):
                widget.deleteLater()

        # Add new window buttons
        windows = []
        for line in wmctrl_output.splitlines():
            parts = line.split(None, 3)
            if len(parts) >= 4:
                window_id, desktop, host, title = parts
                if desktop != '-1':  # Skip sticky windows
                    windows.append({'id': window_id, 'title': title})

        # Add buttons for windows (limit to 6)
        for window in windows[:6]:
            btn = self.create_window_button(window['title'], window['id'])
            
            # Set appropriate style based on active window
            if window['id'] == active_window_id:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.BLUE}, 
                            stop:1 {TokyoNight.PURPLE});
                        color: {TokyoNight.BACKGROUND};
                        border: none;
                        border-radius: 6px;
                        font-weight: bold;
                    }}
                    QPushButton:hover {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.CYAN}, 
                            stop:1 {TokyoNight.BLUE});
                    }}
                """)
            else:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.SELECTION}, 
                            stop:1 {TokyoNight.NIGHT_BOTTOM});
                        color: {TokyoNight.FOREGROUND};
                        border: none;
                        border-radius: 6px;
                    }}
                    QPushButton:hover {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.BLUE}40, 
                            stop:1 {TokyoNight.PURPLE}40);
                    }}
                """)
            
            # Add context menu support
            btn.setContextMenuPolicy(Qt.CustomContextMenu)
            btn.customContextMenuRequested.connect(self.show_window_menu)
            self.taskbar_layout.addWidget(btn)

        # Update the taskbar widget size to ensure proper scrolling
        self.taskbar_widget.adjustSize()

    def show_window_menu_at_position(self, position, window_id):
        """Show window context menu at specified position"""
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 6px;
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 16px;
                border-radius: 4px;
                font-family: "JetBrains Mono Nerd Font";
            }}
            QMenu::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
        """)
        
        # Window actions
        actions = [
            ("Û∞ñ© Focus", self.focus_window_simple),
            ("Û∞îÅ Restore", self.restore_window),
            ("Û∞ñ∞ Maximize", self.maximize_window),
            ("Û∞ñØ Minimize", self.minimize_window),
            ("Û∞ñ™ Close", self.close_window),
            ("Û∞íì Move", self.move_window),
            ("Û∞ç∫ Always on Top", self.set_always_on_top),
            ("Û∞Ç∏ Unstick", self.unstick_window),
            ("Û∞òö Always Below", self.set_always_below),
            ("Û∞Ç∏ Pin to Workspace", self.pin_to_workspace),
            ("Û∞Çä Move to Workspace", self.move_to_workspace),
            ("Û∞îÅ Send to Workspace", self.send_to_workspace)
        ]
        
        for name, callback in actions:
            action = QAction(name, self)
            action.triggered.connect(lambda checked, func=callback: func(window_id))
            menu.addAction(action)
            
        menu.exec_(position)

    def focus_window(self, window_id):
        """Focus a window by ID (for context menu calls)"""
        self.focus_window_simple(window_id)

    def maximize_window(self, window_id):
        """Maximize a window by ID"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b add,maximized_vert,maximized_horz", shell=True)
        except Exception as e:
            print(f"Maximize error: {e}")

    def close_window(self, window_id):
        """Close a window by ID"""
        try:
            subprocess.run(f"wmctrl -i -c {window_id}", shell=True)
        except Exception as e:
            print(f"Close error: {e}")

    def move_window(self, window_id):
        """Move a window by ID"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b add,move", shell=True)
        except Exception as e:
            print(f"Move error: {e}")

    def set_always_on_top(self, window_id):
        """Set window to always on top"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b add,above", shell=True)
        except Exception as e:
            print(f"Always on top error: {e}")

    def unstick_window(self, window_id):
        """Unstick a window by ID"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b remove,sticky", shell=True)
        except Exception as e:
            print(f"Unstick error: {e}")

    def set_always_below(self, window_id):
        """Set window to always below"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b add,below", shell=True)
        except Exception as e:
            print(f"Always below error: {e}")

    def pin_to_workspace(self, window_id):
        """Pin window to current workspace"""
        try:
            current_workspace = self.current_workspace
            subprocess.run(f"wmctrl -i -r {window_id} -b add,sticky", shell=True)
        except Exception as e:
            print(f"Pin to workspace error: {e}")

    def move_to_workspace(self, window_id):
        """Move window to a specific workspace"""
        try:
            # Get current workspace
            current_workspace = self.current_workspace
            # Show dialog to select workspace
            workspace_id, ok = QInputDialog.getInt(
                self, "Move to Workspace",
                f"Enter workspace number (0-{current_workspace + 10}):",
                current_workspace,
                0, current_workspace + 10
            )
            if ok:
                subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
        except Exception as e:
            print(f"Move to workspace error: {e}")

    def send_to_workspace(self, window_id):
        """Send window to a specific workspace"""
        try:
            # Get current workspace
            current_workspace = self.current_workspace
            # Show dialog to select workspace
            workspace_id, ok = QInputDialog.getInt(
                self, "Send to Workspace",
                f"Enter workspace number (0-{current_workspace + 10}):",
                current_workspace,
                0, current_workspace + 10
            )
            if ok:
                subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
        except Exception as e:
            print(f"Send to workspace error: {e}")

    def show_window_menu(self, position):
        """Show context menu for window button"""
        btn = self.sender()
        window_id = btn.property('window_id')
        if window_id:
            self.show_window_menu_at_position(btn.mapToGlobal(position), window_id)

    def update_windows(self):
        """Update window list"""
        try:
            result = subprocess.run("wmctrl -l", shell=True, capture_output=True, text=True)
            if result.returncode == 0:
                self.update_taskbar(result.stdout)
        except Exception as e:
            print(f"Window update error: {e}")

    def quick_signal_check(self):
        """Quick command to check detailed signal information"""
        try:
            print("=== Network Signal Information ===")
            
            # WiFi information
            wifi_result = subprocess.run(
                "iwgetid --raw 2>/dev/null", 
                shell=True, capture_output=True, text=True
            )
            
            if wifi_result.returncode == 0 and wifi_result.stdout.strip():
                ssid = wifi_result.stdout.strip()
                print(f"Connected to: {ssid}")
                
                # Get detailed signal information
                signal_result = subprocess.run(
                    "iwconfig 2>/dev/null | grep -E 'ESSID|Signal level|Link Quality'",
                    shell=True, capture_output=True, text=True
                )
                if signal_result.returncode == 0:
                    print("Signal details:")
                    print(signal_result.stdout)
                
                # Get network interface statistics
                stats_result = subprocess.run(
                    "cat /proc/net/wireless 2>/dev/null | tail -1",
                    shell=True, capture_output=True, text=True
                )
                if stats_result.returncode == 0:
                    print(f"Interface stats: {stats_result.stdout.strip()}")
            else:
                # Check Ethernet
                ethernet_result = subprocess.run(
                    "ip route show default 2>/dev/null | head -1",
                    shell=True, capture_output=True, text=True
                )
                if ethernet_result.returncode == 0:
                    print("Wired Ethernet connection detected")
                    print(f"Route: {ethernet_result.stdout.strip()}")
                else:
                    print("No network connection detected")
                    
        except Exception as e:
            print(f"Signal check error: {e}")


# In TokyoNightPanelBar class, add these methods:

    def setup_enhanced_network_widget(self, layout):
        """Setup enhanced network widget in the panel"""
        if self.config.show_network:
            self.enhanced_network = EnhancedNetworkWidget(self)
            self.enhanced_network.setMaximumWidth(200)
            layout.addWidget(self.enhanced_network)

    def replace_network_display(self):
        """Replace old network display with enhanced version"""
        # This method should be called during UI setup to replace the old network label
        if hasattr(self, 'network_label'):
            # Find and remove the old network label
            for i in reversed(range(self.right_widget.layout().count())):
                widget = self.right_widget.layout().itemAt(i).widget()
                if widget == self.network_label:
                    self.right_widget.layout().removeWidget(widget)
                    widget.deleteLater()
                    break
        
        # Add enhanced network widget
        self.setup_enhanced_network_widget(self.right_widget.layout())











    # ... include all your other existing methods (setup_ui, load_applications, etc.)

    def setup_ui(self):
        """Setup the main panel UI with enhanced dark night theme"""
        # Window configuration
        self.setWindowTitle("Tokyo Night Panel")
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint | Qt.Tool)
        # Set opacity
        self.setWindowOpacity(self.config.opacity)
        # Apply stylesheet
        self.setStyleSheet(self.get_stylesheet())
        # Central widget with night sky background
        central_widget = NightSkyWidget()
        central_widget.setObjectName("centralwidget")
        self.setCentralWidget(central_widget)
        # === NEW LAYOUT STRUCTURE FOR FULL WIDTH ===
        # Main layout - ensure it expands fully
        layout = QHBoxLayout(central_widget)
        layout.setContentsMargins(0, 0, 0, 0)  # Remove margins for full width
        layout.setSpacing(0)  # Remove spacing
        # Left section - allow it to expand
        self.left_widget = QWidget()
        left_layout = QHBoxLayout(self.left_widget)
        left_layout.setContentsMargins(10, 5, 10, 5)  # Keep some internal padding
        left_layout.setSpacing(6)
        # Applications menu button
        self.apps_button = QToolButton()
        self.apps_button.setText("Û∞Äª")  # nf-linux-arch icon
        self.apps_button.setToolButtonStyle(Qt.ToolButtonIconOnly)
        self.apps_button.setPopupMode(QToolButton.InstantPopup)
        self.apps_button.setMenu(self.create_applications_menu())
        self.apps_button.setFixedSize(32, 32)
        left_layout.addWidget(self.apps_button)
        # Separator
        sep1 = QFrame()
        sep1.setFrameShape(QFrame.VLine)
        sep1.setFrameShadow(QFrame.Sunken)
        left_layout.addWidget(sep1)
        # Workspace switcher
        if self.config.show_workspace_switcher:
            self.setup_workspace_switcher(left_layout)
            sep_ws = QFrame()
            sep_ws.setFrameShape(QFrame.VLine)
            sep_ws.setFrameShadow(QFrame.Sunken)
            left_layout.addWidget(sep_ws)
        # XFCE Launchers area
        self.xfce_launchers_widget = QWidget()
        self.xfce_launchers_layout = QHBoxLayout(self.xfce_launchers_widget)
        self.xfce_launchers_layout.setContentsMargins(0, 0, 0, 0)
        self.xfce_launchers_layout.setSpacing(4)
        self.xfce_launchers_widget.setVisible(self.config.show_xfce_launchers)
        left_layout.addWidget(self.xfce_launchers_widget)
        # Separator
        sep2 = QFrame()
        sep2.setFrameShape(QFrame.VLine)
        sep2.setFrameShadow(QFrame.Sunken)
        sep2.setVisible(self.config.show_xfce_launchers)
        left_layout.addWidget(sep2)
        # === FIXED TASKBAR SECTION - NOW EXPANDS PROPERLY ===
        # Taskbar area with scroll support - NOW EXPANDS TO FILL AVAILABLE SPACE
        self.taskbar_container = QWidget()
        self.taskbar_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)  # Changed to Expanding
        taskbar_container_layout = QHBoxLayout(self.taskbar_container)
        taskbar_container_layout.setContentsMargins(0, 0, 0, 0)
        taskbar_container_layout.setSpacing(0)
        # Create scroll area for taskbar
        self.taskbar_scroll = QScrollArea()
        self.taskbar_scroll.setWidgetResizable(True)
        self.taskbar_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.taskbar_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.taskbar_scroll.setFrameShape(QFrame.NoFrame)
        self.taskbar_scroll.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)  # Added expanding policy
        self.taskbar_scroll.setStyleSheet(f"""
            QScrollArea {{
                background: transparent;
                border: none;
            }}
            QScrollBar:horizontal {{
                background: {TokyoNight.SELECTION};
                height: 6px;
                border-radius: 3px;
            }}
            QScrollBar::handle:horizontal {{
                background: {TokyoNight.BLUE};
                border-radius: 3px;
                min-width: 20px;
            }}
            QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {{
                border: none;
                background: none;
            }}
        """)
        # Create taskbar widget
        self.taskbar_widget = QWidget()
        self.taskbar_widget.setStyleSheet(f"background: transparent;")
        self.taskbar_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)  # Added expanding policy
        self.taskbar_layout = QHBoxLayout(self.taskbar_widget)
        self.taskbar_layout.setContentsMargins(0, 0, 0, 0)
        self.taskbar_layout.setSpacing(4)
        self.taskbar_layout.setAlignment(Qt.AlignLeft)
        # Set the taskbar widget as the scroll area's widget
        self.taskbar_scroll.setWidget(self.taskbar_widget)
        taskbar_container_layout.addWidget(self.taskbar_scroll)
        # Add taskbar container to left layout WITH STRETCH FACTOR
        left_layout.addWidget(self.taskbar_container, 1)  # This makes it expand
        # Center section - fixed width
        self.center_widget = QWidget()
        center_layout = QVBoxLayout(self.center_widget)
        center_layout.setContentsMargins(15, 0, 15, 0)
        center_layout.setSpacing(0)
        self.clock_label = QLabel("00:00")
        self.clock_label.setAlignment(Qt.AlignCenter)
        self.clock_label.setStyleSheet(f"""
            font-size: {self.config.clock_font_size}pt;
            color: {self.config.clock_color};
            background: transparent;
            font-weight: {self.config.clock_font_weight};
            text-shadow: 0px 0px 5px {self.config.clock_color}40;
        """)
        # --- FIXED: Connect ONLY to left-click ---
        self.clock_label.mousePressEvent = self.show_calendar
        # --- END FIX ---
        
        self.date_label = QLabel("Mon Jan 1")
        self.date_label.setAlignment(Qt.AlignCenter)
        self.date_label.setVisible(self.config.show_date)
        # Apply initial styles
        self.update_clock_styles()
        center_layout.addWidget(self.clock_label)
        center_layout.addWidget(self.date_label)
        # Right section - fixed width
        self.right_widget = QWidget()
        right_layout = QHBoxLayout(self.right_widget)
        right_layout.setContentsMargins(0, 0, 10, 0)  # Right margin only
        right_layout.setSpacing(8)
        # Notification center
        if self.config.show_notifications:
            self.setup_notification_center(right_layout)
        # Weather widget
        if self.config.show_weather:
            self.setup_weather_widget(right_layout)
        # System monitors
        self.cpu_label = QLabel("Û∞çõ 0%")
        self.mem_label = QLabel("Û∞òö 0%")
        # Apply styling to labels
        for label in [self.cpu_label, self.mem_label]:
            label.setStyleSheet(f"""
                padding: 4px 8px;
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                border-radius: 6px;
                font-size: 9pt;
                color: {TokyoNight.FOREGROUND};
            """)
        right_layout.addWidget(self.cpu_label)
        right_layout.addWidget(self.mem_label)
        
        # Brightness and Volume container (NEW - for collapsible controls)
        self.controls_container = QWidget()
        self.controls_layout = QHBoxLayout(self.controls_container)
        self.controls_layout.setContentsMargins(0, 0, 0, 0)
        self.controls_layout.setSpacing(8)
        
        # Brightness control
        if self.config.show_brightness_control:
            self.setup_brightness_control(self.controls_layout)
        # Volume control widget
        if self.config.show_volume:
            self.volume_control = VolumeControlWidget(self)
            self.controls_layout.addWidget(self.volume_control)
        
        # Add controls container to right layout
        right_layout.addWidget(self.controls_container)
        
        # Collapsible toggle for controls (NEW) - ADD THIS BEFORE OTHER CONTROLS
        self.setup_collapsible_toggle_icons(right_layout)
        
        # Network Manager control
        if self.config.show_network_control:
            self.network_control = NetworkManagerWidget(self)
            right_layout.addWidget(self.network_control)
        # Bluetooth Manager control  
        if self.config.show_bluetooth_control:
            self.bluetooth_control = BluetoothManagerWidget(self)
            right_layout.addWidget(self.bluetooth_control)
        # NEW: Tiling control
        if self.config.show_tiling_control:
            self.tiling_control = TilingControlWidget(self)
            right_layout.addWidget(self.tiling_control)
        
        # === ENHANCED NETWORK WIDGET - REPLACES OLD NETWORK LABEL ===
        if self.config.show_network:
            self.enhanced_network = EnhancedNetworkWidget(self)
            self.enhanced_network.setMaximumWidth(200)  # Reasonable width limit
            right_layout.addWidget(self.enhanced_network)
        
        # Battery display (keep this as it's separate from network)
        if self.config.show_battery:
            self.battery_label = QLabel("Û∞Åπ 0%")
            self.battery_label.setStyleSheet(f"""
                padding: 4px 8px;
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                border-radius: 6px;
                font-size: 9pt;
                color: {TokyoNight.FOREGROUND};
            """)
            right_layout.addWidget(self.battery_label)
        
        # System tray area
        if self.config.show_tray:
            self.tray_widget = SystemTrayWidget(self)
            self.tray_widget.setMaximumWidth(200)
            right_layout.addWidget(self.tray_widget)
            # Separator before system menu
            sep3 = QFrame()
            sep3.setFrameShape(QFrame.VLine)
            sep3.setFrameShadow(QFrame.Sunken)
            right_layout.addWidget(sep3)
        # System menu button
        self.system_button = QToolButton()
        self.system_button.setText("Û∞ÄΩ")
        self.system_button.setToolButtonStyle(Qt.ToolButtonIconOnly)
        self.system_button.setPopupMode(QToolButton.InstantPopup)
        self.system_button.setMenu(self.create_system_menu())
        self.system_button.setFixedSize(32, 32)
        right_layout.addWidget(self.system_button)
        # Add all sections to main layout WITH PROPER STRETCH FACTORS
        layout.addWidget(self.left_widget, 1)  # Left section expands
        layout.addWidget(self.center_widget, 0)  # Center section fixed width
        layout.addWidget(self.right_widget, 0)  # Right section fixed width
        # Set initial geometry
        self.update_panel_geometry()




    def show_quick_settings_menu(self, position):
        """Show quick settings context menu for the settings button"""
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 6px;
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 16px;
                border-radius: 4px;
                font-family: "JetBrains Mono Nerd Font";
            }}
            QMenu::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
        """)
        
        # Position settings
        position_menu = QMenu("Û∞ñØ Position", self)
        position_menu.setStyleSheet(menu.styleSheet())
        
        top_action = QAction("Û∞ñù Top", self)
        top_action.setCheckable(True)
        top_action.setChecked(self.config.position == "top")
        top_action.triggered.connect(lambda: self.set_panel_position("top"))
        position_menu.addAction(top_action)
        
        bottom_action = QAction("Û∞ñî Bottom", self)
        bottom_action.setCheckable(True)
        bottom_action.setChecked(self.config.position == "bottom")
        bottom_action.triggered.connect(lambda: self.set_panel_position("bottom"))
        position_menu.addAction(bottom_action)
        
        menu.addMenu(position_menu)
        
        # Auto-hide toggle
        auto_hide_action = QAction("Û∞ñØ Auto-Hide", self)
        auto_hide_action.setCheckable(True)
        auto_hide_action.setChecked(self.config.auto_hide)
        auto_hide_action.triggered.connect(self.toggle_auto_hide)
        menu.addAction(auto_hide_action)
        
        menu.addSeparator()
        
        # Quick opacity adjustment
        opacity_menu = QMenu("Û∞óä Opacity", self)
        opacity_menu.setStyleSheet(menu.styleSheet())
        
        opacity_levels = [
            ("100%", 1.0),
            ("90%", 0.9),
            ("80%", 0.8),
            ("70%", 0.7),
            ("60%", 0.6)
        ]
        
        for name, value in opacity_levels:
            action = QAction(name, self)
            action.triggered.connect(lambda checked, v=value: self.set_panel_opacity(v))
            opacity_menu.addAction(action)
        
        menu.addMenu(opacity_menu)
        
        # Height adjustment
        height_action = QAction("Û∞ñä Adjust Height", self)
        height_action.triggered.connect(self.show_height_dialog)
        menu.addAction(height_action)
        
        menu.addSeparator()
        
        # Full settings
        full_settings_action = QAction("Û∞íì Full Settings", self)
        full_settings_action.triggered.connect(self.show_settings)
        menu.addAction(full_settings_action)
        
        menu.exec_(self.settings_button.mapToGlobal(position))

    def set_panel_opacity(self, opacity):
        """Set panel opacity quickly"""
        self.config.opacity = opacity
        self.setWindowOpacity(opacity)
        # Save config
        config_manager = ConfigManager()
        config_manager.save_config(self.config)

    def set_panel_position(self, position):
        """Set panel position quickly"""
        if position != self.config.position:
            self.config.position = position
            self.update_panel_geometry()
            # Save config
            config_manager = ConfigManager()
            config_manager.save_config(self.config)








    def setup_settings_button(self, layout):
        """Setup panel settings button"""
        self.settings_button = QToolButton()
        self.settings_button.setText("Û∞íì")  # Settings icon
        self.settings_button.setToolButtonStyle(Qt.ToolButtonIconOnly)
        self.settings_button.setFixedSize(32, 32)
        self.settings_button.setStyleSheet(f"""
            QToolButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                color: {TokyoNight.FOREGROUND};
                border: none;
                border-radius: 6px;
                font-size: 12pt;
            }}
            QToolButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}40, 
                    stop:1 {TokyoNight.PURPLE}40);
            }}
            QToolButton:pressed {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}60, 
                    stop:1 {TokyoNight.PURPLE}60);
            }}
        """)
        self.settings_button.setCursor(Qt.PointingHandCursor)
        self.settings_button.setToolTip("Panel Settings\nClick to open panel configuration")
        self.settings_button.clicked.connect(self.show_settings)
        
        # Add context menu for quick settings
        self.settings_button.setContextMenuPolicy(Qt.CustomContextMenu)
        self.settings_button.customContextMenuRequested.connect(self.show_quick_settings_menu)
        
        layout.addWidget(self.settings_button)








    def setup_collapsible_toggle_icons(self, layout):
        """
        Setup toggle icons with arrow indicators
        """
        try:
            # Collapse button with left arrow (hiding controls)
            self.collapsible_toggle_btn = QPushButton("‚Æú")  # Left arrow
            self.collapsible_toggle_btn.setFixedSize(28, 28)
            self.collapsible_toggle_btn.setStyleSheet(f"""
                QPushButton {{
                    background: {TokyoNight.SELECTION};
                    border: 1px solid {TokyoNight.NEBULA};
                    color: {TokyoNight.FOREGROUND};
                    font-size: 14px;
                    border-radius: 4px;
                    font-weight: bold;
                }}
                QPushButton:hover {{
                    background: {TokyoNight.BLUE}60;
                    color: {TokyoNight.CYAN};
                }}
            """)
            self.collapsible_toggle_btn.setToolTip("Hide controls")
            self.collapsible_toggle_btn.clicked.connect(self.toggle_controls)
            
            # Restore button with right arrow (showing controls)
            self.restore_controls_btn = QPushButton("‚Æû")  # Right arrow
            self.restore_controls_btn.setFixedSize(28, 28)
            self.restore_controls_btn.setStyleSheet(f"""
                QPushButton {{
                    background: {TokyoNight.GREEN};
                    border: 1px solid {TokyoNight.BRIGHT_GREEN};
                    color: {TokyoNight.BACKGROUND};
                    font-size: 14px;
                    border-radius: 4px;
                    font-weight: bold;
                }}
                QPushButton:hover {{
                    background: {TokyoNight.BRIGHT_GREEN};
                }}
            """)
            self.restore_controls_btn.setToolTip("Show controls")
            self.restore_controls_btn.clicked.connect(self.show_controls)
            self.restore_controls_btn.setVisible(False)
            
            layout.addWidget(self.collapsible_toggle_btn)
            layout.addWidget(self.restore_controls_btn)
            self.controls_collapsed = False
            
        except Exception as e:
            print(f"Error setting up collapsible toggle: {e}")



        
    def toggle_controls(self):
        """Toggle brightness and volume controls visibility"""
        try:
            if self.controls_collapsed:
                # Show controls
                self.show_controls()
            else:
                # Hide controls
                self.hide_controls()
                
            self.controls_collapsed = not self.controls_collapsed
            print(f"Controls {'hidden' if self.controls_collapsed else 'shown'}")
            
        except Exception as e:
            print(f"Error toggling controls: {e}")

    def hide_controls(self):
        """Hide brightness and volume controls and show restore button"""
        try:
            # Hide controls container
            self.controls_container.setVisible(False)
            
            # Hide the collapse button
            self.collapsible_toggle_btn.setVisible(False)
            
            # Show the restore button with green background
            self.restore_controls_btn.setVisible(True)
            self.restore_controls_btn.setText("üîä")
            self.restore_controls_btn.setToolTip("Show brightness and volume controls - CLICK ME!")
            
            print("üîá Controls hidden - GREEN restore button should be visible")
            
        except Exception as e:
            print(f"Error hiding controls: {e}")

    def show_controls(self):
        """Show brightness and volume controls and hide restore button"""
        try:
            # Show controls container
            self.controls_container.setVisible(True)
            
            # Show the collapse button
            self.collapsible_toggle_btn.setVisible(True)
            self.collapsible_toggle_btn.setText("üîá")
            self.collapsible_toggle_btn.setToolTip("Hide brightness and volume controls")
            
            # Hide the restore button
            self.restore_controls_btn.setVisible(False)
            
            print("üîä Controls shown - Collapse button visible")
            
        except Exception as e:
            print(f"Error showing controls: {e}")




    def cleanup(self):
        """Clean up all resources before exit"""
        print("üßπ Cleaning up panel resources...")
        
        # Stop all timers
        timers = [
            'clock_timer', 'window_timer', 'volume_timer', 
            'weather_timer', 'notification_timer', 'auto_hide_timer',
            'edge_detection_timer', 'health_timer', 'memory_check_timer',
            'monitor_timer', 'animation'
        ]
        
        for timer_name in timers:
            if hasattr(self, timer_name):
                timer = getattr(self, timer_name)
                if timer and hasattr(timer, 'stop'):
                    timer.stop()
                    print(f"‚èπÔ∏è  Stopped {timer_name}")
        
        # Stop monitor thread
        if hasattr(self, 'monitor_thread'):
            print("üõë Stopping monitor thread...")
            self.monitor_thread.stop()
            if not self.monitor_thread.wait(3000):  # Wait up to 3 seconds
                print("‚ö†Ô∏è  Monitor thread didn't stop gracefully, terminating...")
                self.monitor_thread.terminate()
                self.monitor_thread.wait(2000)
        
        # Clean up taskbar
        self.cleanup_taskbar()
        
        # Clean up tiling control
        if hasattr(self, 'tiling_control'):
            self.tiling_control.cleanup()
        
        # Clean up launchers
        self.cleanup_launchers()
        
        print("‚úÖ Panel cleanup completed")

    def cleanup_taskbar(self):
        """Clean up taskbar widgets"""
        if hasattr(self, 'taskbar_layout'):
            print("üßπ Cleaning up taskbar...")
            for i in reversed(range(self.taskbar_layout.count())):
                widget = self.taskbar_layout.itemAt(i).widget()
                if widget and hasattr(widget, 'is_window_button'):
                    widget.deleteLater()
            print(f"‚úÖ Taskbar cleaned up, remaining widgets: {self.taskbar_layout.count()}")

    def cleanup_launchers(self):
        """Clean up launcher widgets"""
        if hasattr(self, 'xfce_launchers_layout'):
            print("üßπ Cleaning up launchers...")
            for i in reversed(range(self.xfce_launchers_layout.count())):
                widget = self.xfce_launchers_layout.itemAt(i).widget()
                if widget:
                    widget.deleteLater()
            print(f"‚úÖ Launchers cleaned up, remaining widgets: {self.xfce_launchers_layout.count()}")

    def start_health_monitor(self):
        """Monitor panel health and restart if needed"""
        self.health_timer = QTimer()
        self.health_timer.timeout.connect(self.check_health)
        self.health_timer.start(30000)  # Check every 30 seconds
        print("‚ù§Ô∏è  Health monitor started")

    def check_health(self):
        """Check panel health and restart if memory usage too high"""
        try:
            import psutil
            process = psutil.Process()
            memory_mb = process.memory_info().rss / 1024 / 1024
            
            # Count active timers
            active_timers = 0
            timer_names = ['clock_timer', 'window_timer', 'volume_timer', 'weather_timer', 
                          'notification_timer', 'monitor_timer']
            for timer_name in timer_names:
                if hasattr(self, timer_name):
                    timer = getattr(self, timer_name)
                    if timer and hasattr(timer, 'isActive') and timer.isActive():
                        active_timers += 1
            
            print(f"üß† Panel health: {memory_mb:.1f}MB memory, {active_timers} active timers")
            
            # Restart if memory usage too high
            if memory_mb > 300:  # 300MB threshold
                print(f"üîÑ High memory usage ({memory_mb:.1f}MB), restarting panel...")
                self.restart_panel()
                
        except Exception as e:
            print(f"‚ö†Ô∏è  Health check error: {e}")

    def force_garbage_collection(self):
        """Force garbage collection to prevent memory leaks"""
        import gc
        collected = gc.collect()
        print(f"üóëÔ∏è  Garbage collection: {collected} objects collected")

    def restart_panel(self):
        """Restart the panel gracefully"""
        print("üîÑ Restarting panel...")
        self.cleanup()
        QTimer.singleShot(1000, lambda: subprocess.Popen([sys.executable] + sys.argv))
        QApplication.quit()

    def update_taskbar_memory_safe(self, wmctrl_output):
        """Memory-safe taskbar update"""
        # Track existing windows
        existing_windows = {}
        for i in range(self.taskbar_layout.count()):
            widget = self.taskbar_layout.itemAt(i).widget()
            if widget and hasattr(widget, 'is_window_button'):
                window_id = widget.property("window_id")
                if window_id:
                    existing_windows[window_id] = widget
        
        # Process current windows
        current_windows = []
        for line in wmctrl_output.splitlines():
            parts = line.split(None, 3)
            if len(parts) >= 4:
                window_id, desktop, host, title = parts
                if desktop != '-1':  # Skip sticky windows
                    current_windows.append({'id': window_id, 'title': title})
        
        current_window_ids = {w['id'] for w in current_windows}
        
        # Remove windows that no longer exist
        for window_id, button in existing_windows.items():
            if window_id not in current_window_ids:
                button.deleteLater()
                print(f"üóëÔ∏è  Removed window button: {window_id}")
        
        # Add new windows (limit to 8 for memory safety)
        for window in current_windows[:8]:
            if window['id'] not in existing_windows:
                self.add_window_button(window)
        
        # Force garbage collection occasionally
        if hasattr(self, '_gc_counter'):
            self._gc_counter += 1
            if self._gc_counter >= 10:  # Every 10 updates
                self.force_garbage_collection()
                self._gc_counter = 0
        else:
            self._gc_counter = 0

    def add_window_button(self, window):
        """Add a single window button safely"""
        btn = QPushButton(window['title'][:18])
        btn.setFixedHeight(28)
        btn.is_window_button = True
        btn.setProperty("window_id", window['id'])
        
        btn.clicked.connect(lambda checked, wid=window['id']: self.focus_window(wid))
        
        # Style based on active window
        active_window = self.get_active_window()
        if window['id'] == active_window:
            btn.setStyleSheet(f"""
                QPushButton {{
                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                        stop:0 {TokyoNight.BLUE}, 
                        stop:1 {TokyoNight.PURPLE});
                    color: {TokyoNight.BACKGROUND};
                    border: none;
                    border-radius: 6px;
                    font-weight: bold;
                }}
                QPushButton:hover {{
                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                        stop:0 {TokyoNight.CYAN}, 
                        stop:1 {TokyoNight.BLUE});
                }}
            """)
        else:
            btn.setStyleSheet(f"""
                QPushButton {{
                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                        stop:0 {TokyoNight.SELECTION}, 
                        stop:1 {TokyoNight.NIGHT_BOTTOM});
                    color: {TokyoNight.FOREGROUND};
                    border: none;
                    border-radius: 6px;
                }}
                QPushButton:hover {{
                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                        stop:0 {TokyoNight.BLUE}40, 
                        stop:1 {TokyoNight.PURPLE}40);
                }}
            """)
        
        btn.setContextMenuPolicy(Qt.CustomContextMenu)
        btn.customContextMenuRequested.connect(self.show_window_menu)
        self.taskbar_layout.addWidget(btn)



























        
    def refresh_taskbar(self):
        """Force refresh the taskbar display"""
        self.update_windows()



    def get_active_window(self):
        """Get the ID of the currently active window"""
        try:
            # Method 1: xdotool (most reliable for active window)
            result = subprocess.run(
                ["xdotool", "getactivewindow"],
                capture_output=True, text=True, timeout=2
            )
            if result.returncode == 0 and result.stdout.strip():
                return result.stdout.strip()
                
            # Method 2: wmctrl fallback
            result = subprocess.run(
                "wmctrl -l | grep ' -1 ' | head -1 | cut -d' ' -f1",
                shell=True, capture_output=True, text=True, timeout=1
            )
            if result.returncode == 0 and result.stdout.strip():
                return result.stdout.strip()
                
        except Exception as e:
            print(f"Error getting active window: {e}")
        
        return ""













# Inside the TokyoNightPanelBar class definition:

    def toggle_tiling(self):
        """Toggle window tiling using the control widget."""
        if hasattr(self, 'tiling_control'):
            # Delegate to the control widget which uses the adapter
            self.tiling_control.toggle_tiling()

    def set_tiling_layout(self, layout_name):
        """Set specific tiling layout using the control widget."""
        if hasattr(self, 'tiling_control'):
            # Delegate to the control widget which uses the adapter
            self.tiling_control.set_layout(layout_name)

    def cycle_tiling_layout(self):
        """Cycle to next tiling layout"""
        # This needs to be implemented within the adapter or control widget
        # For now, let's assume it cycles internally or add a method to the adapter
        print("Cycling tiling layout is not directly implemented in the adapter example.")
        # You might need to implement this logic in CortileAdapter if cortile supports it
        # Example: self.tiling_control.cycle_layout() if added to TilingControlWidget

    def set_tiling_master(self):
        """Set currently focused window as master"""
        # This functionality might not be directly available in cortile
        # or might require specific interaction. Placeholder.
        print("Setting master window is not implemented in the CortileAdapter example.")
        # Example: self.tiling_control.set_master() if added to TilingControlWidget

    def force_apply_tiling(self):
        """Force apply tiling layout using the control widget."""
        if hasattr(self, 'tiling_control'):
            # Delegate to the control widget which uses the adapter
            self.tiling_control.force_apply_layout()

    def toggle_auto_tile(self):
        """Toggle auto-tiling using the control widget."""
        if hasattr(self, 'tiling_control'):
            # Delegate to the control widget which uses the adapter
            self.tiling_control.toggle_auto_tile()
            # Update the display in the control widget
            self.tiling_control.update_display()

    def refresh_layout(self):
        """Refresh the current layout to fix alignment issues"""
        # This might be a feature of cortile or a manual re-apply
        self.force_apply_tiling()

    def correct_alignment(self):
        """Correct alignment for all windows"""
        # This might be a feature of cortile or a manual re-apply
        self.force_apply_tiling()

    def restart_tiler(self):
        """Restart the tiler"""
        if hasattr(self, 'tiling_control'):
            print("üîÑ Restarting window tiler")
            # Don't try to set properties directly - use the toggle methods instead
            if self.tiling_control.tiler.is_active:
                self.tiling_control.tiler.toggle_tiling()  # Turn off
                import time
                time.sleep(0.5)
                self.tiling_control.tiler.toggle_tiling()  # Turn back on
            else:
                self.tiling_control.tiler.toggle_tiling()  # Just turn on
            
            # Enable auto-tile
            if not self.tiling_control.tiler.auto_tile:
                self.tiling_control.tiler.toggle_auto_tile()
            
            self.tiling_control.force_apply_layout()

    def cleanup(self):
        """Clean up all resources before exit"""
        print("üßπ Cleaning up panel resources...")
        # Stop all timers
        timers = [
            'clock_timer', 'window_timer', 'volume_timer',
            'weather_timer', 'notification_timer', 'auto_hide_timer',
            'edge_detection_timer', 'health_timer', 'memory_check_timer',
            'monitor_timer', 'animation'
        ]
        for timer_name in timers:
            if hasattr(self, timer_name):
                timer = getattr(self, timer_name)
                if timer and hasattr(timer, 'stop'):
                    timer.stop()
                    print(f"‚èπÔ∏è  Stopped {timer_name}")
        # Stop monitor thread
        if hasattr(self, 'monitor_thread'):
            print("üõë Stopping monitor thread...")
            self.monitor_thread.stop()
            if not self.monitor_thread.wait(3000):  # Wait up to 3 seconds
                print("‚ö†Ô∏è  Monitor thread didn't stop gracefully, terminating...")
                self.monitor_thread.terminate()
                self.monitor_thread.wait(2000)
        # Clean up taskbar
        self.cleanup_taskbar()
        # Clean up tiling control - ensure it calls the adapter's cleanup
        if hasattr(self, 'tiling_control'):
            self.tiling_control.cleanup() # This will call self.tiler.cleanup()
        # Clean up launchers
        self.cleanup_launchers()
        print("‚úÖ Panel cleanup completed")




    def show_calendar(self, event):
        """Show a calendar dialog when the clock is left-clicked."""
        from PyQt5.QtWidgets import QDialog, QCalendarWidget, QVBoxLayout, QLabel
        from PyQt5.QtCore import Qt, QDate
        
        # ONLY show calendar if left mouse button was pressed
        if event.button() != Qt.LeftButton:
            return  # Ignore right-clicks, middle-clicks, etc.
            
        # Create a dialog
        dialog = QDialog(self)
        dialog.setWindowTitle("Calendar")
        dialog.setFixedSize(300, 250)
        dialog.setStyleSheet(f"""
            QDialog {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border-radius: 8px;
                border: 1px solid {TokyoNight.NEBULA};
            }}
            QCalendarWidget {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 4px;
            }}
            QCalendarWidget QAbstractItemView:enabled {{
                selection-background-color: {TokyoNight.BLUE};
                selection-color: {TokyoNight.BACKGROUND};
            }}
            QCalendarWidget QToolButton {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                border: none;
                border-radius: 4px;
            }}
            QCalendarWidget QToolButton:hover {{
                background: {TokyoNight.BLUE}40;
            }}
        """)
        
        # Create a vertical layout
        layout = QVBoxLayout(dialog)
        
        # Create a calendar widget
        calendar = QCalendarWidget()
        # Optional: Set the current date as the selected date
        current_date = QDate.currentDate()
        calendar.setSelectedDate(current_date)
        calendar.setGridVisible(True)
        layout.addWidget(calendar)
        
        # Show the dialog
        dialog.exec_()







    def edit_custom_launchers(self):
        """Edit custom launchers in a dialog"""
        if not hasattr(self, 'custom_apps') or not self.custom_apps:
            QMessageBox.information(self, "No Launchers", "No custom launchers to edit.")
            return
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Edit Custom Launchers")
        dialog.setFixedSize(500, 400)
        dialog.setStyleSheet(f"""
            QDialog {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border-radius: 8px;
                border: 1px solid {TokyoNight.NEBULA};
            }}
            QListWidget {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 4px;
                padding: 5px;
            }}
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}, 
                    stop:1 {TokyoNight.PURPLE});
                color: {TokyoNight.BACKGROUND};
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.CYAN}, 
                    stop:1 {TokyoNight.BLUE});
            }}
        """)
        
        layout = QVBoxLayout(dialog)
        
        # List widget to display current launchers
        list_widget = QListWidget()
        for name, command, icon in self.custom_apps:
            item = QListWidgetItem(f"{name} ‚Üí {command}")
            list_widget.addItem(item)
        
        layout.addWidget(QLabel("Current Custom Launchers:"))
        layout.addWidget(list_widget)
        
        # Buttons layout
        buttons_layout = QHBoxLayout()
        
        add_btn = QPushButton("Û∞êï Add")
        add_btn.clicked.connect(lambda: self.add_from_edit_dialog(dialog))
        buttons_layout.addWidget(add_btn)
        
        remove_btn = QPushButton("Û∞Ü¥ Remove")
        remove_btn.clicked.connect(lambda: self.remove_launcher_from_list(list_widget))
        buttons_layout.addWidget(remove_btn)
        
        edit_btn = QPushButton("Û∞è´ Edit")
        edit_btn.clicked.connect(lambda: self.edit_launcher_in_list(list_widget))
        buttons_layout.addWidget(edit_btn)
        
        buttons_layout.addStretch()
        
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dialog.accept)
        buttons_layout.addWidget(close_btn)
        
        layout.addLayout(buttons_layout)
        dialog.exec_()




    def force_apply_tiling(self):
        """Force apply tiling layout"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.force_apply_layout()

    def toggle_auto_tile(self):
        """Toggle auto-tiling"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.tiler.toggle_auto_tile()
            self.tiling_control.update_display()




    def update_clock_styles(self):
        """Update clock and date styles based on configuration"""
        # Clock style
        clock_style = f"""
            font-size: {self.config.clock_font_size}pt;
            color: {self.config.clock_color};
            background: transparent;
        """
        if self.config.clock_font_weight == "bold":
            clock_style += "font-weight: bold;"
        elif self.config.clock_font_weight == "light":
            clock_style += "font-weight: 300;"
        
        # Add text shadow for better visibility
        clock_style += f"text-shadow: 0px 0px 5px {self.config.clock_color}40;"
        
        self.clock_label.setStyleSheet(clock_style)
        
        # Date style
        date_style = f"""
            font-size: {self.config.date_font_size}pt;
            color: {self.config.date_color};
            background: transparent;
            opacity: 0.9;
        """
        if self.config.date_font_weight == "bold":
            date_style += "font-weight: bold;"
        elif self.config.date_font_weight == "light":
            date_style += "font-weight: 300;"
        
        self.date_label.setStyleSheet(date_style)

    def update_clock(self):
        """Update clock display with customizable formatting"""
        now = datetime.now()
        
        try:
            # Format time
            if self.config.show_seconds:
                # If show_seconds is enabled, use format that includes seconds
                if "ss" not in self.config.time_format:
                    # Auto-add seconds to format if not present
                    time_format = self.config.time_format.replace("mm", "mm:ss")
                else:
                    time_format = self.config.time_format
            else:
                # Remove seconds from format if present
                time_format = self.config.time_format.replace(":ss", "").replace("ss", "")
            
            time_str = now.strftime(time_format)
            
            # Format date
            date_str = now.strftime(self.config.date_format)
            
            self.clock_label.setText(time_str)
            self.date_label.setText(date_str)
            
        except Exception as e:
            # Fallback to default formatting if custom format fails
            print(f"Clock format error: {e}, using defaults")
            time_str = now.strftime("%I:%M %p")
            date_str = now.strftime("%a %b %d")
            self.clock_label.setText(time_str)
            self.date_label.setText(date_str)

    # Add these quick setting methods to TokyoNightPanelBar class
    def set_clock_font_size(self, size):
        """Quick set clock font size"""
        self.config.clock_font_size = size
        self.update_clock_styles()
        self.save_config()

    def set_date_font_size(self, size):
        """Quick set date font size"""
        self.config.date_font_size = size
        self.update_clock_styles()
        self.save_config()

    def set_clock_color(self, color):
        """Quick set clock color"""
        self.config.clock_color = color
        self.update_clock_styles()
        self.save_config()

    def toggle_seconds(self):
        """Toggle seconds display"""
        self.config.show_seconds = not self.config.show_seconds
        self.update_clock_styles()
        self.save_config()

    def save_config(self):
        """Save configuration"""
        config_manager = ConfigManager()
        config_manager.save_config(self.config)





    def add_from_edit_dialog(self, parent_dialog):
        """Add launcher from edit dialog"""
        self.add_custom_launcher()
        parent_dialog.accept()
        self.edit_custom_launchers()  # Reopen to refresh list

    def remove_launcher_from_list(self, list_widget):
        """Remove selected launcher from list"""
        current_row = list_widget.currentRow()
        if current_row >= 0:
            self.custom_apps.pop(current_row)
            list_widget.takeItem(current_row)
            self.save_custom_launchers_to_config()
            self.update_applications_menu()

    def edit_launcher_in_list(self, list_widget):
        """Edit selected launcher"""
        current_row = list_widget.currentRow()
        if current_row >= 0:
            old_name, old_command, old_icon = self.custom_apps[current_row]
            
            new_name, ok = QInputDialog.getText(
                self, "Edit Launcher", 
                "Enter new name:",
                text=old_name
            )
            if ok and new_name:
                new_command, ok = QInputDialog.getText(
                    self, "Edit Launcher",
                    "Enter new command:",
                    text=old_command
                )
                if ok and new_command:
                    self.custom_apps[current_row] = (new_name, new_command, old_icon)
                    list_widget.currentItem().setText(f"{new_name} ‚Üí {new_command}")
                    self.save_custom_launchers_to_config()
                    self.update_applications_menu()

    def save_custom_launchers_to_config(self):
        """Save custom launchers to configuration"""
        if hasattr(self, 'custom_apps'):
            # Convert to the format expected by create_applications_menu
            self.config.custom_launchers = self.custom_apps
            config_manager = ConfigManager()
            config_manager.save_config(self.config)

    def update_applications_menu(self):
        """Update the applications menu with current custom launchers"""
        self.apps_button.setMenu(self.create_applications_menu())

    def add_custom_launcher(self):
        """Add a new custom launcher via dialog"""
        name, ok = QInputDialog.getText(
            self, "Add Custom Launcher", 
            "Enter launcher name:"
        )
        if ok and name:
            command, ok = QInputDialog.getText(
                self, "Add Custom Launcher",
                "Enter command to execute:"
            )
            if ok and command:
                # Initialize custom_apps if it doesn't exist
                if not hasattr(self, 'custom_apps'):
                    self.custom_apps = []
                
                # Add the new launcher
                self.custom_apps.append((name, command, ""))
                
                # Save to config and reload menu
                self.save_custom_launchers_to_config()
                self.update_applications_menu()
                
                QMessageBox.information(self, "Success", "Custom launcher added!")

    def eventFilter(self, obj, event):
        """Filter events to detect mouse movement for auto-hide"""
        if event.type() == QEvent.MouseMove and self.config.auto_hide:
            # Get the current mouse position
            mouse_pos = QCursor.pos()
            screen = QApplication.primaryScreen()
            screen_rect = screen.geometry()
            
            # Check if mouse is at the edge where panel is located
            at_edge = False
            
            if self.config.position == "top":
                if mouse_pos.y() <= self.config.edge_size:
                    at_edge = True
            else:  # bottom
                if mouse_pos.y() >= screen_rect.height() - self.config.edge_size:
                    at_edge = True
            
            # Show panel if mouse is at edge and show_on_edge is enabled
            if at_edge and self.config.show_on_edge and self.is_hidden:
                self.show_panel()
            
            # Reset auto-hide timer if mouse is over the panel
            if self.geometry().contains(mouse_pos) and not self.is_hidden:
                self.auto_hide_timer.stop()
                self.auto_hide_timer.start(self.config.auto_hide_delay)
        
        return super().eventFilter(obj, event)

    def check_mouse_position(self):
        """Check mouse position for edge detection"""
        if not self.config.auto_hide or not self.config.show_on_edge:
            return
            
        mouse_pos = QCursor.pos()
        screen = QApplication.primaryScreen()
        screen_rect = screen.geometry()
        
        # Check if mouse is at the edge where panel is located
        at_edge = False
        
        if self.config.position == "top":
            if mouse_pos.y() <= self.config.edge_size:
                at_edge = True
        else:  # bottom
            if mouse_pos.y() >= screen_rect.height() - self.config.edge_size:
                at_edge = True
        
        # Show panel if mouse is at edge and panel is hidden
        if at_edge and self.is_hidden:
            self.show_panel()

    def show_panel(self):
        """Show the panel with animation"""
        if self.is_hidden:
            self.is_hidden = False
            
            # Get the screen geometry
            screen = QApplication.primaryScreen()
            screen_rect = screen.geometry()
            
            # Create animation
            self.animation = QPropertyAnimation(self, b"geometry")
            self.animation.setDuration(200)
            self.animation.setEasingCurve(QEasingCurve.OutCubic)
            
            # Set start and end positions based on panel position
            if self.config.position == "top":
                start_pos = QRect(0, -self.config.height, screen_rect.width(), self.config.height)
                end_pos = QRect(0, 0, screen_rect.width(), self.config.height)
            else:  # bottom
                start_pos = QRect(0, screen_rect.height(), screen_rect.width(), self.config.height)
                end_pos = QRect(0, screen_rect.height() - self.config.height, screen_rect.width(), self.config.height)
            
            self.animation.setStartValue(start_pos)
            self.animation.setEndValue(end_pos)
            self.animation.start()
            
            # Show the panel
            self.show()
            
            # Reset auto-hide timer
            self.auto_hide_timer.stop()
            self.auto_hide_timer.start(self.config.auto_hide_delay)

    def hide_panel(self):
        """Hide the panel with animation"""
        if not self.is_hidden and self.config.auto_hide:
            self.is_hidden = True
            
            # Get the screen geometry
            screen = QApplication.primaryScreen()
            screen_rect = screen.geometry()
            
            # Create animation
            self.animation = QPropertyAnimation(self, b"geometry")
            self.animation.setDuration(200)
            self.animation.setEasingCurve(QEasingCurve.InCubic)
            
            # Set start and end positions based on panel position
            if self.config.position == "top":
                start_pos = QRect(0, 0, screen_rect.width(), self.config.height)
                end_pos = QRect(0, -self.config.height, screen_rect.width(), self.config.height)
            else:  # bottom
                start_pos = QRect(0, screen_rect.height() - self.config.height, screen_rect.width(), self.config.height)
                end_pos = QRect(0, screen_rect.height(), screen_rect.width(), self.config.height)
            
            self.animation.setStartValue(start_pos)
            self.animation.setEndValue(end_pos)
            self.animation.start()
            
            # Hide the panel after animation completes
            QTimer.singleShot(250, self.hide)

    def enterEvent(self, event):
        """Handle mouse enter event"""
        if self.config.auto_hide and self.is_hidden:
            self.show_panel()
        super().enterEvent(event)

    def leaveEvent(self, event):
        """Handle mouse leave event"""
        if self.config.auto_hide and not self.is_hidden:
            self.auto_hide_timer.stop()
            self.auto_hide_timer.start(self.config.auto_hide_delay)
        super().leaveEvent(event)

    def create_applications_menu(self):
        """Create applications menu with Nerd Font icons and workspace options"""
        menu = QMenu(self)
        menu.setStyleSheet(self.get_stylesheet())
        
        # === CUSTOM LAUNCHERS AT THE TOP ===
        # Load custom launchers from config or initialize
        if hasattr(self.config, 'custom_launchers') and self.config.custom_launchers:
            self.custom_apps = self.config.custom_launchers
        elif not hasattr(self, 'custom_apps'):
            # Initialize with default launchers if none exist
            self.custom_apps = [
                ("StormOS Launcher", "stormos-launcher", "Û∞Äª"),
                # Add more default launchers here if desired
            ]
        
        # Add custom launchers to menu
        if hasattr(self, 'custom_apps') and self.custom_apps:
            for name, command, icon in self.custom_apps:
                action = QAction(f"{icon} {name}", self)
                action.triggered.connect(lambda checked, cmd=command: self.launch_application(cmd))
                menu.addAction(action)
            
            menu.addSeparator()
        # === END CUSTOM LAUNCHERS ===
        
        # Rest of the method remains the same...
        # Common applications with Nerd Font icons (original apps below custom ones)
        apps = [
            ("Û∞Üç Terminal", self.config.terminal_command, "terminal"),
            ("Û∞âã File Manager", self.config.file_manager_command, "folder"),
            ("Û∞àπ Web Browser", self.config.browser_command, "browser"),
            ("Û∞à¨ Text Editor", self.config.text_editor_command, "text"),
            ("Û∞É§ Settings", self.config.settings_command, "settings"),
            ("Û∞éÅ Calculator", self.config.calculator_command, "calculator"),
            ("Û∞äì Screenshot", self.config.screenshot_command, "camera"),
            ("Û∞ª≠ Image Viewer", self.config.image_viewer_command, "image"),
            ("Û∞éÑ Music Player", self.config.music_player_command, "music", self.config.music_player_args),
        ]

        # Add workspace submenus for each app
        for name, command, icon, *args in apps:
            app_menu = QMenu(name, self)
            app_menu.setStyleSheet(menu.styleSheet())
            
            # Get workspace options
            workspaces = self.get_workspace_options()
            
            for ws_name, ws_id in workspaces:
                ws_action = QAction(ws_name, self)
                extra_args = args[0] if args else ""
                ws_action.triggered.connect(lambda checked, cmd=command, extra=extra_args, wid=ws_id: 
                                          self.launch_application(cmd, extra, wid))
                app_menu.addAction(ws_action)
            
            menu.addMenu(app_menu)

        menu.addSeparator()
        
        # Power menu (unchanged)
        power_menu = QMenu("Û∞ê• Power", self)
        power_menu.setStyleSheet(self.get_stylesheet())
        power_actions = [
            ("Û∞óΩ Log Out", "xfce4-session-logout"),
            ("Û∞úâ Reboot", "systemctl reboot"),
            ("Û∞ê• Shutdown", "systemctl poweroff"),
            ("Û∞í≤ Suspend", "systemctl suspend"),
        ]
        for name, command in power_actions:
            action = QAction(name, self)
            action.triggered.connect(lambda checked, cmd=command: self.execute_command(cmd))
            power_menu.addAction(action)
        menu.addMenu(power_menu)
        
        return menu
    
    def get_workspace_options(self):
        """Get workspace options for menu"""
        options = [("Current Workspace", -1)]
        try:
            result = subprocess.run("wmctrl -d", shell=True, capture_output=True, text=True)
            if result.returncode == 0:
                for i, line in enumerate(result.stdout.splitlines()):
                    parts = line.split()
                    if len(parts) >= 9:
                        name_parts = parts[8:]
                        ws_name = ' '.join(name_parts)
                        options.append((f"Workspace {i+1}: {ws_name}", i))
                    else:
                        options.append((f"Workspace {i+1}", i))
        except:
            # Fallback options
            for i in range(4):
                options.append((f"Workspace {i+1}", i))
        return options

    def create_system_menu(self):
        """Create system menu"""
        menu = QMenu(self)
        menu.setStyleSheet(self.get_stylesheet())
        # Volume control - now launches pavucontrol
        vol_action = QAction("Û∞ïæ Volume Control", self)
        vol_action.triggered.connect(self.launch_pavucontrol)
        menu.addAction(vol_action)
        # Network Manager action
        net_action = QAction("Û∞§® Network Manager", self)
        net_action.triggered.connect(self.launch_network_manager)
        menu.addAction(net_action)
        # Bluetooth Manager action
        bt_action = QAction("Û∞ÇØ Bluetooth Manager", self)
        bt_action.triggered.connect(self.launch_bluetooth_manager)
        menu.addAction(bt_action)
        menu.addSeparator()
        # System tools
        tools_actions = [
            ("Û∞çõ System Monitor", "gnome-system-monitor"),
            ("Û∞íì Settings", "xfce4-settings-manager"),
        ]
        for name, command in tools_actions:
            action = QAction(name, self)
            action.triggered.connect(lambda checked, cmd=command: self.launch_application(cmd))
            menu.addAction(action)
        menu.addSeparator()
        # Panel settings
        settings_action = QAction("Û∞íì Panel Settings", self)
        settings_action.triggered.connect(self.show_settings)
        menu.addAction(settings_action)
        return menu

    def show_settings(self):
        """Show settings dialog"""
        dialog = SettingsDialog(self.config, self)
        if dialog.exec_() == QDialog.Accepted:
            # Update panel configuration
            old_config = self.config
            self.config = dialog.config
            
            # Save configuration immediately
            config_manager = ConfigManager()
            config_manager.save_config(self.config)
            print("DEBUG: Settings saved immediately after dialog close")  # Debug line
            
            # Reload the panel with new settings
            self.setup_ui()
            self.load_xfce_launchers()  # This will reload both XFCE and custom launchers
            self.setup_strut()
            
            # Update applications menu with new commands
            self.apps_button.setMenu(self.create_applications_menu())
            
            # Update auto-hide settings
            if self.config.auto_hide:
                self.auto_hide_timer.start(self.config.auto_hide_delay)
            else:
                self.auto_hide_timer.stop()
                if self.is_hidden:
                    self.show_panel()

    def launch_pavucontrol(self):
        """Launch pavucontrol"""
        try:
            # Check if pavucontrol is already running
            result = subprocess.run(
                ["pgrep", "-f", "pavucontrol"],
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0:
                # If running, focus it
                subprocess.run(
                    ["wmctrl", "-a", "pavucontrol"],
                    shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
                )
            else:
                # Launch pavucontrol
                subprocess.Popen(
                    ["pavucontrol"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
        except Exception as e:
            print(f"Failed to launch pavucontrol: {e}")

    def launch_network_manager(self):
        """Launch network manager"""
        if hasattr(self, 'network_control'):
            self.network_control.launch_network_manager()
        else:
            # Fallback if widget not available
            try:
                subprocess.Popen(
                    ["nm-connection-editor"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
            except:
                subprocess.Popen(
                    ["nm-applet"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )

    def launch_bluetooth_manager(self):
        """Launch bluetooth manager"""
        if hasattr(self, 'bluetooth_control'):
            self.bluetooth_control.launch_bluetooth_manager()
        else:
            # Fallback if widget not available
            try:
                subprocess.Popen(
                    ["blueman-manager"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
            except:
                print("Bluetooth manager not available")

    def load_applications(self):
        """Load common applications"""
        self.applications = [
            Application("Web Browser", "firefox", "üåê"),
            Application("Text Editor", "mousepad", "üìù"),
            Application("Calculator", "gnome-calculator", "üßÆ"),
        ]

    def load_xfce_launchers(self):
        """Load XFCE panel launchers and custom launchers"""
        # Always load custom launchers first
        combined_launchers = []
        if self.config.launcher_customizations:
            combined_launchers.extend(self.config.launcher_customizations)
            print(f"DEBUG: Loaded {len(self.config.launcher_customizations)} custom launchers from config")  # Debug line

        # Then load XFCE launchers if the setting is enabled
        if self.config.show_xfce_launchers:
            try:
                reader = XfceLauncherReader()
                xfce_launchers = reader.get_xfce_launchers()
                combined_launchers.extend(xfce_launchers)
                print(f"DEBUG: Loaded {len(xfce_launchers)} XFCE launchers")  # Debug line
            except Exception as e:
                print(f"Error loading XFCE launchers: {e}")

        # Update the internal list
        self.xfce_launchers = combined_launchers
        # Update the display - always show if there are custom launchers
        should_show = self.config.show_xfce_launchers or bool(self.config.launcher_customizations)
        self.xfce_launchers_widget.setVisible(should_show)
        # Update the actual buttons displayed in the widget
        self.update_xfce_launchers_display()

    def update_xfce_launchers_display(self):
        """Update the XFCE launchers display - now handles system icons and workspace targeting."""
        # Clear existing launcher buttons
        for i in reversed(range(self.xfce_launchers_layout.count())):
            widget = self.xfce_launchers_layout.itemAt(i).widget()
            if widget:
                widget.deleteLater()
        
        # Add launcher buttons for the combined list
        for launcher in self.xfce_launchers: # Uses the combined list from load_xfce_launchers
            btn = QToolButton()
            
            # Set tooltip with workspace info
            workspace_info = "Current workspace" if launcher.workspace == -1 else f"Workspace {launcher.workspace + 1}"
            btn.setToolTip(f"{launcher.name}\nOpen in: {workspace_info}")
            
            btn.setFixedSize(32, 32)
            
            # Icon loading logic (existing code)
            icon_input = launcher.icon
            icon_set = False
            
            if icon_input and icon_input.startswith('/'):
                if os.path.isfile(icon_input):
                    try:
                        icon_from_file = QIcon(icon_input)
                        if not icon_from_file.isNull():
                            btn.setIcon(icon_from_file)
                            btn.setIconSize(QSize(24, 24))
                            icon_set = True
                    except:
                        pass

            if not icon_set and icon_input:
                system_icon = QIcon.fromTheme(icon_input)
                if not system_icon.isNull():
                    btn.setIcon(system_icon)
                    btn.setIconSize(QSize(24, 24))
                    icon_set = True

            if not icon_set:
                btn.setText(icon_input or "üöÄ")
            else:
                btn.setText("")
            
            # FIX: Connect with workspace parameter - THIS WAS MISSING
            btn.clicked.connect(lambda checked, cmd=launcher.command, args=launcher.args, ws=launcher.workspace: 
                               self.launch_application(cmd, args, ws))
            self.xfce_launchers_layout.addWidget(btn)
        
        print(f"Updated launcher display with {len(self.xfce_launchers)} buttons (XFCE + Custom)")

    def launch_application(self, command, args="", workspace=-1):
        """Launch an application with optional arguments and workspace targeting"""
        try:
            # Get current workspace
            current_workspace = self.current_workspace
            
            print(f"Launching: {command} with workspace target: {workspace} (current: {current_workspace})")
            
            # Build the command list properly
            cmd_list = command.split() if ' ' in command else [command]
            if args:
                cmd_list.extend(args.split())
            
            # Launch the application
            process = subprocess.Popen(cmd_list, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            
            # If workspace is specified and different from current, move the window
            if workspace >= 0 and workspace != current_workspace:
                print(f"Will move application to workspace {workspace}")
                
                # Use multiple methods to ensure window gets moved
                # Method 1: Try to move by PID after a delay
                QTimer.singleShot(1000, lambda: self.move_window_to_workspace(process.pid, workspace))
                
                # Method 2: Try to move by window title/class as backup
                app_name = os.path.basename(command.split()[0])  # Get app name from command
                QTimer.singleShot(2000, lambda: self.ensure_window_in_workspace(app_name, workspace))
                
            elif workspace >= 0:
                print(f"Application already on target workspace {workspace}")
                
        except Exception as e:
            print(f"Failed to launch {command}: {e}")

    def move_window_to_workspace(self, pid, workspace_id):
        """Move a window to a specific workspace by PID"""
        try:
            print(f"Attempting to move window with PID {pid} to workspace {workspace_id}")
            
            # Wait a bit more for the window to fully appear
            time.sleep(0.5)
            
            # Find window by PID and move it to target workspace
            result = subprocess.run(
                f"wmctrl -l -p | grep ' {pid} ' | head -1 | cut -d' ' -f1",
                shell=True, capture_output=True, text=True
            )
            
            if result.returncode == 0 and result.stdout.strip():
                window_id = result.stdout.strip()
                print(f"Found window {window_id} for PID {pid}, moving to workspace {workspace_id}")
                subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
                print(f"Window {window_id} moved to workspace {workspace_id}")
            else:
                print(f"No window found for PID {pid}, trying alternative methods")
                # Try alternative method
                self.move_recent_window_to_workspace(workspace_id)
                
        except Exception as e:
            print(f"Error moving window to workspace: {e}")

    def move_recent_window_to_workspace(self, workspace_id):
        """Move the most recent window to target workspace"""
        try:
            print(f"Moving most recent window to workspace {workspace_id}")
            
            # Get list of windows and move the most recent one
            result = subprocess.run("wmctrl -l | tail -1 | cut -d' ' -f1", 
                                  shell=True, capture_output=True, text=True)
            if result.returncode == 0 and result.stdout.strip():
                window_id = result.stdout.strip()
                print(f"Moving recent window {window_id} to workspace {workspace_id}")
                subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
                print(f"Recent window moved to workspace {workspace_id}")
        except Exception as e:
            print(f"Error moving recent window: {e}")

    def ensure_window_in_workspace(self, app_name, workspace_id):
        """Ensure the application window ends up in the target workspace"""
        try:
            print(f"Ensuring {app_name} window is in workspace {workspace_id}")
            
            # Try to find window by application name
            result = subprocess.run(
                f"wmctrl -l | grep -i '{app_name}' | tail -1 | cut -d' ' -f1",
                shell=True, capture_output=True, text=True
            )
            
            if result.returncode == 0 and result.stdout.strip():
                window_id = result.stdout.strip()
                print(f"Found {app_name} window {window_id}, moving to workspace {workspace_id}")
                subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
                print(f"{app_name} window moved to workspace {workspace_id}")
            else:
                print(f"No {app_name} window found, trying to move most recent window")
                # Move the most recent window as fallback
                self.move_recent_window_to_workspace(workspace_id)
                
        except Exception as e:
            print(f"Error ensuring window in workspace: {e}")

    def execute_command(self, command):
        """Execute a system command"""
        try:
            subprocess.Popen(command.split(), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except Exception as e:
            print(f"Failed to execute {command}: {e}")

    def setup_system_monitor(self):
        """Setup system monitoring thread"""
        self.monitor_thread = SystemMonitorThread()
        self.monitor_thread.cpu_updated.connect(self.update_cpu_display)
        self.monitor_thread.memory_updated.connect(self.update_memory_display)
        self.monitor_thread.battery_updated.connect(self.update_battery_display)
        self.monitor_thread.volume_updated.connect(self.update_volume_display)
        self.monitor_thread.network_updated.connect(self.update_network_display)
        self.monitor_thread.brightness_updated.connect(self.update_brightness_display)
        self.monitor_thread.workspace_updated.connect(self.update_workspace_display)
        self.monitor_thread.active_window_updated.connect(self.update_active_window)
        self.monitor_thread.start()

    def update_cpu_display(self, usage):
        """Update CPU display with color coding"""
        color = TokyoNight.GREEN if usage < 50 else TokyoNight.YELLOW if usage < 80 else TokyoNight.RED
        self.cpu_label.setText(f"Û∞çõ <font color='{color}'>{usage:.0f}%</font>")

    def update_memory_display(self, usage):
        """Update memory display with color coding"""
        color = TokyoNight.GREEN if usage < 60 else TokyoNight.YELLOW if usage < 85 else TokyoNight.RED
        self.mem_label.setText(f"Û∞òö <font color='{color}'>{usage:.0f}%</font>")

    def update_battery_display(self, capacity, status, time_str):
        """Update battery display with dynamic icons and time information"""
        # Check if battery_label exists
        if not hasattr(self, 'battery_label'):
            return
        # Battery icons based on level
        battery_icons = ["Û∞Çé", "Û∞Å∫", "Û∞Åª", "Û∞Åº", "Û∞ÅΩ", "Û∞Åæ", "Û∞ÇÄ", "Û∞ÇÅ", "Û∞ÇÇ", "Û∞Åπ"]
        icon_index = min(len(battery_icons) - 1, capacity // 10)
        icon = battery_icons[icon_index]
        if status == "Charging":
            icon = "Û∞ÇÑ"  # Charging icon
        
        # Battery capacity color
        capacity_color = (TokyoNight.GREEN if capacity > 50
                         else TokyoNight.YELLOW if capacity > 20
                         else TokyoNight.RED)
        
        # Build display text with time information
        display_text = f"{icon} <font color='{capacity_color}'>{capacity}%</font>"
        
        # Add time information if available - CHANGED COLORS HERE
        if time_str:
            if status.lower() == "discharging":
                # Use yellow for discharging time to make it more visible
                display_text += f" <font color='{TokyoNight.YELLOW}'>({time_str})</font>"
            elif status.lower() == "charging":
                display_text += f" <font color='{TokyoNight.GREEN}'>({time_str})</font>"
            elif status.lower() == "full":
                display_text += f" <font color='{TokyoNight.GREEN}'>(Full)</font>"
        
        self.battery_label.setText(display_text)

    def update_volume_display(self, volume, muted):
        """Update volume display"""
        if hasattr(self, 'volume_control'):
            self.volume_control.update_volume_display(volume, muted)

    def update_network_display(self, ssid, status):
        """Update network display"""
        # Check if network_label exists
        if not hasattr(self, 'network_label'):
            return
        if status == "connected":
            icon = "Û∞ñ©" if ssid else "Û∞àÄ"  # WiFi vs Ethernet
            color = TokyoNight.GREEN
            text = ssid[:12] if ssid else "Ethernet"
        else:
            icon = "Û∞ñ™"
            color = TokyoNight.RED
            text = "Offline"
        self.network_label.setText(f"{icon} <font color='{color}'>{text}</font>")

    def update_brightness_display(self, brightness):
        """Update brightness slider position"""
        if hasattr(self, 'brightness_slider'):
            self.brightness_slider.blockSignals(True)
            self.brightness_slider.setValue(brightness)
            self.brightness_slider.blockSignals(False)

    def update_clock(self):
        """Update clock display"""
        now = datetime.now()
        time_str = now.strftime("%I:%M %p")
        date_str = now.strftime("%a %b %d")
        self.clock_label.setText(time_str)
        self.date_label.setText(date_str)

    def update_windows(self):
        """Update window list"""
        try:
            result = subprocess.run("wmctrl -l", shell=True, capture_output=True, text=True)
            if result.returncode == 0:
                self.update_taskbar(result.stdout)
        except Exception as e:
            print(f"Window update error: {e}")

    def update_taskbar(self, wmctrl_output):
        """Update taskbar with current windows - check active window directly for highlighting."""
        # Get the *currently* active window ID right now using xdotool
        active_window_id = None
        try:
            result = subprocess.run(
                ["xdotool", "getactivewindow"],
                capture_output=True, text=True, timeout=2
            )
            if result.returncode == 0:
                active_window_id = result.stdout.strip()
        except Exception as e:
            print(f"Error getting active window with xdotool: {e}")
            # Fallback: try wmctrl
            try:
                result = subprocess.run(
                    ["wmctrl", "-l"],
                    capture_output=True, text=True, timeout=2
                )
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    for line in lines:
                        if ' -1 ' in line: # Look for the line containing -1 which indicates active
                            active_window_id = line.split()[0]
                            break
            except Exception as e2:
                print(f"Error getting active window with wmctrl: {e2}")

        print(f"DEBUG: Active window ID (for taskbar update): {active_window_id}") # Debug line

        # Clear existing window buttons
        for i in reversed(range(self.taskbar_layout.count())):
            widget = self.taskbar_layout.itemAt(i).widget()
            if widget and hasattr(widget, 'is_window_button'):
                widget.deleteLater()

        # Add new window buttons
        windows = []
        for line in wmctrl_output.splitlines():
            parts = line.split(None, 3)
            if len(parts) >= 4:
                window_id, desktop, host, title = parts
                if desktop != '-1':  # Skip sticky windows
                    windows.append({'id': window_id, 'title': title})

        # Add buttons for windows (limit to 6)
        for window in windows[:6]:
            btn = QPushButton(window['title'][:18])  # Truncate long titles
            btn.setFixedHeight(28)
            btn.is_window_button = True
            btn.setProperty("window_id", window['id'])
            
            # UPDATED: Connect to focus_window which now handles minimize/focus toggle
            btn.clicked.connect(lambda checked, wid=window['id']: self.focus_window(wid))
            
            # Check if this button's window ID matches the *currently* active window ID
            if window['id'] == active_window_id:
                # Apply the highlighted style for the active window
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.BLUE}, 
                            stop:1 {TokyoNight.PURPLE});
                        color: {TokyoNight.BACKGROUND};
                        border: none;
                        border-radius: 6px;
                        font-weight: bold;
                    }}
                    QPushButton:hover {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.CYAN}, 
                            stop:1 {TokyoNight.BLUE});
                    }}
                """)
            else:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.SELECTION}, 
                            stop:1 {TokyoNight.NIGHT_BOTTOM});
                        color: {TokyoNight.FOREGROUND};
                        border: none;
                        border-radius: 6px;
                    }}
                    QPushButton:hover {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.BLUE}40, 
                            stop:1 {TokyoNight.PURPLE}40);
                    }}
                """)
            # Add context menu support
            btn.setContextMenuPolicy(Qt.CustomContextMenu)
            btn.customContextMenuRequested.connect(self.show_window_menu)
            self.taskbar_layout.addWidget(btn)

        # Update the taskbar widget size to ensure proper scrolling
        self.taskbar_widget.adjustSize()
        
    def _toggle_blink_style(self):
        """Toggle the blink state for the active window button."""
        if not hasattr(self, '_blink_state'):
            self._blink_state = False
        self._blink_state = not self._blink_state
        # Force a refresh of the taskbar to apply the new style
        self.update_windows()



    def start_timers(self):
        """Start all timers for updating UI elements with memory safety"""
        # Clock timer
        self.clock_timer = QTimer()
        self.clock_timer.timeout.connect(self.update_clock)
        self.clock_timer.start(1000)
        
        # Window list timer - use memory-safe version
        self.window_timer = QTimer()
        self.window_timer.timeout.connect(self.update_windows_memory_safe)
        self.window_timer.start(1000)  # Reduced from 500ms to 1000ms
        
        # Initial updates
        self.update_clock()
        self.update_windows_memory_safe()

    def update_windows_memory_safe(self):
        """Memory-safe window update"""
        try:
            result = subprocess.run("wmctrl -l", shell=True, capture_output=True, text=True, timeout=2)
            if result.returncode == 0:
                self.update_taskbar_memory_safe(result.stdout)
        except Exception as e:
            print(f"Window update error: {e}")

    def show_window_menu(self, position):
        """Show context menu for window button"""
        btn = self.sender()
        window_id = btn.property('window_id')
        if window_id:
            self.show_window_menu_at_position(btn.mapToGlobal(position), window_id)

    def show_window_menu_at_position(self, position, window_id):
        """Show window context menu at specified position"""
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 6px;
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 16px;
                border-radius: 4px;
                font-family: "JetBrains Mono Nerd Font";
            }}
            QMenu::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
        """)
        # Window actions
        actions = [
            ("Û∞ñ© Focus", self.focus_window),
            ("Û∞ñ∞ Maximize", self.maximize_window),
            ("Û∞ñØ Minimize", self.minimize_window),
            ("Û∞ñ™ Close", self.close_window),
            ("Û∞íì Move", self.move_window),
            ("Û∞ç∫ Always on Top", self.set_always_on_top),
            ("Û∞Ç∏ Unstick", self.unstick_window),
            ("Û∞òö Always Below", self.set_always_below),
            ("Û∞Ç∏ Pin to Workspace", self.pin_to_workspace),
            ("Û∞Çä Move to Workspace", self.move_to_workspace),
            ("Û∞îÅ Send to Workspace", self.send_to_workspace)
        ]
        for name, callback in actions:
            action = QAction(name, self)
            action.triggered.connect(lambda checked, func=callback: func(window_id))
            menu.addAction(action)
        menu.exec_(position)

    def focus_window(self, window_id):
        """Focus a window by ID, or minimize if already focused"""
        try:
            # Get currently active window
            active_window = self.get_active_window()
            
            print(f"DEBUG: Active window: {active_window}, Clicked window: {window_id}")
            
            if active_window == window_id:
                # Window is already focused - minimize it
                print(f"ü™ü Minimizing focused window {window_id}")
                self.minimize_window(window_id)
            else:
                # Window is not focused - focus it
                print(f"üéØ Focusing window {window_id}")
                subprocess.run(f"wmctrl -i -a {window_id}", shell=True)
                
                # Also ensure it's not minimized
                subprocess.run(f"wmctrl -i -r {window_id} -b remove,hidden", shell=True)
        except Exception as e:
            print(f"Focus/minimize error: {e}")

    def minimize_window(self, window_id):
        """Minimize a window by ID using multiple methods"""
        try:
            # Method 1: wmctrl hidden state (primary)
            result1 = subprocess.run(
                f"wmctrl -i -r {window_id} -b add,hidden",
                shell=True, capture_output=True, text=True
            )
            
            # Method 2: xdotool windowminimize (fallback)
            result2 = subprocess.run(
                f"xdotool windowminimize {window_id}",
                shell=True, capture_output=True, text=True
            )
            
            if result1.returncode == 0 or result2.returncode == 0:
                print(f"‚úÖ Window {window_id} minimized")
            else:
                print(f"‚ö†Ô∏è  Could not minimize window {window_id}")
                
        except Exception as e:
            print(f"Minimize error: {e}")

    def maximize_window(self, window_id):
        """Maximize a window by ID"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b add,maximized_vert,maximized_horz", shell=True)
        except Exception as e:
            print(f"Maximize error: {e}")

    def close_window(self, window_id):
        """Close a window by ID"""
        try:
            subprocess.run(f"wmctrl -i -c {window_id}", shell=True)
        except Exception as e:
            print(f"Close error: {e}")

    def move_window(self, window_id):
        """Move a window by ID"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b add,move", shell=True)
        except Exception as e:
            print(f"Move error: {e}")

    def set_always_on_top(self, window_id):
        """Set window to always on top"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b add,above", shell=True)
        except Exception as e:
            print(f"Always on top error: {e}")

    def unstick_window(self, window_id):
        """Unstick a window by ID"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b remove,sticky", shell=True)
        except Exception as e:
            print(f"Unstick error: {e}")

    def set_always_below(self, window_id):
        """Set window to always below"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b add,below", shell=True)
        except Exception as e:
            print(f"Always below error: {e}")

    def pin_to_workspace(self, window_id):
        """Pin window to current workspace"""
        try:
            current_workspace = self.current_workspace
            subprocess.run(f"wmctrl -i -r {window_id} -b add,sticky", shell=True)
        except Exception as e:
            print(f"Pin to workspace error: {e}")

    def move_to_workspace(self, window_id):
        """Move window to a specific workspace"""
        try:
            # Get current workspace
            current_workspace = self.current_workspace
            # Show dialog to select workspace
            workspace_id, ok = QInputDialog.getInt(
                self, "Move to Workspace",
                f"Enter workspace number (0-{current_workspace + 10}):",
                current_workspace,
                0, current_workspace + 10
            )
            if ok:
                subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
        except Exception as e:
            print(f"Move to workspace error: {e}")

    def send_to_workspace(self, window_id):
        """Send window to a specific workspace"""
        try:
            # Get current workspace
            current_workspace = self.current_workspace
            # Show dialog to select workspace
            workspace_id, ok = QInputDialog.getInt(
                self, "Send to Workspace",
                f"Enter workspace number (0-{current_workspace + 10}):",
                current_workspace,
                0, current_workspace + 10
            )
            if ok:
                subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
        except Exception as e:
            print(f"Send to workspace error: {e}")

    def update_active_window(self, window_id):
        """Update the active window indicator"""
        self.active_window_id = window_id
        # Update taskbar to highlight active window
        self.update_windows()

    def reload_panel(self):
        """Reload the panel with current settings"""
        # Save current config
        config_manager = ConfigManager()
        config_manager.save_config(self.config)
        # Restart the application
        QApplication.quit()
        subprocess.Popen([sys.executable] + sys.argv)

    def quit_application(self):
        """Quit the application"""
        QApplication.quit()

    def setup_workspace_switcher(self, layout):
        """Setup workspace/desktop switcher"""
        self.workspace_widget = QWidget()
        workspace_layout = QHBoxLayout(self.workspace_widget)
        workspace_layout.setContentsMargins(0, 0, 0, 0)
        workspace_layout.setSpacing(2)
        # Get current workspace count
        try:
            result = subprocess.run("wmctrl -d", shell=True, capture_output=True, text=True)
            if result.returncode == 0:
                workspaces = result.stdout.splitlines()
                current_workspace = 0
                for i, line in enumerate(workspaces):
                    if "*" in line:
                        current_workspace = i
                        break
                # Create workspace buttons
                self.workspace_buttons = []
                for i in range(len(workspaces)):
                    btn = QPushButton(str(i+1))
                    btn.setFixedSize(28, 28)
                    btn.setProperty("workspace_id", i)
                    # Set initial style based on current workspace
                    if i == current_workspace:
                        btn.setStyleSheet(f"""
                            QPushButton {{
                                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.BLUE}, 
                                    stop:1 {TokyoNight.PURPLE});
                                color: {TokyoNight.BACKGROUND};
                                border: none;
                                border-radius: 6px;
                                font-weight: bold;
                                font-size: 10pt;
                            }}
                            QPushButton:hover {{
                                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.CYAN}, 
                                    stop:1 {TokyoNight.BLUE});
                            }}
                        """)
                    else:
                        btn.setStyleSheet(f"""
                            QPushButton {{
                                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.SELECTION}, 
                                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                                color: {TokyoNight.FOREGROUND};
                                border: none;
                                border-radius: 6px;
                                font-size: 10pt;
                            }}
                            QPushButton:hover {{
                                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.BLUE}40, 
                                    stop:1 {TokyoNight.PURPLE}40);
                            }}
                        """)
                    btn.clicked.connect(lambda checked, w=i: self.switch_workspace(w))
                    workspace_layout.addWidget(btn)
                    self.workspace_buttons.append(btn)
                # Store current workspace
                self.current_workspace = current_workspace
        except Exception as e:
            print(f"Error setting up workspaces: {e}")
        layout.addWidget(self.workspace_widget)

    def switch_workspace(self, workspace_id):
        """Switch to the specified workspace"""
        try:
            subprocess.run(f"wmctrl -s {workspace_id}", shell=True)
            # Update button styles
            for i, btn in enumerate(self.workspace_buttons):
                if i == workspace_id:
                    btn.setStyleSheet(f"""
                        QPushButton {{
                            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                stop:0 {TokyoNight.BLUE}, 
                                stop:1 {TokyoNight.PURPLE});
                            color: {TokyoNight.BACKGROUND};
                            border: none;
                            border-radius: 6px;
                            font-weight: bold;
                            font-size: 10pt;
                        }}
                        QPushButton:hover {{
                            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.CYAN}, 
                                    stop:1 {TokyoNight.BLUE});
                        }}
                    """)
                else:
                    btn.setStyleSheet(f"""
                        QPushButton {{
                            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.SELECTION}, 
                                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                                color: {TokyoNight.FOREGROUND};
                                border: none;
                                border-radius: 6px;
                                font-size: 10pt;
                            }}
                            QPushButton:hover {{
                                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.BLUE}40, 
                                    stop:1 {TokyoNight.PURPLE}40);
                            }}
                        """)
            # Update current workspace
            self.current_workspace = workspace_id
        except Exception as e:
            print(f"Error switching workspace: {e}")

    def update_workspace_display(self, workspace_id):
        """Update workspace display when workspace changes"""
        if hasattr(self, 'workspace_buttons') and workspace_id < len(self.workspace_buttons):
            # Update button styles
            for i, btn in enumerate(self.workspace_buttons):
                if i == workspace_id:
                    btn.setStyleSheet(f"""
                        QPushButton {{
                            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                stop:0 {TokyoNight.BLUE}, 
                                stop:1 {TokyoNight.PURPLE});
                            color: {TokyoNight.BACKGROUND};
                            border: none;
                            border-radius: 6px;
                            font-weight: bold;
                            font-size: 10pt;
                        }}
                        QPushButton:hover {{
                            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.CYAN}, 
                                    stop:1 {TokyoNight.BLUE});
                        }}
                    """)
                else:
                    btn.setStyleSheet(f"""
                        QPushButton {{
                            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.SELECTION}, 
                                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                                color: {TokyoNight.FOREGROUND};
                                border: none;
                                border-radius: 6px;
                                font-size: 10pt;
                            }}
                            QPushButton:hover {{
                                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.BLUE}40, 
                                    stop:1 {TokyoNight.PURPLE}40);
                            }}
                        """)
            # Update current workspace
            self.current_workspace = workspace_id

    def setup_brightness_control(self, layout):
        """Setup brightness control slider"""
        # Brightness icon
        brightness_icon = QLabel("Û∞É†")
        brightness_icon.setStyleSheet(f"color: {TokyoNight.YELLOW}; font-size: 12pt;")
        layout.addWidget(brightness_icon)
        # Brightness slider
        self.brightness_slider = QSlider(Qt.Horizontal)
        self.brightness_slider.setRange(10, 100)
        self.brightness_slider.setFixedWidth(80)
        self.brightness_slider.valueChanged.connect(self.set_brightness)
        layout.addWidget(self.brightness_slider)

    def set_brightness(self, value):
        """Set screen brightness"""
        try:
            subprocess.run(f"brightnessctl set {value}%", shell=True,
                          stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except Exception as e:
            print(f"Failed to set brightness: {e}")

    def setup_weather_widget(self, layout):
        """Setup weather widget"""
        self.weather_label = QLabel("Û∞ñê --¬∞C")
        self.weather_label.setStyleSheet(f"""
            padding: 4px 8px;
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 {TokyoNight.SELECTION}, 
                stop:1 {TokyoNight.NIGHT_BOTTOM});
            border-radius: 6px;
            font-size: 9pt;
            color: {TokyoNight.FOREGROUND};
        """)
        layout.addWidget(self.weather_label)
        # Start weather update timer (update every 30 minutes)
        self.weather_timer = QTimer()
        self.weather_timer.timeout.connect(self.update_weather)
        self.weather_timer.start(1800000)  # 30 minutes
        # Initial weather update
        self.update_weather()

    def update_weather(self):
        """Update weather information"""
        # Check if weather_label exists
        if not hasattr(self, 'weather_label'):
            return
        try:
            # Build location parameter
            location = self.config.weather_location if self.config.weather_location else ""
            if location:
                location_url = f"{location}"
            else:
                location_url = ""
            # Using wttr.in for weather data
            result = subprocess.run(
                f"curl -s 'wttr.in/{location_url}?format=%C+%t'",
                shell=True, capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0 and result.stdout.strip():
                weather_data = result.stdout.strip()
                # Format: "Condition +temp"
                parts = weather_data.split('+')
                if len(parts) == 2:
                    condition = parts[0].strip()
                    temp = parts[1].strip()
                    # Map weather conditions to icons
                    weather_icons = {
                        "Clear": "Û∞ñô", "Sunny": "Û∞ñô", "Partly cloudy": "Û∞ñï",
                        "Cloudy": "Û∞ñê", "Overcast": "Û∞ñê", "Fog": "Û∞ñë",
                        "Rain": "Û∞ñó", "Drizzle": "Û∞ñó", "Snow": "Û∞ñò",
                        "Thunderstorm": "Û∞ñì", "Mist": "Û∞ñë", "Patchy rain": "Û∞ñó",
                        "Light rain": "Û∞ñó", "Moderate rain": "Û∞ñó", "Heavy rain": "Û∞ñó"
                    }
                    icon = weather_icons.get(condition, "Û∞ñê")
                    self.weather_label.setText(f"{icon} {temp}")
            else:
                self.weather_label.setText("Û∞ñê --¬∞C")
        except Exception as e:
            print(f"Error updating weather: {e}")
            self.weather_label.setText("Û∞ñê --¬∞C")

    def setup_notification_center(self, layout):
        """Setup notification center"""
        self.notification_btn = QPushButton("Û∞Çö")
        self.notification_btn.setFixedSize(32, 32)
        self.notification_btn.clicked.connect(self.show_notifications)
        self.notification_btn.setStyleSheet(f"""
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                color: {TokyoNight.FOREGROUND};
                border: none;
                border-radius: 6px;
                font-size: 12pt;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}40, 
                    stop:1 {TokyoNight.PURPLE}40);
            }}
        """)
        layout.addWidget(self.notification_btn)
        # Track notification count
        self.update_notification_count()
        # Start notification monitoring
        self.notification_timer = QTimer()
        self.notification_timer.timeout.connect(self.update_notification_count)
        self.notification_timer.start(5000)  # Check every 5 seconds

    def update_notification_count(self):
        """Update notification count"""
        # Check if notification_btn exists
        if not hasattr(self, 'notification_btn'):
            return
        try:
            # Try different notification systems
            count = 0
            # Try dunst
            result = subprocess.run(
                "dunstctl count 2>/dev/null || echo 0",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0:
                # Parse the output to extract the waiting count
                output = result.stdout.strip()
                if output.isdigit():
                    count = int(output)
                else:
                    # Extract the waiting count from multi-line output
                    match = re.search(r'Waiting:\s+(\d+)', output)
                    if match:
                        count = int(match.group(1))
            else:
                # Try mako
                result = subprocess.run(
                    "makoctl list 2>/dev/null | grep -c 'app-name' || echo 0",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode == 0:
                    count = int(result.stdout.strip())
            if count > 0:
                self.notification_btn.setText(f"Û∞Çö {count}")
                self.notification_btn.setStyleSheet(f"""
                    QPushButton {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.BLUE}, 
                            stop:1 {TokyoNight.PURPLE});
                        color: {TokyoNight.BACKGROUND};
                        border: none;
                        border-radius: 6px;
                        font-size: 12pt;
                    }}
                    QPushButton:hover {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.CYAN}, 
                            stop:1 {TokyoNight.BLUE});
                    }}
                """)
            else:
                self.notification_btn.setText("Û∞Çö")
                self.notification_btn.setStyleSheet(f"""
                    QPushButton {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.SELECTION}, 
                            stop:1 {TokyoNight.NIGHT_BOTTOM});
                        color: {TokyoNight.FOREGROUND};
                        border: none;
                        border-radius: 6px;
                        font-size: 12pt;
                    }}
                    QPushButton:hover {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.BLUE}40, 
                            stop:1 {TokyoNight.PURPLE}40);
                    }}
                """)
        except Exception as e:
            print(f"Error updating notification count: {e}")

    def show_notifications(self):
        """Show notification history"""
        try:
            # Try dunst
            subprocess.run("dunstctl history-pop 2>/dev/null", shell=True)
        except:
            try:
                # Try mako
                subprocess.run("makoctl restore 2>/dev/null", shell=True)
            except:
                print("No supported notification system found")

    def get_stylesheet(self):
        """Return enhanced dark night themed stylesheet"""
        # Do not call TokyoNight.change_theme(self.config.theme_variant) here
        # as it does not exist as a class method on TokyoNight.
        # The theme should ideally be set correctly by ConfigManager.load_config
        # or PanelConfig.__post_init__ before this method is called.
        # Use getattr with fallbacks to prevent AttributeError if the theme
        # is somehow not initialized correctly at this point.

        corner_radius = f"{self.config.corner_radius}px" if self.config.rounded_corners else "0px"
        return f"""
            QMainWindow {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {getattr(TokyoNight, 'NIGHT_TOP', '#1a1b26')}CC, 
                    stop:0.7 {getattr(TokyoNight, 'NIGHT_BOTTOM', '#13141e')}CC,
                    stop:1 {getattr(TokyoNight, 'NIGHT_HIGHLIGHT', '#1f2335')}CC);
                border: 1px solid {getattr(TokyoNight, 'NEBULA', '#3a415e')}60;
                border-radius: {corner_radius};
            }}
            QWidget#centralwidget {{
                background: transparent;
                border-radius: {corner_radius};
            }}
            QToolButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {getattr(TokyoNight, 'SELECTION', '#292e42')}, 
                    stop:1 {getattr(TokyoNight, 'NIGHT_BOTTOM', '#13141e')});
                color: {getattr(TokyoNight, 'FOREGROUND', '#c0caf5')};
                border: none;
                border-radius: 6px;
                font-family: "JetBrains Mono Nerd Font";
            }}
            QToolButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {getattr(TokyoNight, 'BLUE', '#5a7fc7')}40, 
                    stop:1 {getattr(TokyoNight, 'PURPLE', '#9b7fc7')}40);
            }}
            QToolButton:pressed {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {getattr(TokyoNight, 'BLUE', '#5a7fc7')}60, 
                    stop:1 {getattr(TokyoNight, 'PURPLE', '#9b7fc7')}60);
            }}
            QMenu {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {getattr(TokyoNight, 'NIGHT_TOP', '#1a1b26')}, 
                    stop:0.7 {getattr(TokyoNight, 'NIGHT_BOTTOM', '#13141e')},
                    stop:1 {getattr(TokyoNight, 'NIGHT_HIGHLIGHT', '#1f2335')});
                color: {getattr(TokyoNight, 'FOREGROUND', '#c0caf5')};
                border: 1px solid {getattr(TokyoNight, 'NEBULA', '#3a415e')};
                border-radius: 6px;
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 16px;
                border-radius: 4px;
                font-family: "JetBrains Mono Nerd Font";
            }}
            QMenu::item:selected {{
                background: {getattr(TokyoNight, 'BLUE', '#5a7fc7')};
                color: {getattr(TokyoNight, 'BACKGROUND', '#0d0f1a')};
            }}
            QFrame[frameShape="4"] {{
                background: {getattr(TokyoNight, 'NEBULA', '#3a415e')}40;
                max-width: 1px;
            }}
            QSlider::groove:horizontal {{
                border: none;
                height: 4px;
                background: {getattr(TokyoNight, 'NEBULA', '#3a415e')};
                border-radius: 2px;
            }}
            QSlider::handle:horizontal {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {getattr(TokyoNight, 'BLUE', '#5a7fc7')}, 
                    stop:1 {getattr(TokyoNight, 'PURPLE', '#9b7fc7')});
                border: none;
                width: 12px;
                margin: -4px 0;
                border-radius: 6px;
            }}
            QSlider::handle:horizontal:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {getattr(TokyoNight, 'CYAN', '#5abfcf')}, 
                    stop:1 {getattr(TokyoNight, 'BLUE', '#5a7fc7')});
            }}
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {getattr(TokyoNight, 'BLUE', '#5a7fc7')}, 
                    stop:1 {getattr(TokyoNight, 'PURPLE', '#9b7fc7')});
                color: {getattr(TokyoNight, 'BACKGROUND', '#0d0f1a')};
                border: none;
                padding: 6px 12px;
                border-radius: 4px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {getattr(TokyoNight, 'CYAN', '#5abfcf')}, 
                    stop:1 {getattr(TokyoNight, 'BLUE', '#5a7fc7')});
            }}
            QFormLayout {{
                color: {getattr(TokyoNight, 'FOREGROUND', '#c0caf5')};
            }}
            QLabel {{
                color: {getattr(TokyoNight, 'FOREGROUND', '#c0caf5')};
            }}
        """

    def show_panel_context_menu(self, position):
        """Show context menu with clock customization options"""
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 6px;
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 16px;
                border-radius: 4px;
                font-family: "JetBrains Mono Nerd Font";
            }}
            QMenu::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
        """)
        # Clock quick settings submenu
        clock_menu = QMenu("Û∞•î Clock Settings", self)
        clock_menu.setStyleSheet(menu.styleSheet())
        # Font size quick adjustments
        font_size_menu = QMenu("Font Size", self)
        font_size_menu.setStyleSheet(menu.styleSheet())
        clock_sizes = [("Small (10pt)", 10), ("Medium (12pt)", 12), ("Large (14pt)", 14), ("X-Large (16pt)", 16)]
        for name, size in clock_sizes:
            action = QAction(name, self)
            action.triggered.connect(lambda checked, s=size: self.set_clock_font_size(s))
            font_size_menu.addAction(action)
        date_sizes = [("Small (7pt)", 7), ("Medium (9pt)", 9), ("Large (11pt)", 11)]
        for name, size in date_sizes:
            action = QAction(f"Date {name}", self)
            action.triggered.connect(lambda checked, s=size: self.set_date_font_size(s))
            font_size_menu.addAction(action)
        clock_menu.addMenu(font_size_menu)
        # Color quick picks
        color_menu = QMenu("Colors", self)
        color_menu.setStyleSheet(menu.styleSheet())
        color_presets = [
            ("Moon Glow", TokyoNight.MOON_GLOW),
            ("Cyan", TokyoNight.CYAN),
            ("Green", TokyoNight.GREEN),
            ("Yellow", TokyoNight.YELLOW),
            ("Pink", TokyoNight.PINK),
            ("White", TokyoNight.BRIGHT_WHITE)
        ]
        for name, color in color_presets:
            action = QAction(name, self)
            action.triggered.connect(lambda checked, c=color: self.set_clock_color(c))
            color_menu.addAction(action)
        clock_menu.addMenu(color_menu)
        # Toggle seconds
        seconds_action = QAction("Show Seconds", self)
        seconds_action.setCheckable(True)
        seconds_action.setChecked(self.config.show_seconds)
        seconds_action.triggered.connect(self.toggle_seconds)
        clock_menu.addAction(seconds_action)
        menu.addMenu(clock_menu)
        menu.addSeparator()
        # Custom Launchers submenu
        launchers_menu = QMenu("Û∞Äª Custom Launchers", self)
        launchers_menu.setStyleSheet(menu.styleSheet())
        # Add current custom launchers as quick actions
        if hasattr(self, 'custom_apps') and self.custom_apps:
            for name, command, icon in self.custom_apps:
                action = QAction(name, self)
                action.triggered.connect(lambda checked, cmd=command: self.launch_application(cmd))
                launchers_menu.addAction(action)
            launchers_menu.addSeparator()
        # Management actions
        add_action = QAction("Û∞êï Add Launcher", self)
        add_action.triggered.connect(self.add_custom_launcher)
        launchers_menu.addAction(add_action)
        edit_action = QAction("Û∞è´ Edit Launchers", self)
        edit_action.triggered.connect(self.edit_custom_launchers)
        launchers_menu.addAction(edit_action)
        menu.addMenu(launchers_menu)
        menu.addSeparator()
        # Tiling submenu
        tiling_menu = QMenu("‚äû Window Tiling", self)
        tiling_menu.setStyleSheet(menu.styleSheet())
        # Toggle tiling
        toggle_action = QAction("‚äû Toggle Tiling", self)
        toggle_action.triggered.connect(self.toggle_tiling)
        tiling_menu.addAction(toggle_action)
        # Force apply layout
        force_apply_action = QAction("üîÑ Force Apply Layout", self)
        force_apply_action.triggered.connect(self.force_apply_tiling)
        tiling_menu.addAction(force_apply_action)
        if hasattr(self, 'tiling_control') and self.tiling_control.tiler.is_active:
            # Layout options
            tiling_menu.addSeparator()
            layout_menu = QMenu("üìê Layout", self)
            layout_menu.setStyleSheet(menu.styleSheet())
            layouts = ["tall", "wide", "grid", "monocle", "floating"]
            for layout in layouts:
                action = QAction(layout.capitalize(), self)
                action.setCheckable(True)
                action.setChecked(self.tiling_control.tiler.layouts[self.tiling_control.tiler.current_layout] == layout)
                action.triggered.connect(lambda checked, l=layout: self.set_tiling_layout(l))
                layout_menu.addAction(action)
            tiling_menu.addMenu(layout_menu)
            # Cycle layout
            cycle_action = QAction("üîÑ Cycle Layout", self)
            cycle_action.triggered.connect(self.cycle_tiling_layout)
            tiling_menu.addAction(cycle_action)
            # Set master
            master_action = QAction("üéØ Set Master", self)
            master_action.triggered.connect(self.set_tiling_master)
            tiling_menu.addAction(master_action)
            tiling_menu.addSeparator()
            # Auto-tile toggle
            auto_tile_action = QAction("ü§ñ Auto-tile", self)
            auto_tile_action.setCheckable(True)
            auto_tile_action.setChecked(self.tiling_control.tiler.auto_tile)
            auto_tile_action.triggered.connect(self.toggle_auto_tile)
            tiling_menu.addAction(auto_tile_action)
            # Refresh layout
            refresh_action = QAction("üîÑ Refresh Layout", self)
            refresh_action.triggered.connect(self.refresh_layout)
            tiling_menu.addAction(refresh_action)
            # Correct alignment
            align_action = QAction("üîß Correct Alignment", self)
            align_action.triggered.connect(self.correct_alignment)
            tiling_menu.addAction(align_action)
            # Restart tiler
            restart_action = QAction("üîÑ Restart Tiler", self)
            restart_action.triggered.connect(self.restart_tiler)
            tiling_menu.addAction(restart_action)
        menu.addMenu(tiling_menu)
        menu.addSeparator()
        # NEW: Add Refresh Taskbar action
        refresh_taskbar_action = QAction("Û∞ëê Refresh Taskbar", self)
        refresh_taskbar_action.triggered.connect(self.refresh_taskbar)
        menu.addAction(refresh_taskbar_action)
        # Panel settings
        settings_action = QAction("Û∞íì Panel Settings", self)
        settings_action.triggered.connect(self.show_settings)
        menu.addAction(settings_action)
        menu.addSeparator()
        # Position submenu
        position_menu = QMenu("Û∞ñØ Position", self)
        position_menu.setStyleSheet(menu.styleSheet())
        top_action = QAction("Û∞ñù Top", self)
        top_action.setCheckable(True)
        top_action.setChecked(self.config.position == "top")
        top_action.triggered.connect(lambda: self.set_panel_position("top"))
        position_menu.addAction(top_action)
        bottom_action = QAction("Û∞ñî Bottom", self)
        bottom_action.setCheckable(True)
        bottom_action.setChecked(self.config.position == "bottom")
        bottom_action.triggered.connect(lambda: self.set_panel_position("bottom"))
        position_menu.addAction(bottom_action)
        menu.addMenu(position_menu)
        menu.addSeparator()
        # Panel height
        height_action = QAction("Û∞ñä Height", self)
        height_action.triggered.connect(self.show_height_dialog)
        menu.addAction(height_action)
        # Opacity
        opacity_action = QAction("Û∞óä Opacity", self)
        opacity_action.triggered.connect(self.show_opacity_dialog)
        menu.addAction(opacity_action)
        # Auto-hide toggle
        auto_hide_action = QAction("Û∞ñØ Auto-Hide", self)
        auto_hide_action.setCheckable(True)
        auto_hide_action.setChecked(self.config.auto_hide)
        auto_hide_action.triggered.connect(self.toggle_auto_hide)
        menu.addAction(auto_hide_action)
        menu.addSeparator()
        # Reload/Restart panel
        reload_action = QAction("Û∞ú∫ Reload Panel", self)
        reload_action.triggered.connect(self.reload_panel)
        menu.addAction(reload_action)
        # Quit panel
        quit_action = QAction("Û∞óº Quit Panel", self)
        quit_action.triggered.connect(self.quit_application)
        menu.addAction(quit_action)
        menu.exec_(self.mapToGlobal(position))

    def set_clock_font_size(self, size):
        """Quick set clock font size"""
        self.config.clock_font_size = size
        self.update_clock_styles()
        self.save_config()

    def set_date_font_size(self, size):
        """Quick set date font size"""
        self.config.date_font_size = size
        self.update_clock_styles()
        self.save_config()

    def set_clock_color(self, color):
        """Quick set clock color"""
        self.config.clock_color = color
        self.update_clock_styles()
        self.save_config()

    def toggle_seconds(self):
        """Toggle seconds display"""
        self.config.show_seconds = not self.config.show_seconds
        self.update_clock_styles()
        self.save_config()

    def save_config(self):
        """Save configuration"""
        config_manager = ConfigManager()
        config_manager.save_config(self.config)

    # NEW: Tiling control methods
    def toggle_tiling(self):
        """Toggle window tiling"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.toggle_tiling()

    def set_tiling_layout(self, layout_name):
        """Set specific tiling layout"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.set_layout(layout_name)

    def cycle_tiling_layout(self):
        """Cycle to next tiling layout"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.cycle_layout()

    def set_tiling_master(self):
        """Set currently focused window as master"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.set_master()

    def restart_tiler(self):
        """Restart the tiler"""
        if hasattr(self, 'tiling_control'):
            print("üîÑ Restarting window tiler")
            self.tiling_control.tiler.is_active = False
            time.sleep(0.5)
            self.tiling_control.tiler.is_active = True
            self.tiling_control.tiler.auto_tile = True
            self.tiling_control.force_apply_layout()

    def set_panel_position(self, position):
        """Set panel position"""
        if position != self.config.position:
            self.config.position = position
            self.update_panel_geometry()
            # Save config
            config_manager = ConfigManager()
            config_manager.save_config(self.config)

    def show_height_dialog(self):
        """Show dialog to change panel height"""
        height, ok = QInputDialog.getInt(
            self, "Panel Height",
            "Enter panel height (30-100):",
            self.config.height,
            30, 100
        )
        if ok and height != self.config.height:
            self.config.height = height
            self.update_panel_geometry()
            # Save config
            config_manager = ConfigManager()
            config_manager.save_config(self.config)

    def show_opacity_dialog(self):
        """Show dialog to change panel opacity"""
        opacity, ok = QInputDialog.getDouble(
            self, "Panel Opacity",
            "Enter opacity (0.1-1.0):",
            self.config.opacity,
            0.1, 1.0, 2
        )
        if ok and abs(opacity - self.config.opacity) > 0.01:
            self.config.opacity = opacity
            self.setWindowOpacity(opacity)
            # Save config
            config_manager = ConfigManager()
            config_manager.save_config(self.config)

    def toggle_auto_hide(self):
        """Toggle auto-hide setting"""
        self.config.auto_hide = not self.config.auto_hide
        if self.config.auto_hide:
            self.auto_hide_timer.start(self.config.auto_hide_delay)
        else:
            self.auto_hide_timer.stop()
            if self.is_hidden:
                self.show_panel()
        # Save config
        config_manager = ConfigManager()
        config_manager.save_config(self.config)

    def update_panel_geometry(self):
        """Update panel position and size - STRETCHED TO FULL SCREEN WIDTH"""
        screen = QApplication.primaryScreen()
        screen_rect = screen.availableGeometry()
        # Use full screen width, not just available geometry
        full_screen_rect = screen.geometry()
        if self.config.position == 'top':
            self.setGeometry(0, 0, full_screen_rect.width(), self.config.height)
        else:  # bottom
            y_pos = full_screen_rect.height() - self.config.height
            self.setGeometry(0, y_pos, full_screen_rect.width(), self.config.height)
        # Update strut after geometry change
        QTimer.singleShot(100, self.setup_strut)

    def setup_strut(self):
        """Setup window strut to reserve space for the panel - USING FULL WIDTH"""
        try:
            screen = QApplication.primaryScreen()
            screen_rect = screen.geometry()  # Use full geometry, not available
            # Get the window ID
            window_id = int(self.winId())
            # Calculate strut values based on panel position
            if self.config.position == 'top':
                strut_left = 0
                strut_right = 0
                strut_top = self.config.height
                strut_bottom = 0
                # Partial strut values - use full screen width
                strut_partial = (
                    0, 0, self.config.height, 0,
                    0, 0, 0, 0,
                    0, screen_rect.width(),
                    0, 0
                )
            else:  # bottom
                strut_left = 0
                strut_right = 0
                strut_top = 0
                strut_bottom = self.config.height
                # Partial strut values - use full screen width
                strut_partial = (
                    0, 0, 0, self.config.height,
                    0, 0, 0, 0,
                    0, 0,
                    0, screen_rect.width()
                )
            # Set strut properties
            subprocess.run([
                "xprop", "-id", str(window_id),
                "-f", "_NET_WM_STRUT", "32cccc",
                "-set", "_NET_WM_STRUT",
                f"{strut_left}, {strut_right}, {strut_top}, {strut_bottom}"
            ], check=False)
            subprocess.run([
                "xprop", "-id", str(window_id),
                "-f", "_NET_WM_STRUT_PARTIAL", "32cccc",
                "-set", "_NET_WM_STRUT_PARTIAL",
                f"{strut_partial[0]}, {strut_partial[1]}, {strut_partial[2]}, {strut_partial[3]}, "
                f"{strut_partial[4]}, {strut_partial[5]}, {strut_partial[6]}, {strut_partial[7]}, "
                f"{strut_partial[8]}, {strut_partial[9]}, {strut_partial[10]}, {strut_partial[11]}"
            ], check=False)
            # Set window type to dock
            subprocess.run([
                "xprop", "-id", str(window_id),
                "-f", "_NET_WM_WINDOW_TYPE", "32a",
                "-set", "_NET_WM_WINDOW_TYPE", "_NET_WM_WINDOW_TYPE_DOCK"
            ], check=False)
            # Set state to skip taskbar and pager
            subprocess.run([
                "xprop", "-id", str(window_id),
                "-f", "_NET_WM_STATE", "32a",
                "-set", "_NET_WM_STATE", 
                "_NET_WM_STATE_SKIP_TASKBAR,_NET_WM_STATE_SKIP_PAGER"
            ], check=False)
        except Exception as e:
            print(f"Failed to set strut: {e}")

    def start_timers(self):
        """Start all timers for updating UI elements"""
        # Clock timer
        self.clock_timer = QTimer()
        self.clock_timer.timeout.connect(self.update_clock)
        self.clock_timer.start(1000)  # Update every second
        # Window list timer
        self.window_timer = QTimer()
        self.window_timer.timeout.connect(self.update_windows)
        self.window_timer.start(2000)  # Update every 2 seconds
        # Initial updates
        self.update_clock()
        self.update_windows()




    def toggle_tiling(self):
        """Toggle window tiling"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.toggle_tiling()

    def set_tiling_layout(self, layout_name):
        """Set specific tiling layout"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.set_layout(layout_name)

    def cycle_tiling_layout(self):
        """Cycle to next tiling layout"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.cycle_layout()

    def set_tiling_master(self):
        """Set currently focused window as master"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.set_master()

    def force_apply_tiling(self):
        """Force apply tiling layout"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.force_apply_layout()

    def toggle_auto_tile(self):
        """Toggle auto-tiling"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.tiler.toggle_auto_tile()
            self.tiling_control.update_display()

    def restart_tiler(self):
        """Restart the tiler"""
        if hasattr(self, 'tiling_control'):
            print("üîÑ Restarting window tiler")
            self.tiling_control.tiler.is_active = False
            import time
            time.sleep(0.5)
            self.tiling_control.tiler.is_active = True
            self.tiling_control.tiler.auto_tile = True
            self.tiling_control.force_apply_layout()


















class ConfigManager:
    """Configuration manager for saving/loading settings"""
    def __init__(self, config_file=None):
        if config_file is None:
            config_dir = Path.home() / ".config" / "tokyo-night-panel"
            config_dir.mkdir(parents=True, exist_ok=True)
            config_file = config_dir / "panel.conf"
        self.config_file = Path(config_file)
        self.settings = QSettings(str(self.config_file), QSettings.IniFormat)

    def save_config(self, config: PanelConfig):
        """Save configuration to file"""
        # Basic appearance settings
        self.settings.setValue("position", config.position)
        self.settings.setValue("height", config.height)
        self.settings.setValue("opacity", config.opacity)
        self.settings.setValue("blur_effect", config.blur_effect)
        self.settings.setValue("show_date", config.show_date)
        self.settings.setValue("show_battery", config.show_battery)
        self.settings.setValue("show_volume", config.show_volume)
        self.settings.setValue("show_network", config.show_network)
        self.settings.setValue("show_tray", config.show_tray)
        self.settings.setValue("show_xfce_launchers", config.show_xfce_launchers)
        self.settings.setValue("theme_variant", config.theme_variant)
        self.settings.setValue("rounded_corners", config.rounded_corners)
        self.settings.setValue("corner_radius", config.corner_radius)
        
        # New features
        self.settings.setValue("show_workspace_switcher", config.show_workspace_switcher)
        self.settings.setValue("show_brightness_control", config.show_brightness_control)
        self.settings.setValue("show_weather", config.show_weather)
        self.settings.setValue("show_notifications", config.show_notifications)
        
        # NEW: Network and Bluetooth controls
        self.settings.setValue("show_network_control", config.show_network_control)
        self.settings.setValue("show_bluetooth_control", config.show_bluetooth_control)
        self.settings.setValue("weather_location", config.weather_location)
        
        # NEW: Tiling control
        self.settings.setValue("show_tiling_control", config.show_tiling_control)
        
        # Auto-hide settings
        self.settings.setValue("auto_hide", config.auto_hide)
        self.settings.setValue("auto_hide_delay", config.auto_hide_delay)
        self.settings.setValue("show_on_edge", config.show_on_edge)
        self.settings.setValue("edge_size", config.edge_size)

        # Save built-in launcher commands
        self.settings.setValue("terminal_command", config.terminal_command)
        self.settings.setValue("file_manager_command", config.file_manager_command)
        self.settings.setValue("browser_command", config.browser_command)
        self.settings.setValue("text_editor_command", config.text_editor_command)
        self.settings.setValue("settings_command", config.settings_command)
        self.settings.setValue("calculator_command", config.calculator_command)
        self.settings.setValue("screenshot_command", config.screenshot_command)
        self.settings.setValue("image_viewer_command", config.image_viewer_command)
        self.settings.setValue("music_player_command", config.music_player_command)
        self.settings.setValue("music_player_args", config.music_player_args)

        # Save custom launchers from panel context menu
        if hasattr(config, 'custom_launchers'):
            self.settings.setValue("custom_launchers", config.custom_launchers)
            print(f"DEBUG: Saved {len(config.custom_launchers)} custom launchers to config")
        else:
            self.settings.setValue("custom_launchers", [])
            print("DEBUG: No custom_launchers attribute found, saving empty list")

        # Save custom launchers (from SettingsDialog)
        if config.launcher_customizations:
            launchers_data = []
            for launcher in config.launcher_customizations:
                # Convert the Application dataclass to a dictionary
                launcher_dict = {
                    'name': launcher.name,
                    'command': launcher.command,
                    'icon': launcher.icon,
                    'args': launcher.args,
                    'workspace': launcher.workspace  # Save workspace setting
                }
                launchers_data.append(launcher_dict)
            self.settings.setValue("launcher_customizations", launchers_data)
            print(f"DEBUG: ConfigManager saved {len(launchers_data)} custom launchers from SettingsDialog")
        else:
            self.settings.setValue("launcher_customizations", [])
            print("DEBUG: ConfigManager saved empty custom launchers list from SettingsDialog")
        
        # NEW: Clock settings
        self.settings.setValue("clock_font_size", config.clock_font_size)
        self.settings.setValue("date_font_size", config.date_font_size)
        self.settings.setValue("clock_color", config.clock_color)
        self.settings.setValue("date_color", config.date_color)
        self.settings.setValue("clock_font_weight", config.clock_font_weight)
        self.settings.setValue("date_font_weight", config.date_font_weight)
        self.settings.setValue("show_seconds", config.show_seconds)
        self.settings.setValue("date_format", config.date_format)
        self.settings.setValue("time_format", config.time_format)
        
        self.settings.sync()
        print("DEBUG: ConfigManager finished saving all settings")

    def load_config(self) -> PanelConfig:
        """Load configuration from file"""
        config = PanelConfig()
        
        # Basic appearance settings
        config.position = self.settings.value("position", "top", type=str)
        config.height = self.settings.value("height", 40, type=int)
        config.opacity = self.settings.value("opacity", 0.95, type=float)
        config.blur_effect = self.settings.value("blur_effect", True, type=bool)
        config.show_date = self.settings.value("show_date", True, type=bool)
        config.show_battery = self.settings.value("show_battery", True, type=bool)
        config.show_volume = self.settings.value("show_volume", True, type=bool)
        config.show_network = self.settings.value("show_network", False, type=bool)
        config.show_tray = self.settings.value("show_tray", True, type=bool)
        config.show_xfce_launchers = self.settings.value("show_xfce_launchers", True, type=bool)
        config.theme_variant = self.settings.value("theme_variant", "tokyo_night", type=str)
        config.rounded_corners = self.settings.value("rounded_corners", True, type=bool)
        config.corner_radius = self.settings.value("corner_radius", 10, type=int)
        
        # New features
        config.show_workspace_switcher = self.settings.value("show_workspace_switcher", True, type=bool)
        config.show_brightness_control = self.settings.value("show_brightness_control", True, type=bool)
        config.show_weather = self.settings.value("show_weather", True, type=bool)
        config.show_notifications = self.settings.value("show_notifications", True, type=bool)
        
        # NEW: Network and Bluetooth controls
        config.show_network_control = self.settings.value("show_network_control", True, type=bool)
        config.show_bluetooth_control = self.settings.value("show_bluetooth_control", True, type=bool)
        config.weather_location = self.settings.value("weather_location", "", type=str)
        
        # NEW: Tiling control
        config.show_tiling_control = self.settings.value("show_tiling_control", True, type=bool)
        
        # Auto-hide settings
        config.auto_hide = self.settings.value("auto_hide", False, type=bool)
        config.auto_hide_delay = self.settings.value("auto_hide_delay", 2000, type=int)
        config.show_on_edge = self.settings.value("show_on_edge", True, type=bool)
        config.edge_size = self.settings.value("edge_size", 5, type=int)

        # Load built-in launcher commands
        config.terminal_command = self.settings.value("terminal_command", "xfce4-terminal", type=str)
        config.file_manager_command = self.settings.value("file_manager_command", "thunar", type=str)
        config.browser_command = self.settings.value("browser_command", "firefox", type=str)
        config.text_editor_command = self.settings.value("text_editor_command", "mousepad", type=str)
        config.settings_command = self.settings.value("settings_command", "xfce4-settings-manager", type=str)
        config.calculator_command = self.settings.value("calculator_command", "gnome-calculator", type=str)
        config.screenshot_command = self.settings.value("screenshot_command", "xfce4-screenshooter", type=str)
        config.image_viewer_command = self.settings.value("image_viewer_command", "ristretto", type=str)
        config.music_player_command = self.settings.value("music_player_command", "vlc", type=str)
        config.music_player_args = self.settings.value("music_player_args", "", type=str)

        # Load custom launchers from panel context menu
        config.custom_launchers = self.settings.value("custom_launchers", [], type=list)
        print(f"DEBUG: Loaded {len(config.custom_launchers)} custom launchers from config")

        # Load custom launchers (from SettingsDialog)
        config.launcher_customizations = []
        launchers_data = self.settings.value("launcher_customizations", [])
        
        if launchers_data:
            for launcher_dict in launchers_data:
                try:
                    # Handle both string and dict formats
                    if isinstance(launcher_dict, str):
                        # Legacy format - skip or convert if needed
                        continue
                    elif isinstance(launcher_dict, dict):
                        # Create Application object from dictionary
                        launcher = Application(
                            name=launcher_dict.get('name', ''),
                            command=launcher_dict.get('command', ''),
                            icon=launcher_dict.get('icon', 'üöÄ'),
                            args=launcher_dict.get('args', ''),
                            workspace=launcher_dict.get('workspace', -1)  # Load workspace setting
                        )
                        config.launcher_customizations.append(launcher)
                except Exception as e:
                    print(f"Error loading launcher: {e}")
        
        # NEW: Clock settings
        config.clock_font_size = self.settings.value("clock_font_size", 11, type=int)
        config.date_font_size = self.settings.value("date_font_size", 8, type=int)
        config.clock_color = self.settings.value("clock_color", TokyoNight.MOON_GLOW, type=str)
        config.date_color = self.settings.value("date_color", TokyoNight.FOREGROUND, type=str)
        config.clock_font_weight = self.settings.value("clock_font_weight", "bold", type=str)
        config.date_font_weight = self.settings.value("date_font_weight", "normal", type=str)
        config.show_seconds = self.settings.value("show_seconds", False, type=bool)
        config.date_format = self.settings.value("date_format", "ddd MMM d", type=str)
        config.time_format = self.settings.value("time_format", "hh:mm AP", type=str)
        
        print(f"DEBUG: ConfigManager loaded {len(config.launcher_customizations)} custom launchers from SettingsDialog")
        print(f"DEBUG: ConfigManager finished loading all settings")
        
        return config

class TrayIconManager:
    """System tray icon manager"""
    def __init__(self, panel):
        self.panel = panel
        self.tray_icon = QSystemTrayIcon(self.create_icon(), panel)
        self.setup_tray_menu()

    def create_icon(self):
        """Create tray icon with Tokyo Night colors"""
        pixmap = QPixmap(32, 32)
        pixmap.fill(QColor(TokyoNight.NIGHT_TOP))
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        # Draw Tokyo Night styled icon with moon theme
        gradient = QLinearGradient(0, 0, 32, 32)
        gradient.setColorAt(0, QColor(TokyoNight.MOON_GLOW))
        gradient.setColorAt(1, QColor(TokyoNight.BLUE))
        painter.setBrush(gradient)
        painter.setPen(Qt.NoPen)
        painter.drawRoundedRect(4, 4, 24, 24, 6, 6)
        # Draw moon crescent
        painter.setBrush(QColor(TokyoNight.NIGHT_TOP))
        painter.drawEllipse(18, 8, 10, 10)
        painter.end()
        return QIcon(pixmap)

    def setup_tray_menu(self):
        """Setup tray icon context menu"""
        menu = QMenu()
        menu.setStyleSheet(self.panel.get_stylesheet())
        show_action = QAction("Û∞Äæ Show Panel", self.panel)
        show_action.triggered.connect(self.panel.show_panel)
        menu.addAction(show_action)
        hide_action = QAction("Û∞ñØ Hide Panel", self.panel)
        hide_action.triggered.connect(self.panel.hide_panel)
        menu.addAction(hide_action)
        menu.addSeparator()
        settings_action = QAction("Û∞íì Settings", self.panel)
        settings_action.triggered.connect(self.panel.show_settings)
        menu.addAction(settings_action)
        menu.addSeparator()
        restart_action = QAction("Û∞ú∫ Restart", self.panel)
        restart_action.triggered.connect(self.panel.restart_panel)
        menu.addAction(restart_action)
        quit_action = QAction("Û∞óº Quit", self.panel)
        quit_action.triggered.connect(self.panel.quit_application)
        menu.addAction(quit_action)
        self.tray_icon.setContextMenu(menu)
        self.tray_icon.activated.connect(self.tray_icon_activated)

    def tray_icon_activated(self, reason):
        """Handle tray icon activation"""
        if reason == QSystemTrayIcon.DoubleClick:
            if self.panel.isVisible():
                self.panel.hide_panel()
            else:
                self.panel.show_panel()

    def show(self):
        """Show tray icon"""
        self.tray_icon.show()

    def show_message(self, title, message, timeout=3000):
        """Show tray notification"""
        self.tray_icon.showMessage(title, message, QSystemTrayIcon.Information, timeout)

class XfceLauncherReader:
    """Read XFCE panel launchers from configuration files"""
    def __init__(self):
        self.config_dir = Path.home() / ".config" / "xfce4" / "panel"
        self.launchers_dir = Path.home() / ".config" / "xfce4" / "panel" / "launchers"

    def get_xfce_launchers(self):
        """Get XFCE panel launchers"""
        launchers = []
        try:
            # Find launcher directories
            if not self.launchers_dir.exists():
                return launchers
            
            # Read each launcher file
            for launcher_file in self.launchers_dir.glob("*.desktop"):
                launcher = self.parse_launcher_file(launcher_file)
                if launcher:
                    launchers.append(launcher)
        except Exception as e:
            print(f"Error reading XFCE launchers: {e}")
        return launchers

    def parse_launcher_file(self, file_path):
        """Parse a single launcher .desktop file"""
        try:
            with open(file_path, 'r') as f:
                content = f.read()
            
            # Parse desktop file
            name = ""
            command = ""
            icon = ""
            
            for line in content.splitlines():
                if line.startswith("Name="):
                    name = line.split("=", 1)[1]
                elif line.startswith("Exec="):
                    command = line.split("=", 1)[1]
                    # Remove %U, %F, etc. from command
                    command = re.sub(r'\s%[fFuU]', '', command)
                elif line.startswith("Icon="):
                    icon = line.split("=", 1)[1]
            
            if name and command:
                # Try to get icon from theme or use emoji fallback
                if icon:
                    # Check if it's a file path
                    if os.path.exists(icon):
                        # For file icons, we'll use a generic emoji
                        icon = "üöÄ"
                    else:
                        # For theme icons, we'll use a generic emoji
                        icon = "üöÄ"
                else:
                    # Fallback icon based on command
                    if "terminal" in command.lower():
                        icon = "Û∞Üç"
                    elif "browser" in command.lower() or "firefox" in command.lower():
                        icon = "Û∞àπ"
                    elif "file" in command.lower() or "thunar" in command.lower():
                        icon = "Û∞âã"
                    elif "text" in command.lower() or "editor" in command.lower():
                        icon = "Û∞à¨"
                    elif "settings" in command.lower():
                        icon = "Û∞É§"
                    elif "calculator" in command.lower():
                        icon = "Û∞éÅ"
                    elif "screenshot" in command.lower():
                        icon = "Û∞äì"
                    elif "image" in command.lower() or "viewer" in command.lower():
                        icon = "Û∞ª≠"
                    elif "music" in command.lower() or "vlc" in command.lower():
                        icon = "Û∞éÑ"
                    else:
                        icon = "üöÄ"
                
                return Application(name=name, command=command, icon=icon)
        except Exception as e:
            print(f"Error parsing launcher file {file_path}: {e}")
        return None

def main():
    """Main application entry point"""
    # Set up high DPI scaling
    QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
    QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps, True)
    app = QApplication(sys.argv)
    app.setApplicationName("Tokyo Night Panel")
    app.setApplicationVersion("1.0.0")
    
    # Set up system tray
    tray_available = QSystemTrayIcon.isSystemTrayAvailable()
    if not tray_available:
        print("System tray is not available, panel will run without tray icon")
    app.setQuitOnLastWindowClosed(False)
    
    # Load configuration
    config_manager = ConfigManager()
    config = config_manager.load_config()
    
    # Create and show panel with error handling
    try:
        panel = TokyoNightPanelBar(config)
        panel.show()
        
        # Setup system tray only if available
        if tray_available:
            try:
                tray_manager = TrayIconManager(panel)
                tray_manager.show()
                tray_manager.show_message("Tokyo Night Panel", "Panel started with memory protection")
            except Exception as e:
                print(f"Failed to create system tray icon: {e}")
        
        # Ensure cleanup on exit
        def cleanup_and_quit():
            print("üõë Application quitting, cleaning up...")
            panel.cleanup()
            app.quit()
        
        app.aboutToQuit.connect(cleanup_and_quit)
        
        # Handle signals for graceful shutdown
        def handle_signal(signum, frame):
            print(f"üõë Received signal {signum}, shutting down...")
            cleanup_and_quit()
        
        signal.signal(signal.SIGTERM, handle_signal)
        signal.signal(signal.SIGINT, handle_signal)
        
        print("üöÄ Tokyo Night Panel started with memory protection")
        return app.exec_()
        
    except Exception as e:
        print(f"‚ùå Panel initialization failed: {e}")
        # Attempt restart after a delay
        print("üîÑ Attempting to restart panel...")
        QTimer.singleShot(3000, lambda: subprocess.Popen([sys.executable] + sys.argv))
        return 1

if __name__ == "__main__":
    sys.exit(main())