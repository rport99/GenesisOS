#!/usr/bin/env python3
import sys
import json
import os
import subprocess
import re
import threading
import requests
import html
from concurrent.futures import ThreadPoolExecutor
from pathlib import Path
from PyQt6.QtWidgets import *
from PyQt6.QtCore import *
from PyQt6.QtGui import *

# Suppress DBus warnings
os.environ['QT_LOGGING_RULES'] = 'qt.qpa.theme.gnome=false'


class AppDetector:
    """Intelligent application detector for Linux systems with caching"""
    _cached_apps = None
    _cached_apps_by_category = None
    _cached_icons = {}
    _cache_lock = threading.Lock()
    _icon_cache_lock = threading.Lock()

    @staticmethod
    def get_system_applications():
        """Get all installed applications with caching"""
        with AppDetector._cache_lock:
            if AppDetector._cached_apps is not None:
                return AppDetector._cached_apps.copy()
        threading.Thread(target=AppDetector._load_applications_async, daemon=True).start()
        return []

    @staticmethod
    def _load_applications_async():
        apps = []
        seen_execs = set()
        app_dirs = [
            '/usr/share/applications',
            '/usr/local/share/applications',
            os.path.expanduser('~/.local/share/applications'),
            '/var/lib/snapd/desktop/applications'
        ]
        with ThreadPoolExecutor(max_workers=4) as executor:
            future_to_file = {}
            for app_dir in app_dirs:
                if not os.path.exists(app_dir):
                    continue
                try:
                    desktop_files = []
                    for root, dirs, files in os.walk(app_dir):
                        for file in files:
                            if file.endswith('.desktop'):
                                desktop_files.append(os.path.join(root, file))
                        if root.count(os.sep) - app_dir.count(os.sep) > 2:
                            dirs[:] = []
                except:
                    continue
                for file_path in desktop_files[:200]:
                    future = executor.submit(AppDetector.parse_desktop_file_fast, file_path)
                    future_to_file[future] = file_path
            for future in future_to_file:
                try:
                    app_info = future.result(timeout=1)
                    if app_info and app_info.get('Exec'):
                        exec_cmd = app_info['Exec']
                        if exec_cmd not in seen_execs:
                            seen_execs.add(exec_cmd)
                            apps.append(app_info)
                except:
                    continue
        apps.sort(key=lambda x: x.get('Name', '').lower())
        with AppDetector._cache_lock:
            AppDetector._cached_apps = apps[:300]
        return apps[:300]

    @staticmethod
    def parse_desktop_file_fast(file_path):
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read(2048)
            app_info = {'desktop_file': file_path}
            in_desktop_entry = False
            lines_processed = 0
            for line in content.split('\n'):
                lines_processed += 1
                if lines_processed > 50:
                    break
                line = line.strip()
                if line == '[Desktop Entry]':
                    in_desktop_entry = True
                    continue
                elif line.startswith('['):
                    in_desktop_entry = False
                    continue
                if not in_desktop_entry:
                    continue
                if '=' in line:
                    key, value = line.split('=', 1)
                    if key == 'NoDisplay' and value == 'true':
                        return None
                    if key == 'Hidden' and value == 'true':
                        return None
                    if key == 'Terminal' and value == 'true':
                        return None
                    if key in ['Name', 'Exec', 'Icon', 'Categories']:
                        if key == 'Exec':
                            value = AppDetector.clean_exec_command_fast(value)
                            if not value:
                                return None
                        app_info[key] = value
            if not app_info.get('Name') or not app_info.get('Exec'):
                return None
            return app_info
        except:
            return None

    @staticmethod
    def clean_exec_command_fast(exec_cmd):
        exec_cmd = re.sub(r'%[a-zA-Z]', '', exec_cmd)
        exec_cmd = exec_cmd.strip()
        parts = exec_cmd.split()
        if parts:
            return parts[0].strip('"\'')
        return ''

    @staticmethod
    def find_application_icon(icon_name):
        if not icon_name:
            return None
        with AppDetector._icon_cache_lock:
            if icon_name in AppDetector._cached_icons:
                cached_path = AppDetector._cached_icons[icon_name]
                if cached_path and os.path.exists(cached_path):
                    return cached_path
                elif cached_path is None:
                    return None
        icon_path = None
        if os.path.isabs(icon_name):
            for ext in ['', '.png', '.svg', '.xpm', '.jpg']:
                test_path = icon_name + ext if not icon_name.endswith(ext) else icon_name
                if os.path.exists(test_path):
                    icon_path = test_path
                    break
        else:
            icon_path = AppDetector._search_icon_by_name(icon_name)
        with AppDetector._icon_cache_lock:
            AppDetector._cached_icons[icon_name] = icon_path
        return icon_path

    @staticmethod
    def _search_icon_by_name(icon_name):
        icon_dirs = [
            '/usr/share/pixmaps',
            '/usr/share/icons/hicolor/48x48/apps',
            '/usr/share/icons/hicolor/32x32/apps',
            '/usr/share/icons/hicolor/64x64/apps',
            '/usr/share/icons/hicolor/scalable/apps',
            '/usr/share/icons/Adwaita/48x48/apps',
            '/usr/share/icons/Adwaita/scalable/apps',
            '/usr/share/icons/gnome/48x48/apps',
            '/usr/share/icons/breeze/apps/48',
            '/usr/share/icons/oxygen/48x48/apps',
            os.path.expanduser('~/.local/share/icons/hicolor/48x48/apps'),
            os.path.expanduser('~/.local/share/icons'),
            '/var/lib/flatpak/exports/share/icons/hicolor/48x48/apps',
            '/snap/snapd-desktop-integration/current/usr/share/icons/hicolor/48x48/apps'
        ]
        icon_extensions = ['.png', '.svg', '.xpm', '.jpg', '']
        for icon_dir in icon_dirs:
            if not os.path.exists(icon_dir):
                continue
            for ext in icon_extensions:
                patterns = [
                    os.path.join(icon_dir, icon_name + ext),
                    os.path.join(icon_dir, icon_name.lower() + ext),
                    os.path.join(icon_dir, icon_name + ext.lower())
                ]
                for icon_path in patterns:
                    if os.path.exists(icon_path):
                        return icon_path
        return None

    @staticmethod
    def find_icon_for_command(command):
        if not command:
            return None
        base_cmd = command.strip()
        if ' ' in base_cmd:
            base_cmd = base_cmd.split()[0]
        base_cmd = os.path.basename(base_cmd)
        if '.' in base_cmd:
            base_cmd = base_cmd.split('.')[0]
        apps = AppDetector.get_system_applications()
        cmd_lower = base_cmd.lower()
        for app in apps:
            app_exec = app.get('Exec', '').lower()
            if cmd_lower in app_exec or cmd_lower == app_exec:
                icon_name = app.get('Icon')
                if icon_name:
                    icon_path = AppDetector.find_application_icon(icon_name)
                    if icon_path:
                        return icon_path
        for app in apps:
            app_exec = app.get('Exec', '').lower()
            app_name = app.get('Name', '').lower()
            if cmd_lower in app_exec or cmd_lower in app_name:
                icon_name = app.get('Icon')
                if icon_name:
                    icon_path = AppDetector.find_application_icon(icon_name)
                    if icon_path:
                        return icon_path
        return AppDetector.find_application_icon(base_cmd)

    @staticmethod
    def suggest_applications(search_term):
        apps = AppDetector.get_system_applications()
        suggestions = []
        search_lower = search_term.lower()
        for app in apps:
            name = app.get('Name', '').lower()
            exec_cmd = app.get('Exec', '').lower()
            if search_lower in name:
                suggestions.append(app)
            elif search_lower in exec_cmd:
                suggestions.append(app)
            if len(suggestions) >= 15:
                break
        return suggestions

    @staticmethod
    def refresh_cache():
        with AppDetector._cache_lock:
            AppDetector._cached_apps = None
            AppDetector._cached_apps_by_category = None
        with AppDetector._icon_cache_lock:
            AppDetector._cached_icons.clear()


class DuckDuckGoSearcher:
    @staticmethod
    def search_ddg(query, max_results=10):
        try:
            from bs4 import BeautifulSoup
        except ImportError:
            print("Error: beautifulsoup4 is not installed. Install with: sudo pacman -S python-beautifulsoup4")
            return DuckDuckGoSearcher._get_mock_results(query)

        url = "https://html.duckduckgo.com/html/"
        headers = {
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Content-Type': 'application/x-www-form-urlencoded',
            'Origin': 'https://html.duckduckgo.com',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1'
        }
        data = {'q': query, 'kl': 'us-en', 'kp': '-2'}
        try:
            response = requests.post(url, headers=headers, data=data, timeout=10)
            response.raise_for_status()
        except Exception as e:
            print(f"Network error: {e}")
            return DuckDuckGoSearcher._get_mock_results(query)

        soup = BeautifulSoup(response.text, 'html.parser')
        results = []
        # Modern DDG uses <a class="result__a"> for links
        links = soup.find_all('a', class_='result__a', href=True)
        for i, link in enumerate(links[:max_results]):
            title = link.get_text(strip=True) or f"Result {i+1}"
            url = link['href']
            if url.startswith('//'):
                url = 'https:' + url

            # Extract snippet: usually in next <tr> or sibling text
            snippet = ""
            parent = link.find_parent()
            if parent:
                snippet_div = parent.find('td', class_='result__snippet')
                if snippet_div:
                    snippet = snippet_div.get_text(strip=True)
                else:
                    # Fallback: look for any small descriptive text nearby
                    small = parent.find('small')
                    if small:
                        snippet = small.get_text(strip=True)

            results.append({
                'title': html.unescape(title),
                'url': url,
                'snippet': html.unescape(snippet[:150] + "..." if len(snippet) > 150 else snippet)
            })

        if not results:
            return DuckDuckGoSearcher._get_mock_results(query)
        return results

    @staticmethod
    def _get_mock_results(query):
        return [
            {
                'title': f'No results for "{query}"',
                'url': 'https://duckduckgo.com/?q=' + query.replace(' ', '+'),
                'snippet': 'This is a fallback. Make sure you have internet and beautifulsoup4 installed.'
            },
            {
                'title': 'DuckDuckGo ‚Äì Privacy, simplified.',
                'url': 'https://duckduckgo.com/',
                'snippet': 'Search privately with DuckDuckGo.'
            }
        ]


class SearchResultsDialog(QDialog):
    def __init__(self, results, color_scheme=None, parent=None):
        super().__init__(parent)
        self.color_scheme = color_scheme or ColorScheme()
        self.results = results
        self.setup_ui()

    def setup_ui(self):
        self.setWindowTitle("üîç DuckDuckGo Results")
        self.setFixedSize(700, 500)
        self.setWindowFlags(
            Qt.WindowType.Dialog |
            Qt.WindowType.FramelessWindowHint |
            Qt.WindowType.WindowStaysOnTopHint
        )
        layout = QVBoxLayout()
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)

        header = QLabel("üîç DuckDuckGo Search Results")
        header.setAlignment(Qt.AlignmentFlag.AlignCenter)
        header.setStyleSheet(f"""
        QLabel {{
            color: {self.color_scheme.ACCENT};
            font-size: 16px;
            font-weight: bold;
            padding: 12px;
            background-color: {self.color_scheme.SURFACE};
            border-radius: 8px;
            border: 1px solid {self.color_scheme.BORDER};
        }}
        """)
        layout.addWidget(header)

        self.results_list = QListWidget()
        self.results_list.setStyleSheet(f"""
        QListWidget {{
            background-color: {self.color_scheme.SURFACE};
            border: 1px solid {self.color_scheme.BORDER};
            border-radius: 8px;
        }}
        QListWidget::item {{
            padding: 12px;
            border-bottom: 1px solid {self.color_scheme.BORDER}30;
            color: {self.color_scheme.TEXT_PRIMARY};
            font-size: 12px;
        }}
        QListWidget::item:selected {{
            background-color: {self.color_scheme.ACCENT}40;
            color: {self.color_scheme.ACCENT};
        }}
        """)
        self.results_list.itemDoubleClicked.connect(self.open_result)

        for result in self.results:
            item_text = f"üåê {result['title']}\n"
            item_text += f"üîó {result['url']}\n"
            if result['snippet']:
                item_text += f"üìù {result['snippet']}"
            item = QListWidgetItem(item_text)
            item.setData(Qt.ItemDataRole.UserRole, result['url'])
            self.results_list.addItem(item)

        layout.addWidget(self.results_list)

        button_layout = QHBoxLayout()
        open_btn = QPushButton("üåê Open Selected")
        open_btn.clicked.connect(self.open_selected_result)
        open_btn.setMinimumHeight(40)
        open_btn.setStyleSheet(f"""
        QPushButton {{
            background-color: {self.color_scheme.SUCCESS};
            color: {self.color_scheme.BACKGROUND};
            border: none;
            border-radius: 8px;
            padding: 10px 15px;
            font-weight: bold;
            font-size: 12px;
        }}
        QPushButton:hover {{ background-color: {self.color_scheme.SUCCESS}DD; }}
        """)
        copy_btn = QPushButton("üìã Copy URL")
        copy_btn.clicked.connect(self.copy_selected_url)
        copy_btn.setMinimumHeight(40)
        copy_btn.setStyleSheet(f"""
        QPushButton {{
            background-color: {self.color_scheme.CYAN};
            color: {self.color_scheme.BACKGROUND};
            border: none;
            border-radius: 8px;
            padding: 10px 15px;
            font-weight: bold;
            font-size: 12px;
        }}
        QPushButton:hover {{ background-color: {self.color_scheme.CYAN}DD; }}
        """)
        close_btn = QPushButton("‚úï Close")
        close_btn.clicked.connect(self.close)
        close_btn.setMinimumHeight(40)
        close_btn.setStyleSheet(f"""
        QPushButton {{
            background-color: {self.color_scheme.ERROR};
            color: {self.color_scheme.BACKGROUND};
            border: none;
            border-radius: 8px;
            padding: 10px 15px;
            font-weight: bold;
            font-size: 12px;
        }}
        QPushButton:hover {{ background-color: {self.color_scheme.ERROR}DD; }}
        """)
        button_layout.addWidget(open_btn)
        button_layout.addWidget(copy_btn)
        button_layout.addStretch()
        button_layout.addWidget(close_btn)
        layout.addLayout(button_layout)

        self.setLayout(layout)
        self.setStyleSheet(f"QDialog {{ background-color: {self.color_scheme.BACKGROUND}; }}")
        self.center_on_screen()

    def center_on_screen(self):
        screen_geometry = QApplication.primaryScreen().geometry()
        x = (screen_geometry.width() - self.width()) // 2
        y = (screen_geometry.height() - self.height()) // 2
        self.move(x, y)

    def open_selected_result(self):
        selected_items = self.results_list.selectedItems()
        if selected_items:
            self.open_result(selected_items[0])

    def open_result(self, item):
        url = item.data(Qt.ItemDataRole.UserRole)
        try:
            subprocess.Popen(['xdg-open', url], start_new_session=True)
            self.accept()
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not open URL:\n{url}\n\n{e}")

    def copy_selected_url(self):
        selected_items = self.results_list.selectedItems()
        if selected_items:
            url = selected_items[0].data(Qt.ItemDataRole.UserRole)
            clipboard = QApplication.clipboard()
            clipboard.setText(url)
            QMessageBox.information(self, "Copied", "URL copied to clipboard!")


class SearchThread(QThread):
    search_complete = pyqtSignal(list)
    search_error = pyqtSignal(str)

    def __init__(self, query):
        super().__init__()
        self.query = query

    def run(self):
        try:
            results = DuckDuckGoSearcher.search_ddg(self.query, max_results=10)
            self.search_complete.emit(results)
        except Exception as e:
            self.search_error.emit(str(e))


class AppLoaderThread(QThread):
    apps_loaded = pyqtSignal(list)

    def __init__(self, search_term=""):
        super().__init__()
        self.search_term = search_term

    def run(self):
        try:
            if self.search_term:
                apps = AppDetector.suggest_applications(self.search_term)
            else:
                apps = AppDetector._load_applications_async()
            self.apps_loaded.emit(apps)
        except Exception as e:
            print(f"AppLoaderThread error: {e}")
            self.apps_loaded.emit([])


class IconLoaderThread(QThread):
    icon_loaded = pyqtSignal(str, str)

    def __init__(self, icon_name):
        super().__init__()
        self.icon_name = icon_name

    def run(self):
        try:
            icon_path = AppDetector.find_application_icon(self.icon_name)
            self.icon_loaded.emit(self.icon_name, icon_path)
        except:
            self.icon_loaded.emit(self.icon_name, None)


class CommandIconLoaderThread(QThread):
    icon_loaded = pyqtSignal(str, str)

    def __init__(self, command):
        super().__init__()
        self.command = command

    def run(self):
        try:
            icon_path = AppDetector.find_icon_for_command(self.command)
            self.icon_loaded.emit(self.command, icon_path)
        except:
            self.icon_loaded.emit(self.command, None)


class AutoStartManager:
    @staticmethod
    def get_autostart_dir():
        if sys.platform == 'win32':
            startup_dir = os.path.join(os.getenv('APPDATA'), 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')
        elif sys.platform == 'darwin':
            startup_dir = os.path.expanduser('~/Library/LaunchAgents')
        else:
            startup_dir = os.path.expanduser('~/.config/autostart')
        os.makedirs(startup_dir, exist_ok=True)
        return startup_dir

    @staticmethod
    def enable_autostart(app_name="FloatingMenu"):
        if sys.platform == 'win32':
            startup_dir = AutoStartManager.get_autostart_dir()
            shortcut_path = os.path.join(startup_dir, f"{app_name}.lnk")
            try:
                import winshell
                from win32com.client import Dispatch
                shell = Dispatch('WScript.Shell')
                shortcut = shell.CreateShortcut(shortcut_path)
                shortcut.Targetpath = sys.executable
                shortcut.Arguments = f'"{sys.argv[0]}"'
                shortcut.WorkingDirectory = os.path.dirname(sys.argv[0])
                shortcut.save()
                return True, shortcut_path
            except Exception as e:
                return False, str(e)
        elif sys.platform == 'darwin':
            startup_dir = AutoStartManager.get_autostart_dir()
            plist_path = os.path.join(startup_dir, f"com.{app_name.lower()}.plist")
            plist_content = f"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>Label</key>
<string>com.{app_name.lower()}</string>
<key>ProgramArguments</key>
<array>
<string>{sys.executable}</string>
<string>{sys.argv[0]}</string>
</array>
<key>RunAtLoad</key>
<true/>
</dict>
</plist>"""
            try:
                with open(plist_path, 'w') as f:
                    f.write(plist_content)
                return True, plist_path
            except Exception as e:
                return False, str(e)
        else:
            startup_dir = AutoStartManager.get_autostart_dir()
            desktop_path = os.path.join(startup_dir, f"{app_name}.desktop")
            script_path = os.path.abspath(sys.argv[0])
            desktop_content = f"""[Desktop Entry]
Type=Application
Name={app_name}
Exec={sys.executable} "{script_path}"
Terminal=false
Hidden=false
X-GNOME-Autostart-enabled=true
Comment=Floating Menu Launcher
Icon=application-x-executable
"""
            try:
                with open(desktop_path, 'w') as f:
                    f.write(desktop_content)
                os.chmod(desktop_path, 0o755)
                return True, desktop_path
            except Exception as e:
                return False, str(e)

    @staticmethod
    def disable_autostart(app_name="FloatingMenu"):
        if sys.platform == 'win32':
            startup_dir = AutoStartManager.get_autostart_dir()
            shortcut_path = os.path.join(startup_dir, f"{app_name}.lnk")
        elif sys.platform == 'darwin':
            startup_dir = AutoStartManager.get_autostart_dir()
            shortcut_path = os.path.join(startup_dir, f"com.{app_name.lower()}.plist")
        else:
            startup_dir = AutoStartManager.get_autostart_dir()
            shortcut_path = os.path.join(startup_dir, f"{app_name}.desktop")
        if os.path.exists(shortcut_path):
            try:
                os.remove(shortcut_path)
                return True, f"Removed: {shortcut_path}"
            except Exception as e:
                return False, str(e)
        return True, "No auto-start file found"

    @staticmethod
    def is_autostart_enabled(app_name="FloatingMenu"):
        if sys.platform == 'win32':
            startup_dir = AutoStartManager.get_autostart_dir()
            shortcut_path = os.path.join(startup_dir, f"{app_name}.lnk")
        elif sys.platform == 'darwin':
            startup_dir = AutoStartManager.get_autostart_dir()
            shortcut_path = os.path.join(startup_dir, f"com.{app_name.lower()}.plist")
        else:
            startup_dir = AutoStartManager.get_autostart_dir()
            shortcut_path = os.path.join(startup_dir, f"{app_name}.desktop")
        return os.path.exists(shortcut_path)


class ColorScheme:
    BACKGROUND = "#16161e"
    SURFACE = "#1a1b26"
    SURFACE_HOVER = "#24283b"
    ACCENT = "#7aa2f7"
    ACCENT_HOVER = "#bb9af7"
    TEXT_PRIMARY = "#c0caf5"
    TEXT_SECONDARY = "#a9b1d6"
    TEXT_MUTED = "#565f89"
    SUCCESS = "#9ece6a"
    WARNING = "#e0af68"
    ERROR = "#f7768e"
    CYAN = "#7dcfff"
    ORANGE = "#ff9e64"
    BORDER = "#414868"
    BORDER_HOVER = "#7aa2f7"
    GRADIENT_START = "#7aa2f7"
    GRADIENT_MID = "#bb9af7"
    GRADIENT_END = "#ff9e64"


class FastIconButton(QPushButton):
    def __init__(self, text="", command=None, app_info=None, color_scheme=None, parent=None):
        super().__init__(text, parent)
        self.color_scheme = color_scheme or ColorScheme()
        self.command = command
        self.app_info = app_info or {}
        self.setCursor(Qt.CursorShape.PointingHandCursor)
        self.setMinimumHeight(32)
        self.setup_style()
        if command:
            self.set_icon_by_command_async(command)
        elif app_info and app_info.get('Icon'):
            self.set_icon_async(app_info.get('Icon'))
        elif app_info and app_info.get('Exec'):
            self.set_icon_by_command_async(app_info.get('Exec'))
        else:
            self.set_fallback_icon()

    def setup_style(self):
        self.setStyleSheet(f"""
        QPushButton {{
            background-color: {self.color_scheme.SURFACE};
            color: {self.color_scheme.TEXT_PRIMARY};
            border: 1px solid {self.color_scheme.BORDER};
            border-radius: 6px;
            padding: 6px 10px 6px 35px;
            text-align: left;
            font-size: 11px;
            font-weight: 500;
            margin: 0px;
        }}
        QPushButton:hover {{
            background-color: {self.color_scheme.SURFACE_HOVER};
            border: 1px solid {self.color_scheme.BORDER_HOVER};
        }}
        QPushButton:pressed {{
            background-color: {self.color_scheme.ACCENT}20;
            border: 1px solid {self.color_scheme.ACCENT};
        }}
        """)

    def set_icon_by_command_async(self, command):
        self.command_icon_loader = CommandIconLoaderThread(command)
        self.command_icon_loader.icon_loaded.connect(self.on_command_icon_loaded)
        self.command_icon_loader.start()

    def set_icon_async(self, icon_name):
        if icon_name:
            self.icon_loader = IconLoaderThread(icon_name)
            self.icon_loader.icon_loaded.connect(self.on_icon_loaded)
            self.icon_loader.start()
        else:
            self.set_fallback_icon()

    def on_command_icon_loaded(self, command, icon_path):
        if icon_path and os.path.exists(icon_path):
            try:
                icon = QIcon(icon_path)
                if not icon.isNull():
                    self.setIcon(icon)
                    self.setIconSize(QSize(16, 16))
                    return
            except:
                pass
        self.set_fallback_icon()

    def on_icon_loaded(self, icon_name, icon_path):
        if icon_path and os.path.exists(icon_path):
            try:
                icon = QIcon(icon_path)
                if not icon.isNull():
                    self.setIcon(icon)
                    self.setIconSize(QSize(16, 16))
                    return
            except:
                pass
        self.set_fallback_icon()

    def set_fallback_icon(self):
        fallback_icon = QApplication.style().standardIcon(QStyle.StandardPixmap.SP_FileIcon)
        self.setIcon(fallback_icon)
        self.setIconSize(QSize(16, 16))


class FastAddDialog(QDialog):
    def __init__(self, color_scheme=None, parent=None):
        super().__init__(parent)
        self.color_scheme = color_scheme or ColorScheme()
        self.selected_app_info = None
        self.icon_loaders = []
        self.app_items = {}
        self.setWindowTitle("‚ûï Add Launcher")
        self.setFixedSize(600, 500)
        self.setup_ui()
        self.load_apps_async()

    def setup_ui(self):
        main_layout = QVBoxLayout()
        main_layout.setSpacing(8)
        main_layout.setContentsMargins(10, 10, 10, 10)

        header = QLabel("Add Application Launcher")
        header.setAlignment(Qt.AlignmentFlag.AlignCenter)
        header.setStyleSheet(f"""
        QLabel {{
            color: {self.color_scheme.ACCENT};
            font-size: 16px;
            font-weight: bold;
            padding: 12px;
            background-color: {self.color_scheme.SURFACE};
            border-radius: 8px;
            border: 1px solid {self.color_scheme.BORDER};
        }}
        """)
        main_layout.addWidget(header)

        search_layout = QHBoxLayout()
        search_layout.setSpacing(4)
        search_icon = QLabel("üîç")
        search_layout.addWidget(search_icon)
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Type app name to search...")
        self.search_edit.textChanged.connect(self.on_search_changed)
        search_layout.addWidget(self.search_edit)
        main_layout.addLayout(search_layout)

        self.apps_list = QListWidget()
        self.apps_list.setStyleSheet(f"""
        QListWidget {{
            background-color: {self.color_scheme.SURFACE};
            border: 1px solid {self.color_scheme.BORDER};
            border-radius: 8px;
        }}
        QListWidget::item {{
            padding: 8px;
            border-bottom: 1px solid {self.color_scheme.BORDER}30;
            color: {self.color_scheme.TEXT_PRIMARY};
            font-size: 12px;
        }}
        QListWidget::item:selected {{
            background-color: {self.color_scheme.ACCENT}40;
            color: {self.color_scheme.ACCENT};
        }}
        """)
        self.apps_list.itemDoubleClicked.connect(self.use_selected_app)
        self.loading_item = QListWidgetItem("üì¶ Loading applications...")
        self.loading_item.setForeground(QColor(self.color_scheme.TEXT_MUTED))
        self.apps_list.addItem(self.loading_item)
        main_layout.addWidget(self.apps_list)

        quick_label = QLabel("Quick add:")
        quick_label.setStyleSheet(f"color: {self.color_scheme.TEXT_SECONDARY}; font-weight: bold; margin-top: 5px; font-size: 12px;")
        main_layout.addWidget(quick_label)

        quick_grid = QGridLayout()
        quick_grid.setSpacing(4)
        common_apps = [
            ("Package Manager", "eco_pac", ""),
            ("System Monitor", "eco_sys", ""),
            ("Game Recorder", "eco_rec", ""),
            ("Lutris", "lutris", ""),
            ("Steam", "steam", ""),
            ("BrowserOS", "browseros", ""),
            ("Firefox", "firefox", ""),
            ("Rustdesk", "rustdesk", ""),
            ("Discord", "discord", ""),
            ("Obs-Studio", "obs", ""),
        ]
        for i, (name, cmd, icon) in enumerate(common_apps):
            row = i // 4
            col = i % 4
            btn = QPushButton(f"{name}")
            btn.setToolTip(f"Add {name} ({cmd})")
            btn.clicked.connect(lambda checked, n=name, c=cmd: self.add_quick_app(n, c))
            btn.setStyleSheet(f"""
            QPushButton {{
                background-color: {self.color_scheme.SURFACE};
                color: {self.color_scheme.TEXT_PRIMARY};
                border: 1px solid {self.color_scheme.BORDER};
                border-radius: 6px;
                padding: 6px;
                font-size: 10px;
            }}
            QPushButton:hover {{
                background-color: {self.color_scheme.SURFACE_HOVER};
                border: 1px solid {self.color_scheme.ACCENT};
            }}
            """)
            quick_grid.addWidget(btn, row, col)
        main_layout.addLayout(quick_grid)

        custom_label = QLabel("Custom command:")
        custom_label.setStyleSheet(f"color: {self.color_scheme.TEXT_SECONDARY}; font-weight: bold; margin-top: 5px; font-size: 12px;")
        main_layout.addWidget(custom_label)
        custom_layout = QHBoxLayout()
        custom_layout.setSpacing(4)
        self.custom_name = QLineEdit()
        self.custom_name.setPlaceholderText("Name")
        self.custom_name.setMinimumWidth(150)
        custom_layout.addWidget(self.custom_name)
        self.custom_cmd = QLineEdit()
        self.custom_cmd.setPlaceholderText("Command (e.g., firefox)")
        custom_layout.addWidget(self.custom_cmd)
        add_custom_btn = QPushButton("Add")
        add_custom_btn.clicked.connect(self.add_custom)
        add_custom_btn.setStyleSheet(f"""
        QPushButton {{
            background-color: {self.color_scheme.SUCCESS};
            color: {self.color_scheme.BACKGROUND};
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            font-weight: bold;
            font-size: 11px;
        }}
        QPushButton:hover {{ background-color: {self.color_scheme.SUCCESS}DD; }}
        """)
        custom_layout.addWidget(add_custom_btn)
        main_layout.addLayout(custom_layout)

        btn_layout = QHBoxLayout()
        btn_layout.setSpacing(8)
        use_btn = QPushButton("üíæ Use Selected")
        use_btn.clicked.connect(self.use_selected_app)
        use_btn.setStyleSheet(f"""
        QPushButton {{
            background-color: {self.color_scheme.SUCCESS};
            color: {self.color_scheme.BACKGROUND};
            border: none;
            border-radius: 8px;
            padding: 10px 15px;
            font-weight: bold;
            font-size: 12px;
        }}
        QPushButton:hover {{ background-color: {self.color_scheme.SUCCESS}DD; }}
        """)
        cancel_btn = QPushButton("‚úï Cancel")
        cancel_btn.clicked.connect(self.reject)
        cancel_btn.setStyleSheet(f"""
        QPushButton {{
            background-color: {self.color_scheme.ERROR};
            color: {self.color_scheme.BACKGROUND};
            border: none;
            border-radius: 8px;
            padding: 10px 15px;
            font-weight: bold;
            font-size: 12px;
        }}
        QPushButton:hover {{ background-color: {self.color_scheme.ERROR}DD; }}
        """)
        btn_layout.addWidget(use_btn)
        btn_layout.addStretch()
        btn_layout.addWidget(cancel_btn)
        main_layout.addLayout(btn_layout)

        self.setLayout(main_layout)
        self.setStyleSheet(f"QDialog {{ background-color: {self.color_scheme.BACKGROUND}; }}")

    def load_apps_async(self):
        self.app_loader = AppLoaderThread()
        self.app_loader.apps_loaded.connect(self.on_apps_loaded)
        self.app_loader.start()

    def on_apps_loaded(self, apps):
        if self.loading_item:
            self.apps_list.takeItem(0)
            self.loading_item = None
        self.app_items.clear()
        for app in apps:
            name = app.get('Name', 'Unknown')
            comment = app.get('Comment', '')
            item_text = f"{name}"
            if comment and len(comment) < 50:
                item_text += f" - {comment}"
            item = QListWidgetItem(item_text)
            item.setData(Qt.ItemDataRole.UserRole, app)
            self.app_items[name.lower()] = item
            icon_name = app.get('Icon', '')
            if icon_name:
                icon_loader = IconLoaderThread(icon_name)
                icon_loader.icon_loaded.connect(
                    lambda icon_name, icon_path, item=item: self.on_icon_loaded(item, icon_path)
                )
                icon_loader.start()
                self.icon_loaders.append(icon_loader)
            self.apps_list.addItem(item)
        if self.apps_list.count() == 0:
            self.apps_list.addItem("No applications found. Use custom command instead.")

    def on_icon_loaded(self, item, icon_path):
        if icon_path and os.path.exists(icon_path):
            try:
                icon = QIcon(icon_path)
                if not icon.isNull():
                    item.setIcon(icon)
            except:
                pass

    def on_search_changed(self, text):
        search_text = text.strip().lower()
        for i in range(self.apps_list.count()):
            item = self.apps_list.item(i)
            if item:
                item.setHidden(search_text not in item.text().lower())

    def add_quick_app(self, name, command):
        self.selected_app_info = {
            'Name': name,
            'Exec': command,
            'Icon': command if '/' not in command else os.path.basename(command).split('.')[0],
            'Categories': 'QuickAdd'
        }
        self.accept()

    def add_custom(self):
        command = self.custom_cmd.text().strip()
        name = self.custom_name.text().strip()
        if not command:
            QMessageBox.warning(self, "Missing Command", "Please enter a command")
            return
        if not name:
            name = os.path.basename(command).split('.')[0].replace('-', ' ').replace('_', ' ').title()
        self.selected_app_info = {
            'Name': name,
            'Exec': command,
            'Icon': command if '/' not in command else os.path.basename(command).split('.')[0],
            'Categories': 'Custom'
        }
        self.accept()

    def use_selected_app(self):
        selected = self.apps_list.selectedItems()
        if selected:
            item = selected[0]
            self.selected_app_info = item.data(Qt.ItemDataRole.UserRole)
            if self.selected_app_info:
                self.accept()
            else:
                QMessageBox.warning(self, "Invalid Selection", "Please select a valid application")
        else:
            QMessageBox.warning(self, "No Selection", "Please select an application or use custom command")

    def get_app_info(self):
        return self.selected_app_info

    def closeEvent(self, event):
        for loader in self.icon_loaders:
            if loader.isRunning():
                loader.terminate()
                loader.wait()
        super().closeEvent(event)


class SimpleVideoDialog(QDialog):
    def __init__(self, video_dir=None, color_scheme=None, parent=None):
        super().__init__(parent)
        self.color_scheme = color_scheme or ColorScheme()
        self.video_dir = video_dir or os.path.expanduser("~/Videos")
        self.setWindowTitle("üé¨ Videos")
        self.setFixedSize(500, 400)
        self.setup_ui()

    def setup_ui(self):
        layout = QVBoxLayout()
        layout.setSpacing(8)
        layout.setContentsMargins(10, 10, 10, 10)

        header = QLabel("üé¨ Video Player")
        header.setAlignment(Qt.AlignmentFlag.AlignCenter)
        header.setStyleSheet(f"""
        QLabel {{
            color: {self.color_scheme.ACCENT};
            font-size: 16px;
            font-weight: bold;
            padding: 12px;
            background-color: {self.color_scheme.SURFACE};
            border-radius: 8px;
            border: 1px solid {self.color_scheme.BORDER};
        }}
        """)
        layout.addWidget(header)

        self.video_list = QListWidget()
        self.video_list.setStyleSheet(f"""
        QListWidget {{
            background-color: {self.color_scheme.SURFACE};
            border: 1px solid {self.color_scheme.BORDER};
            border-radius: 8px;
        }}
        QListWidget::item {{
            padding: 8px;
            border-bottom: 1px solid {self.color_scheme.BORDER}30;
            color: {self.color_scheme.TEXT_PRIMARY};
            font-size: 12px;
        }}
        QListWidget::item:selected {{
            background-color: {self.color_scheme.ACCENT}40;
            color: {self.color_scheme.ACCENT};
        }}
        """)
        self.load_video_files()
        layout.addWidget(self.video_list)

        btn_layout = QHBoxLayout()
        btn_layout.setSpacing(10)
        play_btn = QPushButton("‚ñ∂Ô∏è Play with MPV")
        play_btn.setFixedHeight(40)
        play_btn.clicked.connect(self.play_video)
        self.style_button(play_btn, self.color_scheme.SUCCESS)
        refresh_btn = QPushButton("üîÑ Refresh")
        refresh_btn.setFixedHeight(40)
        refresh_btn.clicked.connect(self.load_video_files)
        self.style_button(refresh_btn, self.color_scheme.ACCENT)
        close_btn = QPushButton("‚úï Close")
        close_btn.setFixedHeight(40)
        close_btn.clicked.connect(self.reject)
        self.style_button(close_btn, self.color_scheme.ERROR)
        btn_layout.addWidget(play_btn)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        btn_layout.addWidget(close_btn)
        layout.addLayout(btn_layout)

        self.setLayout(layout)
        self.setStyleSheet(f"QDialog {{ background-color: {self.color_scheme.BACKGROUND}; }}")

    def style_button(self, button, color):
        button.setStyleSheet(f"""
        QPushButton {{
            background-color: {color};
            color: {self.color_scheme.BACKGROUND};
            border: none;
            border-radius: 8px;
            padding: 10px;
            font-size: 13px;
            font-weight: bold;
        }}
        QPushButton:hover {{ background-color: {color}DD; }}
        """)

    def load_video_files(self):
        self.video_list.clear()
        if not os.path.exists(self.video_dir):
            self.video_list.addItem("‚ö†Ô∏è Directory not found")
            return
        video_extensions = ['.mp4', '.mkv', '.avi', '.mov', '.webm', '.flv', '.wmv', '.m4v']
        video_files = []
        try:
            for file in os.listdir(self.video_dir):
                file_path = os.path.join(self.video_dir, file)
                if os.path.isfile(file_path) and any(file.lower().endswith(ext) for ext in video_extensions):
                    video_files.append(file_path)
        except:
            pass
        if not video_files:
            self.video_list.addItem("No video files found")
            return
        video_files.sort()
        for video_path in video_files:
            filename = os.path.basename(video_path)
            size = os.path.getsize(video_path)
            if size > 1024*1024*1024:
                size_str = f"{size/1024/1024/1024:.1f} GB"
            elif size > 1024*1024:
                size_str = f"{size/1024/1024:.1f} MB"
            else:
                size_str = f"{size/1024:.1f} KB"
            item = QListWidgetItem(f"üé¨ {filename} ({size_str})")
            item.setData(Qt.ItemDataRole.UserRole, video_path)
            self.video_list.addItem(item)

    def play_video(self):
        selected = self.video_list.selectedItems()
        if not selected:
            QMessageBox.warning(self, "No Selection", "Please select a video to play")
            return
        item = selected[0]
        video_path = item.data(Qt.ItemDataRole.UserRole)
        try:
            result = subprocess.run(['which', 'mpv'], capture_output=True, text=True)
            if result.returncode != 0:
                QMessageBox.warning(self, "MPV Not Found", "MPV is not installed.\nInstall: sudo pacman -S mpv")
                return
            subprocess.Popen(['mpv', video_path], start_new_session=True)
            self.accept()
        except Exception:
            QMessageBox.warning(self, "Error", "Failed to launch MPV")


class FloatingMenu(QMainWindow):
    def __init__(self):
        super().__init__()
        self.launchers = []
        self.color_scheme = ColorScheme()
        self.config_file = os.path.join(os.path.expanduser("~"), "Documents", "floating_menu_config.json")
        self.setup_window()
        self.setup_ui()
        self.apply_theme()
        self.load_config()
        if not os.path.exists(self.config_file):
            success, _ = AutoStartManager.enable_autostart()
            if success:
                print("Auto-start enabled for first launch")
            self.load_config()
        self.update_autostart_indicator()

    def setup_window(self):
        self.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.setFixedSize(225, 450)
        screen_geometry = QApplication.primaryScreen().geometry()
        self.move(screen_geometry.width() - self.width(), 47)
        self.dragging = False
        self.drag_position = QPoint()

    def setup_ui(self):
        central_widget = QWidget()
        central_widget.setObjectName("centralWidget")
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(6)

        title_bar = QWidget()
        title_bar.setFixedHeight(32)
        title_bar.setObjectName("titleBar")
        title_layout = QHBoxLayout(title_bar)
        title_layout.setContentsMargins(10, 0, 10, 0)
        title_layout.setSpacing(4)
        title_label = QLabel("üöÄ Smart Launcher")
        title_label.setStyleSheet(f"color: {self.color_scheme.ACCENT}; font-weight: bold; font-size: 12px;")
        title_layout.addWidget(title_label)
        title_layout.addStretch()
        self.settings_btn = self.create_control_button("‚öôÔ∏è", "Settings", self.color_scheme.ACCENT, 24)
        self.settings_btn.clicked.connect(self.show_settings)
        title_layout.addWidget(self.settings_btn)
        self.pin_btn = self.create_control_button("üìå", "Pin (Disabled)", self.color_scheme.TEXT_MUTED, 24)
        self.pin_btn.setCheckable(True)
        self.pin_btn.setChecked(False)
        self.pin_btn.setEnabled(False)
        self.pin_btn.clicked.connect(self.toggle_pin)
        title_layout.addWidget(self.pin_btn)
        self.close_btn = self.create_control_button("‚úï", "Close", self.color_scheme.ERROR, 24)
        self.close_btn.clicked.connect(self.close_window)
        title_layout.addWidget(self.close_btn)
        main_layout.addWidget(title_bar)

        search_layout = QHBoxLayout()
        search_layout.setSpacing(4)
        search_icon = QLabel("üîç")
        search_icon.setStyleSheet("font-size: 11px;")
        search_layout.addWidget(search_icon)
        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText("Search launchers or web (just press Enter!)")
        self.search_bar.setStyleSheet(f"""
        QLineEdit {{
            background-color: {self.color_scheme.SURFACE};
            color: {self.color_scheme.TEXT_PRIMARY};
            border: 1px solid {self.color_scheme.BORDER};
            border-radius: 6px;
            padding: 5px;
            font-size: 11px;
        }}
        """)
        self.search_bar.textChanged.connect(self.filter_launchers)
        self.search_bar.returnPressed.connect(self.handle_search_return_pressed)
        search_layout.addWidget(self.search_bar)
        self.ddg_btn = self.create_control_button("üåê", "Search DuckDuckGo", self.color_scheme.CYAN, 24)
        self.ddg_btn.clicked.connect(self.search_duckduckgo)
        search_layout.addWidget(self.ddg_btn)
        main_layout.addLayout(search_layout)

        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        scroll_area.setStyleSheet(f"""
        QScrollArea {{
            border: none;
            background: transparent;
        }}
        QScrollBar:vertical {{
            background: {self.color_scheme.SURFACE};
            width: 8px;
            border-radius: 4px;
        }}
        QScrollBar::handle:vertical {{
            background: {self.color_scheme.ACCENT};
            border-radius: 4px;
            min-height: 20px;
        }}
        """)
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)
        self.scroll_layout.setContentsMargins(0, 0, 2, 0)
        self.scroll_layout.setSpacing(2)
        self.scroll_layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        scroll_area.setWidget(self.scroll_content)
        main_layout.addWidget(scroll_area)

        bottom_layout = QHBoxLayout()
        bottom_layout.setSpacing(8)
        video_btn = QPushButton("üé¨ Videos")
        video_btn.setMinimumHeight(36)
        video_btn.clicked.connect(self.show_video_dialog)
        self.style_large_button(video_btn, self.color_scheme.CYAN)
        add_btn = QPushButton("‚ûï Add Fast")
        add_btn.setMinimumHeight(36)
        add_btn.clicked.connect(self.show_fast_add_dialog)
        self.style_large_button(add_btn, self.color_scheme.ACCENT)
        bottom_layout.addWidget(video_btn)
        bottom_layout.addWidget(add_btn)
        bottom_layout.addStretch()
        self.autostart_indicator = QLabel()
        self.update_autostart_indicator()
        bottom_layout.addWidget(self.autostart_indicator)
        main_layout.addLayout(bottom_layout)

        self.setup_tray_icon()

    def handle_search_return_pressed(self):
        """Intelligent Enter behavior: local launchers first, then DDG"""
        query = self.search_bar.text().strip()
        if not query:
            return

        # Try to match local launchers
        matches = []
        for launcher in self.launchers:
            name = launcher.get('name', '').lower()
            cmd = launcher.get('command', '').lower()
            if query.lower() in name or query.lower() in cmd:
                matches.append(launcher)

        if matches:
            self.launch_application(matches[0]['command'])
            self.search_bar.clear()
            return

        # No match ‚Üí search DuckDuckGo
        self.search_duckduckgo()

    def search_duckduckgo(self):
        search_text = self.search_bar.text().strip()
        if not search_text:
            QMessageBox.information(self, "Empty Search", "Please enter a search term")
            return
        # No prefix needed
        query = search_text
        self.search_bar.setPlaceholderText(f"Searching DuckDuckGo for: {query[:30]}...")
        self.search_bar.setEnabled(False)
        self.ddg_btn.setEnabled(False)
        self.search_thread = SearchThread(query)
        self.search_thread.search_complete.connect(self.on_search_complete)
        self.search_thread.search_error.connect(self.on_search_error)
        self.search_thread.start()

    def on_search_complete(self, results):
        self.search_bar.setPlaceholderText("Search launchers or web (just press Enter!)")
        self.search_bar.setEnabled(True)
        self.ddg_btn.setEnabled(True)
        if not results:
            QMessageBox.information(self, "No Results", "No search results found")
            return
        dialog = SearchResultsDialog(results, self.color_scheme, self)
        dialog.exec()

    def on_search_error(self, error_msg):
        self.search_bar.setPlaceholderText("Search launchers or web (just press Enter!)")
        self.search_bar.setEnabled(True)
        self.ddg_btn.setEnabled(True)
        QMessageBox.warning(self, "Search Error", f"Could not search DuckDuckGo:\n{error_msg}")

    def create_control_button(self, icon, tooltip, color, size=22):
        btn = QPushButton(icon)
        btn.setFixedSize(size, size)
        btn.setToolTip(tooltip)
        btn.setCursor(Qt.CursorShape.PointingHandCursor)
        btn.setStyleSheet(f"""
        QPushButton {{
            background-color: {color}30;
            color: {color};
            border: 1px solid {color}50;
            border-radius: 4px;
            font-size: 10px;
            padding: 0px;
        }}
        QPushButton:hover {{
            background-color: {color}60;
            border: 1px solid {color};
        }}
        """)
        return btn

    def style_large_button(self, button, color):
        button.setStyleSheet(f"""
        QPushButton {{
            background-color: {color};
            color: {self.color_scheme.BACKGROUND};
            border: none;
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 12px;
            font-weight: bold;
        }}
        QPushButton:hover {{ background-color: {color}DD; }}
        """)

    def apply_theme(self):
        self.setStyleSheet(f"""
        QMainWindow {{ background: transparent; }}
        #centralWidget {{
            background-color: {self.color_scheme.BACKGROUND};
            border: 1px solid {self.color_scheme.BORDER};
            border-radius: 12px;
        }}
        #titleBar {{
            background-color: {self.color_scheme.SURFACE};
            border-radius: 10px 10px 0 0;
        }}
        """)

    def update_autostart_indicator(self):
        if AutoStartManager.is_autostart_enabled():
            self.autostart_indicator.setText("üîó")
            self.autostart_indicator.setToolTip("Auto-start enabled")
            self.autostart_indicator.setStyleSheet(f"color: {self.color_scheme.SUCCESS}; font-size: 14px;")
        else:
            self.autostart_indicator.setText("")
            self.autostart_indicator.setToolTip("Auto-start disabled")

    def setup_tray_icon(self):
        self.tray_icon = QSystemTrayIcon(self)
        pixmap = QPixmap(24, 24)
        pixmap.fill(Qt.GlobalColor.transparent)
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        painter.setBrush(QBrush(QColor(self.color_scheme.ACCENT)))
        painter.setPen(Qt.PenStyle.NoPen)
        painter.drawEllipse(2, 2, 20, 20)
        painter.end()
        self.tray_icon.setIcon(QIcon(pixmap))
        tray_menu = QMenu()
        show_action = tray_menu.addAction("Show Menu")
        show_action.triggered.connect(self.show_menu)
        add_action = tray_menu.addAction("Add Fast Launcher")
        add_action.triggered.connect(self.show_fast_add_dialog)
        video_action = tray_menu.addAction("Videos")
        video_action.triggered.connect(self.show_video_dialog)
        tray_menu.addSeparator()
        self.autostart_action = tray_menu.addAction("Auto-start on Login")
        self.autostart_action.setCheckable(True)
        self.autostart_action.setChecked(AutoStartManager.is_autostart_enabled())
        self.autostart_action.triggered.connect(self.toggle_autostart)
        tray_menu.addSeparator()
        quit_action = tray_menu.addAction("Quit")
        quit_action.triggered.connect(self.quit_application)
        self.tray_icon.setContextMenu(tray_menu)
        self.tray_icon.show()
        self.tray_icon.activated.connect(self.tray_icon_activated)

    def toggle_autostart(self, checked):
        if checked:
            success, message = AutoStartManager.enable_autostart()
            if success:
                self.tray_icon.showMessage("Auto-start", "Enabled", QSystemTrayIcon.MessageIcon.Information, 1500)
            else:
                self.autostart_action.setChecked(False)
        else:
            success, message = AutoStartManager.disable_autostart()
            if success:
                self.tray_icon.showMessage("Auto-start", "Disabled", QSystemTrayIcon.MessageIcon.Information, 1500)
            else:
                self.autostart_action.setChecked(True)
        self.update_autostart_indicator()

    def show_fast_add_dialog(self):
        dialog = FastAddDialog(color_scheme=self.color_scheme, parent=self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            app_info = dialog.get_app_info()
            if app_info:
                self.add_launcher_from_app_info(app_info)

    def add_launcher_from_app_info(self, app_info):
        name = app_info.get('Name', '').strip()
        command = app_info.get('Exec', '').strip()
        icon = app_info.get('Icon', '').strip()
        if not name or not command:
            return
        for launcher in self.launchers:
            if launcher.get('name') == name or launcher.get('command') == command:
                QMessageBox.information(self, "Already Exists", f"Launcher '{name}' already exists")
                return
        self.launchers.append({
            "name": name,
            "command": command,
            "icon": icon,
            "app_info": app_info
        })
        self.save_config()
        self.refresh_launchers()
        self.tray_icon.showMessage("Launcher Added", f"Added '{name}' to your launchers", QSystemTrayIcon.MessageIcon.Information, 2000)

    def show_video_dialog(self):
        dialog = SimpleVideoDialog(color_scheme=self.color_scheme, parent=self)
        dialog.exec()

    def show_settings(self):
        menu = QMenu(self)
        pin_action = menu.addAction("Always on Top (Disabled)")
        pin_action.setEnabled(False)
        pin_action.setCheckable(True)
        pin_action.setChecked(False)
        menu.addSeparator()
        autostart_action = menu.addAction("Auto-start on Login")
        autostart_action.setCheckable(True)
        autostart_action.setChecked(AutoStartManager.is_autostart_enabled())
        autostart_action.triggered.connect(self.toggle_autostart)
        menu.addSeparator()
        edit_action = menu.addAction("Edit Launchers")
        edit_action.triggered.connect(self.edit_launchers)
        refresh_action = menu.addAction("üîÑ Refresh System Apps")
        refresh_action.triggered.connect(self.refresh_system_apps_cache)
        menu.addSeparator()
        close_action = menu.addAction("Close Window")
        close_action.triggered.connect(self.close_window)
        menu.exec(self.mapToGlobal(QPoint(self.width() - 150, 30)))

    def refresh_system_apps_cache(self):
        AppDetector.refresh_cache()
        QMessageBox.information(self, "Cache Refreshed", "System applications cache has been refreshed.")

    def toggle_pin(self, checked=None):
        self.pin_btn.setChecked(False)
        current_flags = self.windowFlags()
        if current_flags & Qt.WindowType.WindowStaysOnTopHint:
            self.setWindowFlags(current_flags & ~Qt.WindowType.WindowStaysOnTopHint)
            self.show()
        self.tray_icon.showMessage("Always on Top", "This feature is disabled - other windows will take precedence", QSystemTrayIcon.MessageIcon.Information, 1500)

    def close_window(self):
        reply = QMessageBox.question(self, 'Close Menu', "Close the menu?", QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if reply == QMessageBox.StandardButton.Yes:
            self.save_config()
            QApplication.quit()

    def edit_launchers(self):
        dialog = QDialog(self)
        dialog.setWindowTitle("Edit Launchers")
        dialog.setFixedSize(400, 350)
        layout = QVBoxLayout()
        list_widget = QListWidget()
        for launcher in self.launchers:
            item_text = f"{launcher.get('name', 'Unknown')}"
            icon_path = AppDetector.find_icon_for_command(launcher.get('command', ''))
            if icon_path:
                icon = QIcon(icon_path)
                if not icon.isNull():
                    item = QListWidgetItem(icon, item_text)
                    list_widget.addItem(item)
                    continue
            list_widget.addItem(QListWidgetItem(item_text))
        layout.addWidget(list_widget)
        btn_layout = QHBoxLayout()
        delete_btn = QPushButton("üóëÔ∏è Delete")
        delete_btn.setMinimumHeight(35)
        delete_btn.clicked.connect(lambda: self.delete_launcher(list_widget))
        self.style_large_button(delete_btn, self.color_scheme.ERROR)
        close_btn = QPushButton("‚úÖ Done")
        close_btn.setMinimumHeight(35)
        close_btn.clicked.connect(dialog.accept)
        self.style_large_button(close_btn, self.color_scheme.SUCCESS)
        btn_layout.addWidget(delete_btn)
        btn_layout.addWidget(close_btn)
        layout.addLayout(btn_layout)
        dialog.setLayout(layout)
        dialog.exec()

    def delete_launcher(self, list_widget):
        selected = list_widget.selectedItems()
        if selected:
            index = list_widget.row(selected[0])
            launcher_name = self.launchers[index].get('name', 'Unknown')
            reply = QMessageBox.question(self, 'Delete Launcher', f"Delete '{launcher_name}'?", QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
            if reply == QMessageBox.StandardButton.Yes:
                del self.launchers[index]
                self.save_config()
                self.refresh_launchers()
                list_widget.takeItem(index)

    def refresh_launchers(self):
        # Clear existing buttons
        while self.scroll_layout.count():
            child = self.scroll_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
        # Add updated launchers
        for launcher in self.launchers:
            btn = FastIconButton(
                text=f"  {launcher.get('name', '')}",
                command=launcher.get('command', ''),
                app_info=launcher.get('app_info', {}),
                color_scheme=self.color_scheme,
                parent=self
            )
            btn.clicked.connect(lambda checked, cmd=launcher.get('command', ''): self.launch_application(cmd))
            btn.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            btn.customContextMenuRequested.connect(
                lambda pos, l=launcher: self.show_launcher_context_menu(btn, l, pos)
            )
            self.scroll_layout.addWidget(btn)

    def show_launcher_context_menu(self, button, launcher, pos):
        menu = QMenu(self)
        edit_action = menu.addAction("‚úèÔ∏è Edit")
        edit_action.triggered.connect(lambda: self.edit_single_launcher(launcher))
        delete_action = menu.addAction("üóëÔ∏è Delete")
        delete_action.triggered.connect(lambda: self.delete_single_launcher(launcher))
        menu.addSeparator()
        run_action = menu.addAction("üöÄ Run")
        run_action.triggered.connect(lambda: self.launch_application(launcher.get('command', '')))
        menu.exec(button.mapToGlobal(pos))

    def edit_single_launcher(self, launcher):
        dialog = FastAddDialog(color_scheme=self.color_scheme, parent=self)
        dialog.custom_name.setText(launcher.get('name', ''))
        dialog.custom_cmd.setText(launcher.get('command', ''))
        if dialog.exec() == QDialog.DialogCode.Accepted:
            app_info = dialog.get_app_info()
            if app_info:
                index = self.launchers.index(launcher)
                self.launchers[index] = {
                    "name": app_info.get('Name', ''),
                    "command": app_info.get('Exec', ''),
                    "icon": app_info.get('Icon', ''),
                    "app_info": app_info
                }
                self.save_config()
                self.refresh_launchers()

    def delete_single_launcher(self, launcher):
        reply = QMessageBox.question(self, 'Delete Launcher', f"Delete '{launcher.get('name', 'Unknown')}'?", QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if reply == QMessageBox.StandardButton.Yes:
            self.launchers.remove(launcher)
            self.save_config()
            self.refresh_launchers()

    def launch_application(self, command):
        try:
            if command:
                subprocess.Popen(command, shell=True, start_new_session=True)
        except Exception as e:
            QMessageBox.warning(self, "Launch Error", f"Failed to launch application:\n{str(e)}")

    def filter_launchers(self, text):
        text_lower = text.lower()
        for i in range(self.scroll_layout.count()):
            widget = self.scroll_layout.itemAt(i).widget()
            if isinstance(widget, FastIconButton):
                widget.setVisible(text_lower in widget.text().lower())

    def save_config(self):
        try:
            launchers_to_save = []
            for launcher in self.launchers:
                launcher_copy = launcher.copy()
                launcher_copy.pop('app_info', None)  # Don't save large app_info dict
                launchers_to_save.append(launcher_copy)
            with open(self.config_file, 'w') as f:
                json.dump(launchers_to_save, f, indent=2)
        except Exception as e:
            print(f"Save config error: {e}")

    def load_config(self):
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f:
                    loaded_launchers = json.load(f)
                for launcher in loaded_launchers:
                    if launcher.get('command'):
                        system_apps = AppDetector.get_system_applications()
                        for app in system_apps:
                            if app.get('Exec') == launcher.get('command'):
                                launcher['app_info'] = app
                                break
                self.launchers = loaded_launchers
            else:
                self.create_intelligent_defaults()
                self.save_config()
            self.refresh_launchers()
        except Exception as e:
            print(f"Load config error: {e}")
            self.create_intelligent_defaults()

    def create_intelligent_defaults(self):
        self.launchers = []
        quick_defaults = [
            ("Package Manager", "eco_pac", ""),
            ("System Monitor", "eco_sys", ""),
            ("Game Recorder", "eco_rec", ""),
            ("Lutris", "lutris", ""),
            ("Steam", "steam", ""),
            ("BrowserOS", "browseros", ""),
            ("Firefox", "firefox", ""),
            ("Rustdesk", "rustdesk", ""),
            ("Discord", "discord", ""),
            ("Obs-Studio", "obs", ""),
        ]
        for name, command, icon in quick_defaults:
            self.launchers.append({
                "name": name,
                "command": command,
                "icon": icon,
                "app_info": {
                    'Name': name,
                    'Exec': command,
                    'Icon': icon,
                    'Categories': 'Default'
                }
            })

    def show_menu(self):
        self.show()
        self.raise_()
        self.activateWindow()

    def tray_icon_activated(self, reason):
        if reason == QSystemTrayIcon.ActivationReason.Trigger:
            self.show_menu()

    def quit_application(self):
        self.save_config()
        self.tray_icon.hide()
        QApplication.quit()

    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton and event.pos().y() < 40:
            self.dragging = True
            self.drag_position = event.globalPosition().toPoint() - self.frameGeometry().topLeft()

    def mouseMoveEvent(self, event):
        if self.dragging and event.buttons() & Qt.MouseButton.LeftButton:
            self.move(event.globalPosition().toPoint() - self.drag_position)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self.dragging = False


def main():
    app = QApplication(sys.argv)
    app.setQuitOnLastWindowClosed(False)
    app.setApplicationName("Smart Floating Menu")
    window = FloatingMenu()
    window.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()