#!/usr/bin/env python3
import sys
import json
import os
import subprocess
import re
import threading
from concurrent.futures import ThreadPoolExecutor
from pathlib import Path
from PyQt6.QtWidgets import *
from PyQt6.QtCore import *
from PyQt6.QtGui import *

# Suppress DBus warnings
os.environ['QT_LOGGING_RULES'] = 'qt.qpa.theme.gnome=false'

class AppDetector:
    """Intelligent application detector for Linux systems with caching"""
    
    # Caches
    _cached_apps = None
    _cached_apps_by_category = None
    _cached_icons = {}
    _cache_lock = threading.Lock()
    _icon_cache_lock = threading.Lock()
    
    @staticmethod
    def get_system_applications():
        """Get all installed applications with caching"""
        with AppDetector._cache_lock:
            if AppDetector._cached_apps is not None:
                return AppDetector._cached_apps.copy()
        
        # Start async loading and return empty list
        threading.Thread(target=AppDetector._load_applications_async, daemon=True).start()
        return []
    
    @staticmethod
    def _load_applications_async():
        """Load applications in background thread"""
        apps = []
        seen_execs = set()  # Avoid duplicates
        
        # Common application directories in priority order
        app_dirs = [
            '/usr/share/applications',
            '/usr/local/share/applications',
            os.path.expanduser('~/.local/share/applications'),
            '/var/lib/snapd/desktop/applications'
        ]
        
        # Use ThreadPoolExecutor for parallel parsing
        with ThreadPoolExecutor(max_workers=4) as executor:
            future_to_file = {}
            
            for app_dir in app_dirs:
                if not os.path.exists(app_dir):
                    continue
                
                try:
                    desktop_files = []
                    # Get all .desktop files
                    for root, dirs, files in os.walk(app_dir):
                        for file in files:
                            if file.endswith('.desktop'):
                                desktop_files.append(os.path.join(root, file))
                        
                        # Limit depth for speed
                        if root.count(os.sep) - app_dir.count(os.sep) > 2:
                            dirs[:] = []
                except:
                    continue
                
                # Limit to 200 files per directory for speed
                for file_path in desktop_files[:200]:
                    future = executor.submit(AppDetector.parse_desktop_file_fast, file_path)
                    future_to_file[future] = file_path
            
            # Collect results
            for future in future_to_file:
                try:
                    app_info = future.result(timeout=1)
                    if app_info and app_info.get('Exec'):
                        exec_cmd = app_info.get('Exec', '')
                        if exec_cmd not in seen_execs:
                            seen_execs.add(exec_cmd)
                            apps.append(app_info)
                except:
                    continue
        
        # Sort and cache
        apps.sort(key=lambda x: x.get('Name', '').lower())
        
        with AppDetector._cache_lock:
            AppDetector._cached_apps = apps[:300]  # Cache up to 300 apps
        
        return apps[:300]
    
    @staticmethod
    def parse_desktop_file_fast(file_path):
        """Fast .desktop file parser"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read(2048)  # Read only first 2KB
            
            app_info = {'desktop_file': file_path}
            in_desktop_entry = False
            lines_processed = 0
            
            for line in content.split('\n'):
                lines_processed += 1
                if lines_processed > 50:  # Only parse first 50 lines
                    break
                
                line = line.strip()
                
                if line == '[Desktop Entry]':
                    in_desktop_entry = True
                    continue
                elif line.startswith('['):
                    in_desktop_entry = False
                    continue
                
                if not in_desktop_entry:
                    continue
                
                if '=' in line:
                    key, value = line.split('=', 1)
                    
                    # Quick filters
                    if key == 'NoDisplay' and value == 'true':
                        return None
                    if key == 'Hidden' and value == 'true':
                        return None
                    if key == 'Terminal' and value == 'true':
                        return None  # Skip terminal-only apps
                    
                    if key in ['Name', 'Exec', 'Icon', 'Categories']:
                        # Clean Exec command
                        if key == 'Exec':
                            value = AppDetector.clean_exec_command_fast(value)
                            if not value:
                                return None
                        
                        app_info[key] = value
            
            # Must have Name and Exec
            if not app_info.get('Name') or not app_info.get('Exec'):
                return None
            
            return app_info
        except:
            return None
    
    @staticmethod
    def clean_exec_command_fast(exec_cmd):
        """Fast exec command cleaner"""
        # Remove common flags and arguments
        exec_cmd = re.sub(r'%[a-zA-Z]', '', exec_cmd)
        exec_cmd = exec_cmd.strip()
        
        # Extract the base command
        parts = exec_cmd.split()
        if parts:
            base_cmd = parts[0].strip('"\'')
            return base_cmd
        return ''
    
    @staticmethod
    def find_application_icon(icon_name):
        """Find application icon with proper Linux icon lookup"""
        if not icon_name:
            return None
        
        # Check cache first
        with AppDetector._icon_cache_lock:
            if icon_name in AppDetector._cached_icons:
                cached_path = AppDetector._cached_icons[icon_name]
                if cached_path and os.path.exists(cached_path):
                    return cached_path
                elif cached_path is None:  # Already tried and failed
                    return None
        
        icon_path = None
        
        # If icon_name is an absolute path, check it directly
        if os.path.isabs(icon_name):
            # Try with and without extensions
            for ext in ['', '.png', '.svg', '.xpm', '.jpg']:
                test_path = icon_name + ext if not icon_name.endswith(ext) else icon_name
                if os.path.exists(test_path):
                    icon_path = test_path
                    break
        else:
            # It's an icon name - search in standard directories
            icon_path = AppDetector._search_icon_by_name(icon_name)
        
        # Update cache
        with AppDetector._icon_cache_lock:
            AppDetector._cached_icons[icon_name] = icon_path
        
        return icon_path

    @staticmethod
    def _search_icon_by_name(icon_name):
        """Search for icon in standard XDG directories"""
        # Common icon directories in priority order [citation:1]
        icon_dirs = [
            '/usr/share/pixmaps',
            '/usr/share/icons/hicolor/48x48/apps',
            '/usr/share/icons/hicolor/32x32/apps',
            '/usr/share/icons/hicolor/64x64/apps',
            '/usr/share/icons/hicolor/scalable/apps',
            '/usr/share/icons/Adwaita/48x48/apps',
            '/usr/share/icons/Adwaita/scalable/apps',
            '/usr/share/icons/gnome/48x48/apps',
            '/usr/share/icons/breeze/apps/48',
            '/usr/share/icons/oxygen/48x48/apps',
            os.path.expanduser('~/.local/share/icons/hicolor/48x48/apps'),
            os.path.expanduser('~/.local/share/icons'),
            '/var/lib/flatpak/exports/share/icons/hicolor/48x48/apps',
            '/snap/snapd-desktop-integration/current/usr/share/icons/hicolor/48x48/apps'
        ]
        
        icon_extensions = ['.png', '.svg', '.xpm', '.jpg', '']
        
        for icon_dir in icon_dirs:
            if not os.path.exists(icon_dir):
                continue
            
            for ext in icon_extensions:
                # Try different filename patterns
                patterns = [
                    os.path.join(icon_dir, icon_name + ext),
                    os.path.join(icon_dir, icon_name.lower() + ext),
                    os.path.join(icon_dir, icon_name + ext.lower())
                ]
                
                for icon_path in patterns:
                    if os.path.exists(icon_path):
                        return icon_path
        
        return None  # Icon not found
    
    @staticmethod
    def _find_icon_in_dirs(icon_name):
        """Search for icon in common directories"""
        icon_dirs = [
            '/usr/share/pixmaps',  # Fastest check
            '/usr/share/icons/hicolor/48x48/apps',
            '/usr/share/icons/hicolor/scalable/apps',
            '/usr/share/icons/Adwaita/48x48/apps',
            '/usr/share/icons/Adwaita/scalable/apps',
            os.path.expanduser('~/.local/share/icons'),
        ]
        
        icon_extensions = ['.png', '.svg', '.xpm']
        
        # If icon_name contains path, check it directly
        if '/' in icon_name:
            for ext in icon_extensions + ['']:
                if os.path.exists(icon_name + ext):
                    return icon_name + ext
        
        # Search in common directories
        for icon_dir in icon_dirs:
            if not os.path.exists(icon_dir):
                continue
            
            # Check directly for filename with extensions
            for ext in icon_extensions:
                icon_path = os.path.join(icon_dir, icon_name + ext)
                if os.path.exists(icon_path):
                    return icon_path
            
            # Check for .desktop files (snaps)
            icon_path = os.path.join(icon_dir, icon_name + '.desktop')
            if os.path.exists(icon_path):
                return icon_path
        
        return None
    
    @staticmethod
    def suggest_applications(search_term):
        """Suggest applications based on search term - optimized"""
        apps = AppDetector.get_system_applications()
        suggestions = []
        
        search_lower = search_term.lower()
        
        for app in apps:
            name = app.get('Name', '').lower()
            exec_cmd = app.get('Exec', '').lower()
            
            # Fast checks in order of likelihood
            if search_lower in name:
                suggestions.append(app)
            elif search_lower in exec_cmd:
                suggestions.append(app)
            
            if len(suggestions) >= 15:  # Limit results
                break
        
        return suggestions
    
    @staticmethod
    def refresh_cache():
        """Clear cache for refresh"""
        with AppDetector._cache_lock:
            AppDetector._cached_apps = None
            AppDetector._cached_apps_by_category = None
        
        with AppDetector._icon_cache_lock:
            AppDetector._cached_icons.clear()

class AppLoaderThread(QThread):
    """Thread for loading applications in background"""
    apps_loaded = pyqtSignal(list)
    
    def __init__(self, search_term=""):
        super().__init__()
        self.search_term = search_term
    
    def run(self):
        try:
            if self.search_term:
                apps = AppDetector.suggest_applications(self.search_term)
            else:
                apps = AppDetector._load_applications_async()
            
            self.apps_loaded.emit(apps)
        except Exception as e:
            print(f"AppLoaderThread error: {e}")
            self.apps_loaded.emit([])

class IconLoaderThread(QThread):
    """Thread for loading icons in background"""
    icon_loaded = pyqtSignal(str, str)  # icon_name, icon_path
    
    def __init__(self, icon_name):
        super().__init__()
        self.icon_name = icon_name
    
    def run(self):
        try:
            icon_path = AppDetector.find_application_icon(self.icon_name)
            self.icon_loaded.emit(self.icon_name, icon_path)
        except:
            self.icon_loaded.emit(self.icon_name, None)

class AutoStartManager:
    """Handle auto-start functionality for the menu program"""
    
    @staticmethod
    def get_autostart_dir():
        """Get the autostart directory path - fixed for XFCE4"""
        if sys.platform == 'win32':
            startup_dir = os.path.join(os.getenv('APPDATA'), 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')
        elif sys.platform == 'darwin':
            startup_dir = os.path.expanduser('~/Library/LaunchAgents')
        else:
            # XFCE4 uses ~/.config/autostart (same as GNOME)
            startup_dir = os.path.expanduser('~/.config/autostart')
            os.makedirs(startup_dir, exist_ok=True)
        return startup_dir
    
    @staticmethod
    def enable_autostart(app_name="FloatingMenu"):
        """Enable auto-start for the menu program"""
        if sys.platform == 'win32':
            startup_dir = AutoStartManager.get_autostart_dir()
            shortcut_path = os.path.join(startup_dir, f"{app_name}.lnk")
            try:
                import winshell
                from win32com.client import Dispatch
                shell = Dispatch('WScript.Shell')
                shortcut = shell.CreateShortcut(shortcut_path)
                shortcut.Targetpath = sys.executable
                shortcut.Arguments = f'"{sys.argv[0]}"'
                shortcut.WorkingDirectory = os.path.dirname(sys.argv[0])
                shortcut.save()
                return True, shortcut_path
            except Exception as e:
                return False, str(e)
        
        elif sys.platform == 'darwin':
            startup_dir = AutoStartManager.get_autostart_dir()
            plist_path = os.path.join(startup_dir, f"com.{app_name.lower()}.plist")
            plist_content = f"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.{app_name.lower()}</string>
    <key>ProgramArguments</key>
    <array>
        <string>{sys.executable}</string>
        <string>{sys.argv[0]}</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
</dict>
</plist>"""
            try:
                with open(plist_path, 'w') as f:
                    f.write(plist_content)
                return True, plist_path
            except Exception as e:
                return False, str(e)
        
        else:
            # Linux: Create .desktop file
            startup_dir = AutoStartManager.get_autostart_dir()
            desktop_path = os.path.join(startup_dir, f"{app_name}.desktop")
            
            script_path = os.path.abspath(sys.argv[0])
            
            desktop_content = f"""[Desktop Entry]
Type=Application
Name={app_name}
Exec={sys.executable} "{script_path}"
Terminal=false
Hidden=false
X-GNOME-Autostart-enabled=true
Comment=Floating Menu Launcher
Icon=application-x-executable
"""
            
            try:
                with open(desktop_path, 'w') as f:
                    f.write(desktop_content)
                os.chmod(desktop_path, 0o755)
                return True, desktop_path
            except Exception as e:
                return False, str(e)
    
    @staticmethod
    def disable_autostart(app_name="FloatingMenu"):
        """Disable auto-start for the menu program"""
        if sys.platform == 'win32':
            startup_dir = AutoStartManager.get_autostart_dir()
            shortcut_path = os.path.join(startup_dir, f"{app_name}.lnk")
        elif sys.platform == 'darwin':
            startup_dir = AutoStartManager.get_autostart_dir()
            shortcut_path = os.path.join(startup_dir, f"com.{app_name.lower()}.plist")
        else:
            startup_dir = AutoStartManager.get_autostart_dir()
            shortcut_path = os.path.join(startup_dir, f"{app_name}.desktop")
        
        if os.path.exists(shortcut_path):
            try:
                os.remove(shortcut_path)
                return True, f"Removed: {shortcut_path}"
            except Exception as e:
                return False, str(e)
        return True, "No auto-start file found"
    
    @staticmethod
    def is_autostart_enabled(app_name="FloatingMenu"):
        """Check if auto-start is enabled for the menu program"""
        if sys.platform == 'win32':
            startup_dir = AutoStartManager.get_autostart_dir()
            shortcut_path = os.path.join(startup_dir, f"{app_name}.lnk")
        elif sys.platform == 'darwin':
            startup_dir = AutoStartManager.get_autostart_dir()
            shortcut_path = os.path.join(startup_dir, f"com.{app_name.lower()}.plist")
        else:
            startup_dir = AutoStartManager.get_autostart_dir()
            shortcut_path = os.path.join(startup_dir, f"{app_name}.desktop")
        
        return os.path.exists(shortcut_path)

class ColorScheme:
    BACKGROUND = "#16161e"
    SURFACE = "#1a1b26"
    SURFACE_HOVER = "#24283b"
    ACCENT = "#7aa2f7"
    ACCENT_HOVER = "#bb9af7"
    TEXT_PRIMARY = "#c0caf5"
    TEXT_SECONDARY = "#a9b1d6"
    TEXT_MUTED = "#565f89"
    SUCCESS = "#9ece6a"
    WARNING = "#e0af68"
    ERROR = "#f7768e"
    CYAN = "#7dcfff"
    ORANGE = "#ff9e64"
    BORDER = "#414868"
    BORDER_HOVER = "#7aa2f7"
    GRADIENT_START = "#7aa2f7"
    GRADIENT_MID = "#bb9af7"
    GRADIENT_END = "#ff9e64"

class FastIconButton(QPushButton):
    """Fast loading button with async icon"""
    
    def __init__(self, text="", app_info=None, color_scheme=None, parent=None):
        super().__init__(text, parent)
        self.color_scheme = color_scheme or ColorScheme()
        self.app_info = app_info or {}
        self.setCursor(Qt.CursorShape.PointingHandCursor)
        self.setMinimumHeight(32)
        self.setup_style()
        
        # Load icon async
        if app_info:
            self.set_icon_async(app_info.get('Icon', ''))
    
    def setup_style(self):
        self.setStyleSheet(f"""
            QPushButton {{
                background-color: {self.color_scheme.SURFACE};
                color: {self.color_scheme.TEXT_PRIMARY};
                border: 1px solid {self.color_scheme.BORDER};
                border-radius: 6px;
                padding: 6px 10px 6px 35px;
                text-align: left;
                font-size: 11px;
                font-weight: 500;
                margin: 0px;
            }}
            QPushButton:hover {{
                background-color: {self.color_scheme.SURFACE_HOVER};
                border: 1px solid {self.color_scheme.BORDER_HOVER};
            }}
            QPushButton:pressed {{
                background-color: {self.color_scheme.ACCENT}20;
                border: 1px solid {self.color_scheme.ACCENT};
            }}
        """)
    
    def set_icon_async(self, icon_name):
        """Set icon in background thread with fallback"""
        if icon_name:
            self.icon_loader = IconLoaderThread(icon_name)
            self.icon_loader.icon_loaded.connect(self.on_icon_loaded)
            self.icon_loader.start()
        else:
            # Use a fallback icon if no icon name is provided
            self.set_fallback_icon()

    def on_icon_loaded(self, icon_name, icon_path):
        """Callback when icon is loaded"""
        if icon_path and os.path.exists(icon_path):
            try:
                icon = QIcon(icon_path)
                if not icon.isNull():
                    self.setIcon(icon)
                    self.setIconSize(QSize(16, 16))
                    return
            except:
                pass
        
        # If we reach here, icon loading failed
        self.set_fallback_icon()

    def set_fallback_icon(self):
        """Set a fallback icon when the application icon can't be found"""
        # You can use Qt's standard icons or a custom fallback
        fallback_icon = QApplication.style().standardIcon(QStyle.StandardPixmap.SP_FileIcon)
        self.setIcon(fallback_icon)
        self.setIconSize(QSize(16, 16))

class FastAddDialog(QDialog):
    """Fast loading add dialog with threading"""
    
    def __init__(self, color_scheme=None, parent=None):
        super().__init__(parent)
        self.color_scheme = color_scheme or ColorScheme()
        self.selected_app_info = None
        self.icon_loaders = []
        self.app_items = {}  # Map app names to list items
        self.setWindowTitle("‚ûï Add Launcher")
        self.setFixedSize(600, 500)
        self.setup_ui()
        
        # Start loading apps immediately
        self.load_apps_async()
    
    def setup_ui(self):
        main_layout = QVBoxLayout()
        main_layout.setSpacing(8)
        main_layout.setContentsMargins(10, 10, 10, 10)
        
        # Header
        header = QLabel("Add Application Launcher")
        header.setAlignment(Qt.AlignmentFlag.AlignCenter)
        header.setStyleSheet(f"""
            QLabel {{
                color: {self.color_scheme.ACCENT};
                font-size: 16px;
                font-weight: bold;
                padding: 12px;
                background-color: {self.color_scheme.SURFACE};
                border-radius: 8px;
                border: 1px solid {self.color_scheme.BORDER};
            }}
        """)
        main_layout.addWidget(header)
        
        # Search bar
        search_layout = QHBoxLayout()
        search_layout.setSpacing(4)
        
        search_icon = QLabel("üîç")
        search_layout.addWidget(search_icon)
        
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Type app name to search...")
        self.search_edit.textChanged.connect(self.on_search_changed)
        search_layout.addWidget(self.search_edit)
        
        main_layout.addLayout(search_layout)
        
        # Apps list with loading indicator
        self.apps_list = QListWidget()
        self.apps_list.setStyleSheet(f"""
            QListWidget {{
                background-color: {self.color_scheme.SURFACE};
                border: 1px solid {self.color_scheme.BORDER};
                border-radius: 8px;
            }}
            QListWidget::item {{
                padding: 8px;
                border-bottom: 1px solid {self.color_scheme.BORDER}30;
                color: {self.color_scheme.TEXT_PRIMARY};
                font-size: 12px;
            }}
            QListWidget::item:selected {{
                background-color: {self.color_scheme.ACCENT}40;
                color: {self.color_scheme.ACCENT};
            }}
        """)
        self.apps_list.itemDoubleClicked.connect(self.use_selected_app)
        
        # Add loading placeholder
        self.loading_item = QListWidgetItem("üì¶ Loading applications...")
        self.loading_item.setForeground(QColor(self.color_scheme.TEXT_MUTED))
        self.apps_list.addItem(self.loading_item)
        
        main_layout.addWidget(self.apps_list)
        
        # Quick add common apps
        quick_label = QLabel("Quick add:")
        quick_label.setStyleSheet(f"""
            color: {self.color_scheme.TEXT_SECONDARY};
            font-weight: bold;
            margin-top: 5px;
            font-size: 12px;
        """)
        main_layout.addWidget(quick_label)
        
        # Quick add buttons in a grid
        quick_grid = QGridLayout()
        quick_grid.setSpacing(4)
        
        common_apps = [
            ("Package Manager", "eco_pac", "eco_pac"),
            ("System Monitor", "eco_sys", "üíª"),
            ("Game Recorder", "eco_rec", "üìÅ"),
            ("*", "", "üé¨"),
            ("*", "", "‚ö°"),
            ("*", "", "‚öôÔ∏è"),
            ("*", "", "üßÆ"),
            ("*", "", "üé®"),
        ]
        
        for i, (name, cmd, icon) in enumerate(common_apps):
            row = i // 4
            col = i % 4
            
            btn = QPushButton(f"{icon} {name}")
            btn.setToolTip(f"Add {name} ({cmd})")
            btn.clicked.connect(lambda checked, n=name, c=cmd: self.add_quick_app(n, c))
            btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: {self.color_scheme.SURFACE};
                    color: {self.color_scheme.TEXT_PRIMARY};
                    border: 1px solid {self.color_scheme.BORDER};
                    border-radius: 6px;
                    padding: 6px;
                    font-size: 10px;
                }}
                QPushButton:hover {{
                    background-color: {self.color_scheme.SURFACE_HOVER};
                    border: 1px solid {self.color_scheme.ACCENT};
                }}
            """)
            quick_grid.addWidget(btn, row, col)
        
        main_layout.addLayout(quick_grid)
        
        # Custom app section
        custom_label = QLabel("Custom command:")
        custom_label.setStyleSheet(f"""
            color: {self.color_scheme.TEXT_SECONDARY};
            font-weight: bold;
            margin-top: 5px;
            font-size: 12px;
        """)
        main_layout.addWidget(custom_label)
        
        custom_layout = QHBoxLayout()
        custom_layout.setSpacing(4)
        
        self.custom_name = QLineEdit()
        self.custom_name.setPlaceholderText("Name")
        self.custom_name.setMinimumWidth(150)
        custom_layout.addWidget(self.custom_name)
        
        self.custom_cmd = QLineEdit()
        self.custom_cmd.setPlaceholderText("Command (e.g., firefox)")
        custom_layout.addWidget(self.custom_cmd)
        
        add_custom_btn = QPushButton("Add")
        add_custom_btn.clicked.connect(self.add_custom)
        add_custom_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: {self.color_scheme.SUCCESS};
                color: {self.color_scheme.BACKGROUND};
                border: none;
                border-radius: 6px;
                padding: 8px 12px;
                font-weight: bold;
                font-size: 11px;
            }}
            QPushButton:hover {{ background-color: {self.color_scheme.SUCCESS}DD; }}
        """)
        custom_layout.addWidget(add_custom_btn)
        
        main_layout.addLayout(custom_layout)
        
        # Bottom buttons
        btn_layout = QHBoxLayout()
        btn_layout.setSpacing(8)
        
        use_btn = QPushButton("üíæ Use Selected")
        use_btn.clicked.connect(self.use_selected_app)
        use_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: {self.color_scheme.SUCCESS};
                color: {self.color_scheme.BACKGROUND};
                border: none;
                border-radius: 8px;
                padding: 10px 15px;
                font-weight: bold;
                font-size: 12px;
            }}
            QPushButton:hover {{ background-color: {self.color_scheme.SUCCESS}DD; }}
        """)
        
        cancel_btn = QPushButton("‚úï Cancel")
        cancel_btn.clicked.connect(self.reject)
        cancel_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: {self.color_scheme.ERROR};
                color: {self.color_scheme.BACKGROUND};
                border: none;
                border-radius: 8px;
                padding: 10px 15px;
                font-weight: bold;
                font-size: 12px;
            }}
            QPushButton:hover {{ background-color: {self.color_scheme.ERROR}DD; }}
        """)
        
        btn_layout.addWidget(use_btn)
        btn_layout.addStretch()
        btn_layout.addWidget(cancel_btn)
        
        main_layout.addLayout(btn_layout)
        self.setLayout(main_layout)
        self.setStyleSheet(f"QDialog {{ background-color: {self.color_scheme.BACKGROUND}; }}")
    
    def load_apps_async(self):
        """Load apps in background thread"""
        self.app_loader = AppLoaderThread()
        self.app_loader.apps_loaded.connect(self.on_apps_loaded)
        self.app_loader.start()
    
    def on_apps_loaded(self, apps):
        """Callback when apps are loaded"""
        # Remove loading item
        if self.loading_item:
            self.apps_list.takeItem(0)
            self.loading_item = None
        
        # Clear previous items
        self.app_items.clear()
        
        # Add apps to list
        for app in apps:
            name = app.get('Name', 'Unknown')
            comment = app.get('Comment', '')
            
            item_text = f"{name}"
            if comment and len(comment) < 50:  # Limit comment length
                item_text += f" - {comment}"
            
            item = QListWidgetItem(item_text)
            item.setData(Qt.ItemDataRole.UserRole, app)
            
            # Store for quick lookup
            self.app_items[name.lower()] = item
            
            # Load icon in background
            icon_name = app.get('Icon', '')
            if icon_name:
                icon_loader = IconLoaderThread(icon_name)
                icon_loader.icon_loaded.connect(
                    lambda icon_name, icon_path, item=item: self.on_icon_loaded(item, icon_path)
                )
                icon_loader.start()
                self.icon_loaders.append(icon_loader)
            
            self.apps_list.addItem(item)
        
        # If no apps found
        if self.apps_list.count() == 0:
            self.apps_list.addItem("No applications found. Use custom command instead.")
    
    def on_icon_loaded(self, item, icon_path):
        """Callback when icon is loaded"""
        if icon_path and os.path.exists(icon_path):
            try:
                icon = QIcon(icon_path)
                if not icon.isNull():
                    item.setIcon(icon)
            except:
                pass
    
    def on_search_changed(self):
        """Handle search text changes - optimized"""
        search_text = self.search_edit.text().strip().lower()
        
        if not search_text:
            # Show all apps
            for i in range(self.apps_list.count()):
                self.apps_list.item(i).setHidden(False)
            return
        
        # If we have cached items, use them
        if not search_text:
            return
        
        # Show only matching items
        for i in range(self.apps_list.count()):
            item = self.apps_list.item(i)
            if item:
                text = item.text().lower()
                item.setHidden(search_text not in text)
    
    def add_quick_app(self, name, command):
        """Add quick application"""
        self.selected_app_info = {
            'Name': name,
            'Exec': command,
            'Icon': command if '/' not in command else os.path.basename(command).split('.')[0],
            'Categories': 'QuickAdd'
        }
        self.accept()
    
    def add_custom(self):
        """Add custom application"""
        command = self.custom_cmd.text().strip()
        name = self.custom_name.text().strip()
        
        if not command:
            QMessageBox.warning(self, "Missing Command", "Please enter a command")
            return
        
        if not name:
            # Use command as name
            name = os.path.basename(command).split('.')[0]
            name = name.replace('-', ' ').replace('_', ' ').title()
        
        self.selected_app_info = {
            'Name': name,
            'Exec': command,
            'Icon': command if '/' not in command else os.path.basename(command).split('.')[0],
            'Categories': 'Custom'
        }
        self.accept()
    
    def use_selected_app(self):
        """Use selected application"""
        selected = self.apps_list.selectedItems()
        if selected:
            item = selected[0]
            self.selected_app_info = item.data(Qt.ItemDataRole.UserRole)
            if self.selected_app_info:
                self.accept()
            else:
                QMessageBox.warning(self, "Invalid Selection", "Please select a valid application")
        else:
            QMessageBox.warning(self, "No Selection", "Please select an application or use custom command")
    
    def get_app_info(self):
        return self.selected_app_info
    
    def closeEvent(self, event):
        """Clean up threads when dialog closes"""
        # Cancel any running icon loaders
        for loader in self.icon_loaders:
            if loader.isRunning():
                loader.terminate()
                loader.wait()
        super().closeEvent(event)

class SimpleVideoDialog(QDialog):
    def __init__(self, video_dir=None, color_scheme=None, parent=None):
        super().__init__(parent)
        self.color_scheme = color_scheme or ColorScheme()
        self.video_dir = video_dir or os.path.expanduser("~/Videos")
        self.setWindowTitle("üé¨ Videos")
        self.setFixedSize(500, 400)
        self.setup_ui()
    
    def setup_ui(self):
        layout = QVBoxLayout()
        layout.setSpacing(8)
        layout.setContentsMargins(10, 10, 10, 10)
        
        header = QLabel("üé¨ Video Player")
        header.setAlignment(Qt.AlignmentFlag.AlignCenter)
        header.setStyleSheet(f"""
            QLabel {{
                color: {self.color_scheme.ACCENT};
                font-size: 16px;
                font-weight: bold;
                padding: 12px;
                background-color: {self.color_scheme.SURFACE};
                border-radius: 8px;
                border: 1px solid {self.color_scheme.BORDER};
            }}
        """)
        layout.addWidget(header)
        
        self.video_list = QListWidget()
        self.video_list.setStyleSheet(f"""
            QListWidget {{
                background-color: {self.color_scheme.SURFACE};
                border: 1px solid {self.color_scheme.BORDER};
                border-radius: 8px;
            }}
            QListWidget::item {{
                padding: 8px;
                border-bottom: 1px solid {self.color_scheme.BORDER}30;
                color: {self.color_scheme.TEXT_PRIMARY};
                font-size: 12px;
            }}
            QListWidget::item:selected {{
                background-color: {self.color_scheme.ACCENT}40;
                color: {self.color_scheme.ACCENT};
            }}
        """)
        
        self.load_video_files()
        layout.addWidget(self.video_list)
        
        btn_layout = QHBoxLayout()
        btn_layout.setSpacing(10)
        
        play_btn = QPushButton("‚ñ∂Ô∏è Play with MPV")
        play_btn.setFixedHeight(40)
        play_btn.clicked.connect(self.play_video)
        self.style_button(play_btn, self.color_scheme.SUCCESS)
        
        refresh_btn = QPushButton("üîÑ Refresh")
        refresh_btn.setFixedHeight(40)
        refresh_btn.clicked.connect(self.load_video_files)
        self.style_button(refresh_btn, self.color_scheme.ACCENT)
        
        close_btn = QPushButton("‚úï Close")
        close_btn.setFixedHeight(40)
        close_btn.clicked.connect(self.reject)
        self.style_button(close_btn, self.color_scheme.ERROR)
        
        btn_layout.addWidget(play_btn)
        btn_layout.addWidget(refresh_btn)
        btn_layout.addStretch()
        btn_layout.addWidget(close_btn)
        
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        self.setStyleSheet(f"QDialog {{ background-color: {self.color_scheme.BACKGROUND}; }}")
    
    def style_button(self, button, color):
        button.setStyleSheet(f"""
            QPushButton {{
                background-color: {color};
                color: {self.color_scheme.BACKGROUND};
                border: none;
                border-radius: 8px;
                padding: 10px;
                font-size: 13px;
                font-weight: bold;
            }}
            QPushButton:hover {{ background-color: {color}DD; }}
        """)
    
    def load_video_files(self):
        self.video_list.clear()
        
        if not os.path.exists(self.video_dir):
            self.video_list.addItem("‚ö†Ô∏è Directory not found")
            return
        
        video_extensions = ['.mp4', '.mkv', '.avi', '.mov', '.webm', '.flv', '.wmv', '.m4v']
        video_files = []
        
        try:
            for file in os.listdir(self.video_dir):
                file_path = os.path.join(self.video_dir, file)
                if os.path.isfile(file_path):
                    if any(file.lower().endswith(ext) for ext in video_extensions):
                        video_files.append(file_path)
        except:
            pass
        
        if not video_files:
            self.video_list.addItem("No video files found")
            return
        
        video_files.sort()
        for video_path in video_files:
            filename = os.path.basename(video_path)
            size = os.path.getsize(video_path)
            
            if size > 1024*1024*1024:
                size_str = f"{size/1024/1024/1024:.1f} GB"
            elif size > 1024*1024:
                size_str = f"{size/1024/1024:.1f} MB"
            else:
                size_str = f"{size/1024:.1f} KB"
            
            item = QListWidgetItem(f"üé¨ {filename} ({size_str})")
            item.setData(Qt.ItemDataRole.UserRole, video_path)
            self.video_list.addItem(item)
    
    def play_video(self):
        selected = self.video_list.selectedItems()
        if not selected:
            QMessageBox.warning(self, "No Selection", "Please select a video to play")
            return
        
        item = selected[0]
        video_path = item.data(Qt.ItemDataRole.UserRole)
        
        try:
            result = subprocess.run(['which', 'mpv'], capture_output=True, text=True)
            if result.returncode != 0:
                QMessageBox.warning(self, "MPV Not Found", 
                    "MPV is not installed.\n\nInstall: sudo pacman -S mpv")
                return
            
            subprocess.Popen(['mpv', video_path], start_new_session=True)
            self.accept()
            
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Failed to launch MPV")

class FloatingMenu(QMainWindow):
    def __init__(self):
        super().__init__()
        self.launchers = []
        self.color_scheme = ColorScheme()
        self.config_file = os.path.join(os.path.expanduser("~"), "Documents", "floating_menu_config.json")
        self.setup_window()
        self.setup_ui()
        self.apply_theme()
        self.load_config()
    
        # Add this check for first run
        #self.config_file = "floating_menu_config.json"
        
        # Check if this is the VERY FIRST TIME running
        if not os.path.exists(self.config_file):
            # First time ever - enable auto-start once
            success, _ = AutoStartManager.enable_autostart()
            if success:
                print("Auto-start enabled for first launch")
        
        # Now load the config
        self.load_config()
        self.update_autostart_indicator()


    
    def setup_window(self):
        self.setWindowFlags(
            Qt.WindowType.FramelessWindowHint |
            Qt.WindowType.WindowStaysOnTopHint |
            Qt.WindowType.Tool
        )
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.setFixedSize(225, 450)
        
        # Get screen geometry
        screen_geometry = QApplication.primaryScreen().geometry()
        
        # Position window 80px down from top (adjust as needed)
        self.move(screen_geometry.width() - self.width() - 0, 47)
        
        self.dragging = False
        self.drag_position = QPoint()
    
    def setup_ui(self):
        central_widget = QWidget()
        central_widget.setObjectName("centralWidget")
        self.setCentralWidget(central_widget)
        
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(6)
        
        # Title bar
        title_bar = QWidget()
        title_bar.setFixedHeight(32)
        title_bar.setObjectName("titleBar")
        title_layout = QHBoxLayout(title_bar)
        title_layout.setContentsMargins(10, 0, 10, 0)
        title_layout.setSpacing(4)
        
        title_label = QLabel("üöÄ Smart Launcher")
        title_label.setStyleSheet(f"color: {self.color_scheme.ACCENT}; font-weight: bold; font-size: 12px;")
        title_layout.addWidget(title_label)
        title_layout.addStretch()
        
        self.settings_btn = self.create_control_button("‚öôÔ∏è", "Settings", self.color_scheme.ACCENT, 24)
        self.settings_btn.clicked.connect(self.show_settings)
        title_layout.addWidget(self.settings_btn)
        
        self.pin_btn = self.create_control_button("üìå", "Pin", self.color_scheme.WARNING, 24)
        self.pin_btn.setCheckable(True)
        self.pin_btn.setChecked(True)
        self.pin_btn.clicked.connect(self.toggle_pin)
        title_layout.addWidget(self.pin_btn)
        
        self.close_btn = self.create_control_button("‚úï", "Close", self.color_scheme.ERROR, 24)
        self.close_btn.clicked.connect(self.close_window)
        title_layout.addWidget(self.close_btn)
        
        main_layout.addWidget(title_bar)
        
        # Search
        search_layout = QHBoxLayout()
        search_layout.setSpacing(4)
        search_icon = QLabel("üîç")
        search_icon.setStyleSheet("font-size: 11px;")
        search_layout.addWidget(search_icon)
        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText("Search launchers...")
        self.search_bar.setStyleSheet(f"""
            QLineEdit {{
                background-color: {self.color_scheme.SURFACE};
                color: {self.color_scheme.TEXT_PRIMARY};
                border: 1px solid {self.color_scheme.BORDER};
                border-radius: 6px;
                padding: 5px;
                font-size: 11px;
            }}
        """)
        self.search_bar.textChanged.connect(self.filter_launchers)
        search_layout.addWidget(self.search_bar)
        main_layout.addLayout(search_layout)
        
        # Scroll area for launchers
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        
        scroll_area.setStyleSheet(f"""
            QScrollArea {{
                border: none;
                background: transparent;
            }}
            QScrollBar:vertical {{
                background: {self.color_scheme.SURFACE};
                width: 8px;
                border-radius: 4px;
            }}
            QScrollBar::handle:vertical {{
                background: {self.color_scheme.ACCENT};
                border-radius: 4px;
                min-height: 20px;
            }}
        """)
        
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)
        self.scroll_layout.setContentsMargins(0, 0, 2, 0)
        self.scroll_layout.setSpacing(2)
        self.scroll_layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        
        scroll_area.setWidget(self.scroll_content)
        main_layout.addWidget(scroll_area)
        
        # Bottom buttons
        bottom_layout = QHBoxLayout()
        bottom_layout.setSpacing(8)
        
        video_btn = QPushButton("üé¨ Videos")
        video_btn.setMinimumHeight(36)
        video_btn.clicked.connect(self.show_video_dialog)
        self.style_large_button(video_btn, self.color_scheme.CYAN)
        
        add_btn = QPushButton("‚ûï Add Fast")
        add_btn.setMinimumHeight(36)
        add_btn.clicked.connect(self.show_fast_add_dialog)
        self.style_large_button(add_btn, self.color_scheme.ACCENT)
        
        bottom_layout.addWidget(video_btn)
        bottom_layout.addWidget(add_btn)
        bottom_layout.addStretch()
        
        self.autostart_indicator = QLabel()
        self.update_autostart_indicator()
        bottom_layout.addWidget(self.autostart_indicator)
        
        main_layout.addLayout(bottom_layout)
        
        self.setup_tray_icon()
    


    def enable_xfce4_autostart(self):
        """Enable auto-start specifically for XFCE4"""
        # XFCE4 uses a different location
        xfce4_autostart_dir = os.path.expanduser('~/.config/autostart')
        os.makedirs(xfce4_autostart_dir, exist_ok=True)
        
        desktop_file = os.path.join(xfce4_autostart_dir, "FloatingMenu.desktop")
        script_path = os.path.abspath(sys.argv[0])
        
        desktop_content = f"""[Desktop Entry]
    Type=Application
    Name=Floating Menu
    Exec={sys.executable} "{script_path}"
    Terminal=false
    Hidden=false
    X-GNOME-Autostart-enabled=true
    Comment=Floating Menu Launcher
    Icon=application-x-executable
    """
        
        # Create the auto-start file
        try:
            with open(desktop_file, 'w') as f:
                f.write(desktop_content)
            os.chmod(desktop_file, 0o755)
            print(f"XFCE4 auto-start enabled: {desktop_file}")
            
            # Update UI indicator
            self.autostart_indicator.setText("üîó")
            self.autostart_indicator.setToolTip("Auto-start enabled (XFCE4)")
            self.autostart_indicator.setStyleSheet(f"color: {self.color_scheme.SUCCESS}; font-size: 14px;")
        except Exception as e:
            print(f"Failed to enable XFCE4 auto-start: {e}")




    def create_control_button(self, icon, tooltip, color, size=22):
        btn = QPushButton(icon)
        btn.setFixedSize(size, size)
        btn.setToolTip(tooltip)
        btn.setCursor(Qt.CursorShape.PointingHandCursor)
        btn.setStyleSheet(f"""
            QPushButton {{
                background-color: {color}30;
                color: {color};
                border: 1px solid {color}50;
                border-radius: 4px;
                font-size: 10px;
                padding: 0px;
            }}
            QPushButton:hover {{
                background-color: {color}60;
                border: 1px solid {color};
            }}
        """)
        return btn
    
    def style_large_button(self, button, color):
        button.setStyleSheet(f"""
            QPushButton {{
                background-color: {color};
                color: {self.color_scheme.BACKGROUND};
                border: none;
                border-radius: 8px;
                padding: 10px 15px;
                font-size: 12px;
                font-weight: bold;
            }}
            QPushButton:hover {{ background-color: {color}DD; }}
        """)
    
    def apply_theme(self):
        self.setStyleSheet(f"""
            QMainWindow {{ background: transparent; }}
            #centralWidget {{
                background-color: {self.color_scheme.BACKGROUND};
                border: 1px solid {self.color_scheme.BORDER};
                border-radius: 12px;
            }}
            #titleBar {{
                background-color: {self.color_scheme.SURFACE};
                border-radius: 10px 10px 0 0;
            }}
        """)
    
    def update_autostart_indicator(self):
        if AutoStartManager.is_autostart_enabled():
            self.autostart_indicator.setText("üîó")
            self.autostart_indicator.setToolTip("Auto-start enabled")
            self.autostart_indicator.setStyleSheet(f"color: {self.color_scheme.SUCCESS}; font-size: 14px;")
        else:
            self.autostart_indicator.setText("")
            self.autostart_indicator.setToolTip("Auto-start disabled")
    
    def setup_tray_icon(self):
        self.tray_icon = QSystemTrayIcon(self)
        pixmap = QPixmap(24, 24)
        pixmap.fill(Qt.GlobalColor.transparent)
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        painter.setBrush(QBrush(QColor(self.color_scheme.ACCENT)))
        painter.setPen(Qt.PenStyle.NoPen)
        painter.drawEllipse(2, 2, 20, 20)
        painter.end()
        self.tray_icon.setIcon(QIcon(pixmap))
        
        tray_menu = QMenu()
        
        show_action = tray_menu.addAction("Show Menu")
        show_action.triggered.connect(self.show_menu)
        
        add_action = tray_menu.addAction("Add Fast Launcher")
        add_action.triggered.connect(self.show_fast_add_dialog)
        
        video_action = tray_menu.addAction("Videos")
        video_action.triggered.connect(self.show_video_dialog)
        
        tray_menu.addSeparator()
        
        self.autostart_action = tray_menu.addAction("Auto-start on Login")
        self.autostart_action.setCheckable(True)
        self.autostart_action.setChecked(AutoStartManager.is_autostart_enabled())
        self.autostart_action.triggered.connect(self.toggle_autostart)
        
        tray_menu.addSeparator()
        
        quit_action = tray_menu.addAction("Quit")
        quit_action.triggered.connect(self.quit_application)
        
        self.tray_icon.setContextMenu(tray_menu)
        self.tray_icon.show()
        self.tray_icon.activated.connect(self.tray_icon_activated)
    
    def toggle_autostart(self, checked):
        if checked:
            success, message = AutoStartManager.enable_autostart()
            if success:
                self.tray_icon.showMessage("Auto-start", "Enabled", QSystemTrayIcon.MessageIcon.Information, 1500)
            else:
                self.autostart_action.setChecked(False)
        else:
            success, message = AutoStartManager.disable_autostart()
            if success:
                self.tray_icon.showMessage("Auto-start", "Disabled", QSystemTrayIcon.MessageIcon.Information, 1500)
            else:
                self.autostart_action.setChecked(True)
        
        self.update_autostart_indicator()
    
    def show_fast_add_dialog(self):
        """Show the fast add dialog"""
        dialog = FastAddDialog(color_scheme=self.color_scheme, parent=self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            app_info = dialog.get_app_info()
            if app_info:
                self.add_launcher_from_app_info(app_info)
    
    def add_launcher_from_app_info(self, app_info):
        """Add launcher from app info"""
        name = app_info.get('Name', '').strip()
        command = app_info.get('Exec', '').strip()
        icon = app_info.get('Icon', '').strip()
        
        if not name or not command:
            return
        
        # Check if launcher already exists
        for launcher in self.launchers:
            if launcher.get('name') == name or launcher.get('command') == command:
                QMessageBox.information(self, "Already Exists", 
                    f"Launcher '{name}' already exists")
                return
        
        # Add to launchers
        self.launchers.append({
            "name": name,
            "command": command,
            "icon": icon,
            "app_info": app_info
        })
        
        self.save_config()
        self.refresh_launchers()
        
        self.tray_icon.showMessage("Launcher Added", 
            f"Added '{name}' to your launchers", 
            QSystemTrayIcon.MessageIcon.Information, 2000)
    
    def show_video_dialog(self):
        dialog = SimpleVideoDialog(color_scheme=self.color_scheme, parent=self)
        dialog.exec()
    
    def show_settings(self):
        menu = QMenu(self)
        
        pin_action = menu.addAction("Always on Top")
        pin_action.setCheckable(True)
        pin_action.setChecked(True)
        pin_action.triggered.connect(lambda checked: self.toggle_pin(checked))
        
        menu.addSeparator()
        
        autostart_action = menu.addAction("Auto-start on Login")
        autostart_action.setCheckable(True)
        autostart_action.setChecked(AutoStartManager.is_autostart_enabled())
        autostart_action.triggered.connect(self.toggle_autostart)
        
        menu.addSeparator()
        
        edit_action = menu.addAction("Edit Launchers")
        edit_action.triggered.connect(self.edit_launchers)
        
        refresh_action = menu.addAction("üîÑ Refresh System Apps")
        refresh_action.triggered.connect(self.refresh_system_apps_cache)
        
        menu.addSeparator()
        
        close_action = menu.addAction("Close Window")
        close_action.triggered.connect(self.close_window)
        
        menu.exec(self.mapToGlobal(QPoint(self.width() - 150, 30)))
    
    def refresh_system_apps_cache(self):
        """Refresh system apps cache"""
        AppDetector.refresh_cache()
        QMessageBox.information(self, "Cache Refreshed", 
            "System applications cache has been refreshed.")
    
    def toggle_pin(self, checked=None):
        if checked is None:
            checked = not self.pin_btn.isChecked()
            self.pin_btn.setChecked(checked)
        
        if checked:
            self.setWindowFlags(self.windowFlags() | Qt.WindowType.WindowStaysOnTopHint)
        else:
            self.setWindowFlags(self.windowFlags() & ~Qt.WindowType.WindowStaysOnTopHint)
        self.show()
    
    def close_window(self):
        reply = QMessageBox.question(
            self, 'Close Menu',
            "Close the menu?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            self.save_config()
            QApplication.quit()
    
    def edit_launchers(self):
        dialog = QDialog(self)
        dialog.setWindowTitle("Edit Launchers")
        dialog.setFixedSize(400, 350)
        layout = QVBoxLayout()
        
        list_widget = QListWidget()
        for launcher in self.launchers:
            item_text = f"{launcher.get('name', 'Unknown')}"
            if 'icon' in launcher and launcher['icon']:
                icon_path = AppDetector.find_application_icon(launcher['icon'])
                if icon_path:
                    icon = QIcon(icon_path)
                    if not icon.isNull():
                        item = QListWidgetItem(icon, item_text)
                        list_widget.addItem(item)
                        continue
            
            list_widget.addItem(QListWidgetItem(item_text))
        
        layout.addWidget(list_widget)
        
        btn_layout = QHBoxLayout()
        delete_btn = QPushButton("üóëÔ∏è Delete")
        delete_btn.setMinimumHeight(35)
        delete_btn.clicked.connect(lambda: self.delete_launcher(list_widget))
        self.style_large_button(delete_btn, self.color_scheme.ERROR)
        
        close_btn = QPushButton("‚úÖ Done")
        close_btn.setMinimumHeight(35)
        close_btn.clicked.connect(dialog.accept)
        self.style_large_button(close_btn, self.color_scheme.SUCCESS)
        
        btn_layout.addWidget(delete_btn)
        btn_layout.addWidget(close_btn)
        
        layout.addLayout(btn_layout)
        dialog.setLayout(layout)
        dialog.exec()
    
    def delete_launcher(self, list_widget):
        selected = list_widget.selectedItems()
        if selected:
            index = list_widget.row(selected[0])
            launcher_name = self.launchers[index].get('name', 'Unknown')
            
            reply = QMessageBox.question(
                self, 'Delete Launcher',
                f"Delete '{launcher_name}'?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                del self.launchers[index]
                self.save_config()
                self.refresh_launchers()
                list_widget.takeItem(index)
    
    def refresh_launchers(self):
        """Refresh launcher buttons with icons"""
        for i in reversed(range(self.scroll_layout.count())):
            widget = self.scroll_layout.itemAt(i).widget()
            if widget:
                widget.deleteLater()
        
        for launcher in self.launchers:
            # Create button with icon
            btn = FastIconButton(
                text=f"  {launcher.get('name', '')}",
                app_info=launcher.get('app_info', {}),
                color_scheme=self.color_scheme,
                parent=self
            )
            
            # If no app_info in launcher, create minimal one
            if not launcher.get('app_info'):
                btn.app_info = {
                    'Name': launcher.get('name', ''),
                    'Icon': launcher.get('icon', ''),
                    'Exec': launcher.get('command', '')
                }
            
            btn.clicked.connect(lambda checked, cmd=launcher.get('command', ''): self.launch_application(cmd))
            
            # Add context menu for each launcher
            btn.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            btn.customContextMenuRequested.connect(
                lambda pos, l=launcher: self.show_launcher_context_menu(btn, l, pos)
            )
            
            self.scroll_layout.addWidget(btn)
    
    def show_launcher_context_menu(self, button, launcher, pos):
        """Show context menu for launcher"""
        menu = QMenu(self)
        
        edit_action = menu.addAction("‚úèÔ∏è Edit")
        edit_action.triggered.connect(lambda: self.edit_single_launcher(launcher))
        
        delete_action = menu.addAction("üóëÔ∏è Delete")
        delete_action.triggered.connect(lambda: self.delete_single_launcher(launcher))
        
        menu.addSeparator()
        
        run_action = menu.addAction("üöÄ Run")
        run_action.triggered.connect(lambda: self.launch_application(launcher.get('command', '')))
        
        menu.exec(button.mapToGlobal(pos))
    
    def edit_single_launcher(self, launcher):
        """Edit a single launcher"""
        dialog = FastAddDialog(color_scheme=self.color_scheme, parent=self)
        
        # Pre-fill with existing data
        if hasattr(dialog, 'custom_name'):
            dialog.custom_name.setText(launcher.get('name', ''))
            dialog.custom_cmd.setText(launcher.get('command', ''))
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            app_info = dialog.get_app_info()
            if app_info:
                # Update existing launcher
                index = self.launchers.index(launcher)
                self.launchers[index] = {
                    "name": app_info.get('Name', ''),
                    "command": app_info.get('Exec', ''),
                    "icon": app_info.get('Icon', ''),
                    "app_info": app_info
                }
                self.save_config()
                self.refresh_launchers()
    
    def delete_single_launcher(self, launcher):
        """Delete a single launcher"""
        reply = QMessageBox.question(
            self, 'Delete Launcher',
            f"Delete '{launcher.get('name', 'Unknown')}'?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            self.launchers.remove(launcher)
            self.save_config()
            self.refresh_launchers()
    
    def launch_application(self, command):
        """Launch application with error handling"""
        try:
            if command:
                subprocess.Popen(command, shell=True, start_new_session=True)
        except Exception as e:
            QMessageBox.warning(self, "Launch Error", 
                f"Failed to launch application:\n{str(e)}")
    
    def filter_launchers(self, text):
        """Filter launchers based on search text"""
        for i in range(self.scroll_layout.count()):
            widget = self.scroll_layout.itemAt(i).widget()
            if isinstance(widget, FastIconButton):
                widget.setVisible(text.lower() in widget.text().lower())
    
    def save_config(self):
        """Save launchers to config file"""
        try:
            # Remove app_info before saving (it's not JSON serializable)
            launchers_to_save = []
            for launcher in self.launchers:
                launcher_copy = launcher.copy()
                launcher_copy.pop('app_info', None)  # Remove app_info
                launchers_to_save.append(launcher_copy)
            
            with open(self.config_file, 'w') as f:
                json.dump(launchers_to_save, f, indent=2)
        except Exception as e:
            print(f"Save config error: {e}")
    
    def load_config(self):
        """Load launchers from config file"""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f:
                    loaded_launchers = json.load(f)
                
                # Try to find app_info for each launcher
                for launcher in loaded_launchers:
                    # Try to find matching system app
                    if launcher.get('command'):
                        system_apps = AppDetector.get_system_applications()
                        for app in system_apps:
                            if app.get('Exec') == launcher.get('command'):
                                launcher['app_info'] = app
                                break
                
                self.launchers = loaded_launchers
            else:
                # Create intelligent default launchers
                self.create_intelligent_defaults()
                self.save_config()
            
            self.refresh_launchers()
        except Exception as e:
            print(f"Load config error: {e}")
            self.create_intelligent_defaults()
    
    def create_intelligent_defaults(self):
        """Create intelligent default launchers"""
        self.launchers = []
        
        # Quick defaults that don't require scanning
        quick_defaults = [
            ("Package Manager", "eco_pac", "eco_pac"),
            ("System Monitor", "eco_sys", ""),
            ("Game Recorder", "eco_rec", ""),
            ("*", "", ""),
            ("*", "", ""),
            ("*", "", ""),
        ]
        
        for name, command, icon in quick_defaults:
            self.launchers.append({
                "name": name,
                "command": command,
                "icon": icon,
                "app_info": {
                    'Name': name,
                    'Exec': command,
                    'Icon': icon,
                    'Categories': 'Default'
                }
            })
    
    def show_menu(self):
        self.show()
        self.raise_()
        self.activateWindow()
    
    def tray_icon_activated(self, reason):
        if reason == QSystemTrayIcon.ActivationReason.Trigger:
            self.show_menu()
    
    def quit_application(self):
        self.save_config()
        self.tray_icon.hide()
        QApplication.quit()
    
    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton and event.pos().y() < 40:
            self.dragging = True
            self.drag_position = event.globalPosition().toPoint() - self.frameGeometry().topLeft()
    
    def mouseMoveEvent(self, event):
        if self.dragging and event.buttons() & Qt.MouseButton.LeftButton:
            self.move(event.globalPosition().toPoint() - self.drag_position)
    
    def mouseReleaseEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self.dragging = False

def main():
    app = QApplication(sys.argv)
    app.setQuitOnLastWindowClosed(False)
    app.setApplicationName("Smart Floating Menu")
    
    window = FloatingMenu()
    window.show()
    
    sys.exit(app.exec())

if __name__ == "__main__":
    main()