#!/usr/bin/env python3
import sys
import os
import subprocess
import time
import re
from datetime import datetime
from PyQt5.QtWidgets import QApplication, QSystemTrayIcon, QMenu, QAction, QMessageBox
from PyQt5.QtGui import QIcon
from PyQt5.QtCore import QThread, pyqtSignal, QTimer

# ================== CONFIGURATION ==================
CHECK_INTERVAL_MIN = 30
USE_AUR = True
LOG_FILE = os.path.expanduser("~/.local/log/arch-updater-xfce-notifications.log")
ERROR_NOTIFICATION_TIMEOUT_MS = 10000  # 10 seconds
# ==================================================

os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)

def log(msg):
    with open(LOG_FILE, "a") as f:
        f.write(f"[{datetime.now().isoformat()}] {msg}\n")

def notify(title, message, urgency="normal", timeout=0):
    """Send a desktop notification with optional timeout."""
    try:
        cmd = [
            "notify-send", "-u", urgency, "-i", "system-software-update",
            title, message
        ]
        if timeout > 0:
            cmd.extend(["-t", str(timeout)])
        
        subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except Exception as e:
        log(f"Notification failed: {e}")

class UpgradeWorker(QThread):
    finished = pyqtSignal(bool)
    progress = pyqtSignal(str)

    def run(self):
        try:
            # Get list of packages to estimate count
            repo_pkgs = []
            aur_pkgs = []
            repo_code, repo_out = subprocess.getstatusoutput("pacman -Qu")
            if repo_code == 0 and repo_out.strip():
                repo_pkgs = [line.split()[0] for line in repo_out.strip().splitlines()]

            if USE_AUR:
                aur_code, aur_out = subprocess.getstatusoutput("pacman -Qm")
                if aur_code == 0 and aur_out.strip():
                    aur_pkgs = [line.split()[0] for line in aur_out.strip().splitlines()]

            total = len(repo_pkgs) + len(aur_pkgs)
            if total == 0:
                self.finished.emit(True)
                return

            # Start upgrade
            process = subprocess.Popen(
                ["sudo", "pamac", "upgrade", "--no-confirm"],
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
                universal_newlines=True
            )

            completed = 0
            start_time = time.time()

            while True:
                line = process.stdout.readline()
                if not line and process.poll() is not None:
                    break
                if line:
                    log(f"pamac: {line.strip()}")
                    match = re.search(r'(?:Upgrading|Installing):\s+([^\s\(]+)', line)
                    if match:
                        completed += 1
                        pkg = match.group(1)
                        progress_msg = f"Updating ({completed}/{total}): {pkg}"
                        self.progress.emit(progress_msg)

            success = process.returncode == 0
            self.finished.emit(success)

        except Exception as e:
            log(f"Upgrade error: {e}")
            self.finished.emit(False)

class XfceNotificationUpdater:
    def __init__(self):
        self.app = QApplication(sys.argv)
        self.app.setQuitOnLastWindowClosed(False)

        self.tray_icon = QSystemTrayIcon(self._get_icon(), self.app)
        menu = QMenu()
        menu.addAction("Update Now", self.manual_update)
        menu.addAction("View Log", self.view_log)
        menu.addSeparator()
        menu.addAction("Quit", self.app.quit)
        self.tray_icon.setContextMenu(menu)
        self.tray_icon.setToolTip("Arch Updater (XFCE Notifications)")
        self.tray_icon.show()

        self.timer = QTimer()
        self.timer.timeout.connect(self.auto_update)
        self.timer.start(CHECK_INTERVAL_MIN * 60 * 1000)

        # Timer for error notification cleanup
        self.error_notification_timer = QTimer()
        self.error_notification_timer.setSingleShot(True)
        self.error_notification_timer.timeout.connect(self.clear_error_state)
        
        self.update_in_progress = False

        log("XFCE Notification Updater started.")

    def _get_icon(self):
        icon = QIcon.fromTheme("system-software-update")
        if icon.isNull():
            pixmap = QMessageBox.standardIcon(QMessageBox.Information)
            icon = QIcon(pixmap) if not pixmap.isNull() else QIcon()
        return icon

    def view_log(self):
        subprocess.Popen(["xdg-open", LOG_FILE])

    def manual_update(self):
        if not self.update_in_progress:
            self.perform_update()

    def auto_update(self):
        if not self.update_in_progress and self.has_updates():
            log("Updates detected. Installing...")
            self.perform_update()
        else:
            log("No updates or update in progress.")

    def has_updates(self):
        repo_code, repo_out = subprocess.getstatusoutput("pacman -Qu")
        if repo_code == 0 and repo_out.strip():
            return True
        if USE_AUR:
            aur_code, aur_out = subprocess.getstatusoutput("pacman -Qm")
            if aur_code == 0 and aur_out.strip():
                # Check if any AUR packages have updates
                try:
                    # Using yay for AUR update check (you might need to adjust this)
                    aur_updates_code, aur_updates_out = subprocess.getstatusoutput("yay -Qua")
                    if aur_updates_code == 0 and aur_updates_out.strip():
                        return True
                except:
                    pass
        return False

    def is_reboot_absolutely_needed(self):
        try:
            with open("/proc/uptime", "r") as f:
                if float(f.read().split()[0]) < 300:
                    return False
        except:
            pass

        for variant in ["linux", "linux-lts", "linux-zen", "linux-hardened"]:
            try:
                out = subprocess.check_output(["pacman", "-Q", variant], text=True, stderr=subprocess.DEVNULL)
                installed_ver = out.split()[1]
                running = os.uname().release
                normalized = installed_ver.replace('.arch', '-arch').replace('.lts', '-lts')
                if running == normalized:
                    return False
                base_run = '.'.join(running.replace('-', '.').split('.')[:3])
                base_inst = '.'.join(installed_ver.replace('-', '.').split('.')[:3])
                if base_run == base_inst:
                    return False
                return True
            except:
                continue
        return False

    def perform_update(self):
        self.update_in_progress = True
        notify("System Update", "Starting update...", "normal", 5000)
        self.worker = UpgradeWorker()
        self.worker.finished.connect(self.on_update_finished)
        self.worker.progress.connect(self.on_update_progress)
        self.worker.start()

    def on_update_progress(self, message):
        notify("System Update", message, "normal", 5000)

    def on_update_finished(self, success):
        self.update_in_progress = False
        
        if not success:
            # Error notification with timeout
            notify("Update Failed", "Check log for details.", "critical", ERROR_NOTIFICATION_TIMEOUT_MS)
            log("Update failed.")
            # Set timer to ensure error state is cleared
            self.error_notification_timer.start(ERROR_NOTIFICATION_TIMEOUT_MS + 1000)
            return

        # Only notify if reboot is absolutely needed
        if self.is_reboot_absolutely_needed():
            notify("Reboot Required", "Kernel updated. Reboot to use new version.", "critical", 0)  # 0 = no timeout
            log("Reboot required.")
        else:
            # Silent success - no notification
            log("Update succeeded. No reboot needed.")

    def clear_error_state(self):
        """Clear any error state to allow future updates"""
        # This method ensures the system is ready for the next update attempt
        log("Error notification timeout completed, ready for next update.")

    def run(self):
        sys.exit(self.app.exec_())

if __name__ == "__main__":
    if os.geteuid() == 0:
        print("Do not run as root.")
        sys.exit(1)
    app = XfceNotificationUpdater()
    app.run()